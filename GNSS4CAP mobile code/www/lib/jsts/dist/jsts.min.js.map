{"version":3,"sources":["../src/org/locationtech/jts/util/NumberUtil.js","../src/java/lang/IllegalArgumentException.js","../src/java/lang/Double.js","../src/java/lang/Comparable.js","../src/java/lang/Cloneable.js","../src/java/util/Comparator.js","../src/java/io/Serializable.js","../src/java/lang/RuntimeException.js","../src/org/locationtech/jts/util/AssertionFailedException.js","../src/org/locationtech/jts/util/Assert.js","../src/org/locationtech/jts/geom/Coordinate.js","../src/java/util/Iterator.js","../src/java/util/Collection.js","../src/java/util/IndexOutOfBoundsException.js","../src/java/util/List.js","../src/java/util/NoSuchElementException.js","../src/java/util/OperationNotSupported.js","../src/java/util/ArrayList.js","../src/org/locationtech/jts/geom/CoordinateList.js","../src/org/locationtech/jts/geom/Envelope.js","../src/java/lang/Exception.js","../src/org/locationtech/jts/algorithm/NotRepresentableException.js","../src/org/locationtech/jts/geom/Location.js","../src/org/locationtech/jts/math/MathUtil.js","../src/java/lang/StringBuffer.js","../src/java/lang/Integer.js","../src/java/lang/Character.js","../src/org/locationtech/jts/math/DD.js","../src/org/locationtech/jts/algorithm/CGAlgorithmsDD.js","../src/org/locationtech/jts/geom/CoordinateSequence.js","../src/java/lang/System.js","../src/org/locationtech/jts/algorithm/HCoordinate.js","../src/org/locationtech/jts/geom/CoordinateSequenceFactory.js","../src/org/locationtech/jts/geom/GeometryComponentFilter.js","../src/org/locationtech/jts/geom/Geometry.js","../src/org/locationtech/jts/geom/CoordinateFilter.js","../src/org/locationtech/jts/algorithm/BoundaryNodeRule.js","../src/org/locationtech/jts/geom/CoordinateArrays.js","../src/java/util/Map.js","../src/java/util/SortedMap.js","../src/java/util/Set.js","../src/java/util/HashSet.js","../src/java/util/TreeMap.js","../src/org/locationtech/jts/geom/Lineal.js","../src/java/util/SortedSet.js","../src/java/util/TreeSet.js","../src/java/util/Arrays.js","../src/org/locationtech/jts/geom/Dimension.js","../src/org/locationtech/jts/geom/GeometryFilter.js","../src/org/locationtech/jts/geom/CoordinateSequenceFilter.js","../src/org/locationtech/jts/geom/GeometryCollection.js","../src/org/locationtech/jts/geom/MultiLineString.js","../src/org/locationtech/jts/operation/BoundaryOp.js","../src/java/io/PrintStream.js","../src/java/io/StringReader.js","../src/java/text/DecimalFormat.js","../src/java/io/ByteArrayOutputStream.js","../src/java/io/IOException.js","../src/java/io/LineNumberReader.js","../src/org/locationtech/jts/util/StringUtil.js","../src/org/locationtech/jts/geom/CoordinateSequences.js","../src/org/locationtech/jts/geom/LineString.js","../src/org/locationtech/jts/geom/Puntal.js","../src/org/locationtech/jts/geom/Point.js","../src/org/locationtech/jts/geom/Polygonal.js","../src/org/locationtech/jts/geom/Polygon.js","../src/org/locationtech/jts/geom/MultiPoint.js","../src/org/locationtech/jts/geom/LinearRing.js","../src/org/locationtech/jts/geom/MultiPolygon.js","../src/org/locationtech/jts/geom/util/GeometryEditor.js","../src/org/locationtech/jts/geom/impl/CoordinateArraySequence.js","../src/org/locationtech/jts/geom/impl/CoordinateArraySequenceFactory.js","../src/Map.js","../src/java/util/HashMap.js","../src/org/locationtech/jts/geom/PrecisionModel.js","../src/org/locationtech/jts/geom/GeometryFactory.js","../src/org/locationtech/jts/io/WKTParser.js","../src/org/locationtech/jts/io/WKTWriter.js","../src/org/locationtech/jts/algorithm/LineIntersector.js","../src/org/locationtech/jts/algorithm/RobustLineIntersector.js","../src/org/locationtech/jts/algorithm/RobustDeterminant.js","../src/org/locationtech/jts/algorithm/RayCrossingCounter.js","../src/org/locationtech/jts/algorithm/CGAlgorithms.js","../src/org/locationtech/jts/geom/LineSegment.js","../src/org/locationtech/jts/geom/IntersectionMatrix.js","../src/org/locationtech/jts/algorithm/Centroid.js","../src/java/util/EmptyStackException.js","../src/java/util/Stack.js","../src/org/locationtech/jts/util/UniqueCoordinateArrayFilter.js","../src/org/locationtech/jts/algorithm/ConvexHull.js","../src/org/locationtech/jts/geom/util/GeometryTransformer.js","../src/org/locationtech/jts/operation/overlay/snap/LineStringSnapper.js","../src/org/locationtech/jts/operation/overlay/snap/GeometrySnapper.js","../src/org/locationtech/jts/precision/CommonBits.js","../src/org/locationtech/jts/precision/CommonBitsRemover.js","../src/org/locationtech/jts/geom/GeometryCollectionIterator.js","../src/org/locationtech/jts/algorithm/PointLocator.js","../src/org/locationtech/jts/noding/Octant.js","../src/org/locationtech/jts/noding/SegmentString.js","../src/org/locationtech/jts/noding/BasicSegmentString.js","../src/org/locationtech/jts/index/strtree/Boundable.js","../src/org/locationtech/jts/index/strtree/ItemBoundable.js","../src/org/locationtech/jts/util/PriorityQueue.js","../src/org/locationtech/jts/index/ItemVisitor.js","../src/org/locationtech/jts/index/SpatialIndex.js","../src/org/locationtech/jts/index/strtree/AbstractNode.js","../src/org/locationtech/jts/index/strtree/BoundablePair.js","../src/org/locationtech/jts/index/strtree/AbstractSTRtree.js","../src/org/locationtech/jts/index/strtree/ItemDistance.js","../src/org/locationtech/jts/index/strtree/STRtree.js","../src/org/locationtech/jts/noding/SegmentPointComparator.js","../src/org/locationtech/jts/noding/SegmentNode.js","../src/org/locationtech/jts/noding/SegmentNodeList.js","../src/org/locationtech/jts/noding/NodableSegmentString.js","../src/org/locationtech/jts/noding/NodedSegmentString.js","../src/org/locationtech/jts/index/chain/MonotoneChainOverlapAction.js","../src/org/locationtech/jts/index/chain/MonotoneChain.js","../src/org/locationtech/jts/geomgraph/Quadrant.js","../src/org/locationtech/jts/index/chain/MonotoneChainBuilder.js","../src/org/locationtech/jts/noding/Noder.js","../src/org/locationtech/jts/noding/SinglePassNoder.js","../src/org/locationtech/jts/noding/MCIndexNoder.js","../src/org/locationtech/jts/geom/TopologyException.js","../src/org/locationtech/jts/noding/SegmentIntersector.js","../src/org/locationtech/jts/noding/InteriorIntersectionFinder.js","../src/org/locationtech/jts/noding/FastNodingValidator.js","../src/org/locationtech/jts/geomgraph/EdgeNodingValidator.js","../src/org/locationtech/jts/geom/util/GeometryCollectionMapper.js","../src/org/locationtech/jts/geomgraph/Position.js","../src/org/locationtech/jts/geomgraph/TopologyLocation.js","../src/org/locationtech/jts/geomgraph/Label.js","../src/org/locationtech/jts/geomgraph/EdgeRing.js","../src/org/locationtech/jts/operation/overlay/MinimalEdgeRing.js","../src/org/locationtech/jts/operation/overlay/MaximalEdgeRing.js","../src/org/locationtech/jts/geomgraph/GraphComponent.js","../src/org/locationtech/jts/geomgraph/Node.js","../src/org/locationtech/jts/geomgraph/NodeMap.js","../src/org/locationtech/jts/geomgraph/EdgeEnd.js","../src/org/locationtech/jts/geomgraph/DirectedEdge.js","../src/org/locationtech/jts/geomgraph/NodeFactory.js","../src/org/locationtech/jts/geomgraph/PlanarGraph.js","../src/org/locationtech/jts/operation/overlay/PolygonBuilder.js","../src/org/locationtech/jts/operation/overlay/LineBuilder.js","../src/org/locationtech/jts/operation/overlay/PointBuilder.js","../src/org/locationtech/jts/algorithm/locate/PointOnGeometryLocator.js","../src/org/locationtech/jts/algorithm/locate/SimplePointInAreaLocator.js","../src/org/locationtech/jts/geomgraph/EdgeEndStar.js","../src/org/locationtech/jts/geomgraph/DirectedEdgeStar.js","../src/org/locationtech/jts/operation/overlay/OverlayNodeFactory.js","../src/org/locationtech/jts/geomgraph/index/MonotoneChain.js","../src/org/locationtech/jts/geomgraph/index/SweepLineEvent.js","../src/org/locationtech/jts/geomgraph/index/EdgeSetIntersector.js","../src/org/locationtech/jts/geomgraph/index/SegmentIntersector.js","../src/org/locationtech/jts/geomgraph/index/SimpleMCSweepLineIntersector.js","../src/org/locationtech/jts/index/intervalrtree/IntervalRTreeNode.js","../src/org/locationtech/jts/index/intervalrtree/IntervalRTreeLeafNode.js","../src/org/locationtech/jts/index/intervalrtree/IntervalRTreeBranchNode.js","../src/org/locationtech/jts/index/intervalrtree/SortedPackedIntervalRTree.js","../src/org/locationtech/jts/geom/util/LinearComponentExtracter.js","../src/org/locationtech/jts/index/ArrayListVisitor.js","../src/org/locationtech/jts/algorithm/locate/IndexedPointInAreaLocator.js","../src/org/locationtech/jts/geomgraph/EdgeIntersection.js","../src/org/locationtech/jts/geomgraph/EdgeIntersectionList.js","../src/org/locationtech/jts/geomgraph/index/MonotoneChainIndexer.js","../src/org/locationtech/jts/geomgraph/index/MonotoneChainEdge.js","../src/org/locationtech/jts/geomgraph/Depth.js","../src/org/locationtech/jts/geomgraph/Edge.js","../src/org/locationtech/jts/geomgraph/GeometryGraph.js","../src/org/locationtech/jts/operation/GeometryGraphOperation.js","../src/org/locationtech/jts/noding/OrientedCoordinateArray.js","../src/org/locationtech/jts/geomgraph/EdgeList.js","../src/org/locationtech/jts/operation/overlay/OverlayOp.js","../src/org/locationtech/jts/operation/overlay/snap/SnapOverlayOp.js","../src/org/locationtech/jts/operation/overlay/snap/SnapIfNeededOverlayOp.js","../src/org/locationtech/jts/algorithm/InteriorPointArea.js","../src/org/locationtech/jts/algorithm/InteriorPointLine.js","../src/org/locationtech/jts/algorithm/InteriorPointPoint.js","../src/org/locationtech/jts/index/chain/MonotoneChainSelectAction.js","../src/org/locationtech/jts/index/bintree/NodeBase.js","../src/org/locationtech/jts/index/bintree/Interval.js","../src/org/locationtech/jts/index/quadtree/DoubleBits.js","../src/org/locationtech/jts/index/bintree/Key.js","../src/org/locationtech/jts/index/bintree/Node.js","../src/org/locationtech/jts/index/quadtree/IntervalSize.js","../src/org/locationtech/jts/index/bintree/Root.js","../src/org/locationtech/jts/index/bintree/Bintree.js","../src/org/locationtech/jts/algorithm/PointInRing.js","../src/org/locationtech/jts/algorithm/MCPointInRing.js","../src/org/locationtech/jts/algorithm/Angle.js","../src/org/locationtech/jts/geom/Triangle.js","../src/org/locationtech/jts/algorithm/MinimumBoundingCircle.js","../src/org/locationtech/jts/algorithm/MinimumDiameter.js","../src/org/locationtech/jts/densify/Densifier.js","../src/org/locationtech/jts/edgegraph/HalfEdge.js","../src/org/locationtech/jts/edgegraph/MarkHalfEdge.js","../src/org/locationtech/jts/edgegraph/EdgeGraph.js","../src/org/locationtech/jts/dissolve/DissolveHalfEdge.js","../src/org/locationtech/jts/dissolve/DissolveEdgeGraph.js","../src/org/locationtech/jts/dissolve/LineDissolver.js","../src/org/locationtech/jts/index/quadtree/NodeBase.js","../src/org/locationtech/jts/index/quadtree/Key.js","../src/org/locationtech/jts/index/quadtree/Node.js","../src/org/locationtech/jts/index/quadtree/Root.js","../src/org/locationtech/jts/index/quadtree/Quadtree.js","../src/org/locationtech/jts/io/GeoJSONParser.js","../src/org/locationtech/jts/io/GeoJSONReader.js","../src/org/locationtech/jts/io/GeoJSONWriter.js","../src/org/locationtech/jts/io/WKTReader.js","../src/org/locationtech/jts/io/OL3Parser.js","../src/org/locationtech/jts/noding/ScaledNoder.js","../src/org/locationtech/jts/operation/IsSimpleOp.js","../src/org/locationtech/jts/operation/buffer/BufferParameters.js","../src/org/locationtech/jts/operation/buffer/RightmostEdgeFinder.js","../src/java/util/LinkedList.js","../src/org/locationtech/jts/operation/buffer/BufferSubgraph.js","../src/org/locationtech/jts/operation/buffer/BufferInputLineSimplifier.js","../src/org/locationtech/jts/operation/buffer/OffsetSegmentString.js","../src/org/locationtech/jts/operation/buffer/OffsetSegmentGenerator.js","../src/org/locationtech/jts/operation/buffer/OffsetCurveBuilder.js","../src/org/locationtech/jts/operation/buffer/SubgraphDepthLocater.js","../src/org/locationtech/jts/operation/buffer/OffsetCurveSetBuilder.js","../src/org/locationtech/jts/noding/IntersectionAdder.js","../src/org/locationtech/jts/operation/buffer/BufferBuilder.js","../src/org/locationtech/jts/noding/NodingValidator.js","../src/org/locationtech/jts/noding/snapround/HotPixel.js","../src/org/locationtech/jts/noding/snapround/MCIndexPointSnapper.js","../src/org/locationtech/jts/noding/InteriorIntersectionFinderAdder.js","../src/org/locationtech/jts/noding/snapround/MCIndexSnapRounder.js","../src/org/locationtech/jts/operation/buffer/BufferOp.js","../src/org/locationtech/jts/geom/util/PolygonExtracter.js","../src/org/locationtech/jts/operation/distance/GeometryLocation.js","../src/org/locationtech/jts/geom/util/PointExtracter.js","../src/org/locationtech/jts/operation/distance/ConnectedElementLocationFilter.js","../src/org/locationtech/jts/operation/distance/DistanceOp.js","../src/org/locationtech/jts/operation/linemerge/EdgeString.js","../src/org/locationtech/jts/planargraph/GraphComponent.js","../src/org/locationtech/jts/planargraph/DirectedEdge.js","../src/org/locationtech/jts/operation/linemerge/LineMergeDirectedEdge.js","../src/org/locationtech/jts/planargraph/Edge.js","../src/org/locationtech/jts/planargraph/DirectedEdgeStar.js","../src/org/locationtech/jts/planargraph/Node.js","../src/org/locationtech/jts/operation/linemerge/LineMergeEdge.js","../src/org/locationtech/jts/planargraph/NodeMap.js","../src/org/locationtech/jts/planargraph/PlanarGraph.js","../src/org/locationtech/jts/operation/linemerge/LineMergeGraph.js","../src/org/locationtech/jts/operation/linemerge/LineMerger.js","../src/org/locationtech/jts/operation/polygonize/PolygonizeDirectedEdge.js","../src/org/locationtech/jts/operation/polygonize/PolygonizeEdge.js","../src/org/locationtech/jts/operation/valid/ConnectedInteriorTester.js","../src/org/locationtech/jts/operation/relate/EdgeEndBuilder.js","../src/org/locationtech/jts/operation/relate/EdgeEndBundle.js","../src/org/locationtech/jts/operation/relate/EdgeEndBundleStar.js","../src/org/locationtech/jts/operation/relate/RelateNode.js","../src/org/locationtech/jts/operation/relate/RelateNodeFactory.js","../src/org/locationtech/jts/operation/relate/RelateNodeGraph.js","../src/org/locationtech/jts/operation/valid/ConsistentAreaTester.js","../src/org/locationtech/jts/operation/valid/IndexedNestedRingTester.js","../src/org/locationtech/jts/operation/valid/TopologyValidationError.js","../src/org/locationtech/jts/operation/valid/IsValidOp.js","../src/org/locationtech/jts/operation/polygonize/EdgeRing.js","../src/org/locationtech/jts/operation/polygonize/PolygonizeGraph.js","../src/org/locationtech/jts/operation/polygonize/Polygonizer.js","../src/org/locationtech/jts/operation/relate/RelateComputer.js","../src/org/locationtech/jts/operation/predicate/RectangleContains.js","../src/org/locationtech/jts/algorithm/RectangleLineIntersector.js","../src/org/locationtech/jts/geom/util/ShortCircuitedGeometryVisitor.js","../src/org/locationtech/jts/operation/predicate/RectangleIntersects.js","../src/org/locationtech/jts/operation/relate/RelateOp.js","../src/org/locationtech/jts/geom/util/GeometryCombiner.js","../src/org/locationtech/jts/operation/union/PointGeometryUnion.js","../src/org/locationtech/jts/geom/util/GeometryExtracter.js","../src/org/locationtech/jts/operation/union/CascadedPolygonUnion.js","../src/org/locationtech/jts/operation/union/UnaryUnionOp.js","../src/org/locationtech/jts/precision/PrecisionReducerCoordinateOperation.js","../src/org/locationtech/jts/precision/GeometryPrecisionReducer.js","../src/org/locationtech/jts/simplify/DouglasPeuckerLineSimplifier.js","../src/org/locationtech/jts/simplify/DouglasPeuckerSimplifier.js","../src/org/locationtech/jts/simplify/TaggedLineSegment.js","../src/org/locationtech/jts/simplify/TaggedLineString.js","../src/org/locationtech/jts/simplify/LineSegmentIndex.js","../src/org/locationtech/jts/simplify/TaggedLineStringSimplifier.js","../src/org/locationtech/jts/simplify/TaggedLinesSimplifier.js","../src/org/locationtech/jts/simplify/TopologyPreservingSimplifier.js","../src/org/locationtech/jts/triangulate/SplitSegment.js","../src/org/locationtech/jts/triangulate/ConstraintSplitPointFinder.js","../src/org/locationtech/jts/triangulate/NonEncroachingSplitPointFinder.js","../src/org/locationtech/jts/triangulate/quadedge/TrianglePredicate.js","../src/org/locationtech/jts/triangulate/quadedge/Vertex.js","../src/org/locationtech/jts/triangulate/ConstraintVertex.js","../src/org/locationtech/jts/triangulate/quadedge/QuadEdge.js","../src/org/locationtech/jts/triangulate/IncrementalDelaunayTriangulator.js","../src/org/locationtech/jts/triangulate/quadedge/QuadEdgeLocator.js","../src/org/locationtech/jts/triangulate/quadedge/LastFoundQuadEdgeLocator.js","../src/org/locationtech/jts/triangulate/quadedge/LocateFailureException.js","../src/org/locationtech/jts/triangulate/quadedge/TriangleVisitor.js","../src/org/locationtech/jts/triangulate/quadedge/QuadEdgeSubdivision.js","../src/org/locationtech/jts/triangulate/Segment.js","../src/org/locationtech/jts/index/kdtree/KdNodeVisitor.js","../src/org/locationtech/jts/index/kdtree/KdNode.js","../src/org/locationtech/jts/index/kdtree/KdTree.js","../src/org/locationtech/jts/triangulate/ConformingDelaunayTriangulator.js","../src/org/locationtech/jts/triangulate/DelaunayTriangulationBuilder.js","../src/org/locationtech/jts/triangulate/ConformingDelaunayTriangulationBuilder.js","../src/org/locationtech/jts/triangulate/VoronoiDiagramBuilder.js","../src/org/locationtech/jts/linearref/LinearLocation.js","../src/org/locationtech/jts/linearref/LinearIterator.js","../src/org/locationtech/jts/linearref/LocationIndexOfPoint.js","../src/org/locationtech/jts/linearref/LocationIndexOfLine.js","../src/org/locationtech/jts/linearref/LinearGeometryBuilder.js","../src/org/locationtech/jts/linearref/ExtractLineByLocation.js","../src/org/locationtech/jts/linearref/LocationIndexedLine.js","../src/org/locationtech/jts/linearref/LengthIndexOfPoint.js","../src/org/locationtech/jts/linearref/LengthLocationMap.js","../src/org/locationtech/jts/linearref/LengthIndexedLine.js","../src/org/locationtech/jts/operation/union/UnionOp.js","../src/Array.js","../src/Number.js","../src/Math.js","../src/extend.js","../src/inherits.js","../src/hasInterface.js","../src/java/util/Collections.js","../src/org/locationtech/jts/monkey.js","../src/jsts.js"],"names":["NumberUtil","IllegalArgumentException","Double","Comparable","Clonable","Comparator","Serializable","RuntimeException","message","name","stack","Error","call","this","AssertionFailedException","arguments","length","Assert","Coordinate","x","y","z","c","NULL_ORDINATE","DimensionalComparator","dimensionsToTest","Iterator","Collection","IndexOutOfBoundsException","List","NoSuchElementException","OperationNotSupported","ArrayList","array_","addAll","CoordinateList","apply","coord","ensureCapacity","add","allowRepeated","Envelope","minx","maxx","miny","maxy","init","p","env","p1","p2","x1","x2","y1","y2","Exception","NotRepresentableException","Location","MathUtil","StringBuffer","str","Integer","value","Character","DD","hi","lo","dd","parse","CGAlgorithmsDD","CoordinateSequence","System","HCoordinate","w","_x","_y","_w","q1","q2","px","py","pw","qx","qy","qw","CoordinateSequenceFactory","GeometryComponentFilter","Geometry","envelope","factory","SRID","userData","getSRID","CoordinateFilter","BoundaryNodeRule","Mod2BoundaryNodeRule","EndPointBoundaryNodeRule","MultiValentEndPointBoundaryNodeRule","MonoValentEndPointBoundaryNodeRule","CoordinateArrays","ForwardComparator","BidirectionalComparator","Map","SortedMap","Set","HashSet","colorOf","BLACK","color","parentOf","parent","setColor","leftOf","left","rightOf","right","TreeMap","root_","size_","Lineal","SortedSet","TreeSet","Arrays","Dimension","GeometryFilter","CoordinateSequenceFilter","GeometryCollection","geometries","hasNullElements","MultiLineString","lineStrings","BoundaryOp","geom","geomFact","bnRule","endpointMap","MOD2_BOUNDARY_RULE","getFactory","Counter","count","PrintStream","StringReader","DecimalFormat","ByteArrayOutputStream","IOException","LineNumberReader","StringUtil","CoordinateSequences","LineString","points","Puntal","Point","coordinates","Polygonal","Polygon","shell","holes","createLinearRing","isEmpty","hasNonEmptyElements","MultiPoint","LinearRing","GeometryFactory","getCoordinateSequenceFactory","create","hasInterface","validateConstruction","MultiPolygon","polygons","GeometryEditor","isUserDataCopied","GeometryEditorOperation","NoOpGeometryOperation","CoordinateOperation","CoordinateSequenceOperation","CoordinateArraySequence","dimension","Array","Number","isInteger","size","fill","i","coordSeq","getDimension","getCoordinateCopy","CoordinateArraySequenceFactory","is","a","b","forEach","set","sharedDelete","key","has","_keys","splice","_values","_itp","sharedGet","undefined","list","objectOnly","Object","TypeError","indexOf","mapHas","sharedSet","push","sharedClear","sharedKeys","sharedIterator","sharedValues","mapEntries","itp","array","array2","done","v","k","sharedSize","sharedForEach","callback","context","it","entries","r","next","HashMap","map_","MapImpl","PrecisionModel","modelType","scale","FLOATING","Type","FIXED","setScale","pm","nameToTypeMap","put","precisionModel","coordinateSequenceFactory","getDefaultCoordinateSequenceFactory","WKTParser","geometryFactory","WKTWriter","parser","LineIntersector","result","inputLines","map","intPt","intLineIndex","_isProper","pa","pb","RobustLineIntersector","RobustDeterminant","RayCrossingCounter","crossingCount","isPointOnSegment","CGAlgorithms","LineSegment","p0","ls","x0","y0","IntersectionMatrix","matrix","setAll","FALSE","elements","other","INTERIOR","BOUNDARY","EXTERIOR","Centroid","areaBasePt","triangleCent3","areasum2","cg3","lineCentSum","totalLength","ptCount","ptCentSum","EmptyStackException","Stack","UniqueCoordinateArrayFilter","treeSet","ConvexHull","geomFactory","inputPts","geometry","extractCoordinates","pts","filterCoordinates","RadialComparator","origin","GeometryTransformer","inputGeom","pruneEmptyGeometry","preserveGeometryCollectionType","preserveCollections","preserveType","LineStringSnapper","snapTolerance","srcPts","seg","allowSnappingToSourceVertices","_isClosed","srcLine","getCoordinates","isClosed","GeometrySnapper","srcGeom","SnapTransformer","snapPts","isSelfSnap","CommonBits","isFirst","commonMantissaBitsCount","commonBits","commonSignExp","CommonBitsRemover","commonCoord","ccFilter","CommonCoordinateFilter","commonBitsX","commonBitsY","Translater","trans","GeometryCollectionIterator","atStart","max","index","subcollectionIterator","getNumGeometries","PointLocator","boundaryRule","OGC_SFS_BOUNDARY_RULE","isIn","numBoundaries","Octant","SegmentString","BasicSegmentString","data","Boundable","ItemBoundable","bounds","item","PriorityQueue","_size","items","ItemVisitor","SpatialIndex","AbstractNode","childBoundables","level","BoundablePair","boundable1","boundable2","_distance","itemDistance","distance","AbstractSTRtree","root","built","itemBoundables","nodeCapacity","DEFAULT_NODE_CAPACITY","isTrue","IntersectsOp","ItemDistance","STRtree","STRtreeNode","SegmentPointComparator","SegmentNode","segString","segmentIndex","segmentOctant","_isInterior","equals2D","getCoordinate","SegmentNodeList","nodeMap","edge","NodeVertexIterator","nodeList","nodeIt","currNode","nextNode","currSegIndex","getEdge","iterator","readNextNode","NodableSegmentString","NodedSegmentString","MonotoneChainOverlapAction","tempEnv1","tempEnv2","overlapSeg1","overlapSeg2","MonotoneChain","start","end","id","Quadrant","MonotoneChainBuilder","Noder","SinglePassNoder","segInt","setSegmentIntersector","MCIndexNoder","monoChains","idCounter","nodedSegStrings","nOverlaps","si","SegmentOverlapAction","TopologyException","pt","msg","msgWithCoord","SegmentIntersector","InteriorIntersectionFinder","findAllIntersections","isCheckEndSegmentsOnly","li","interiorIntersection","intSegments","intersections","intersectionCount","keepIntersections","FastNodingValidator","segStrings","_isValid","EdgeNodingValidator","nv","edges","toSegmentStrings","GeometryCollectionMapper","mapOp","Position","TopologyLocation","location","on","ON","gl","LEFT","RIGHT","Label","elt","onLoc","lbl","geomIndex","NONE","setLocation","leftLoc","rightLoc","setLocations","EdgeRing","startDe","maxNodeDegree","label","ring","_isHole","computePoints","computeRing","MinimalEdgeRing","MaximalEdgeRing","GraphComponent","_isInResult","_isCovered","_isCoveredSet","_isVisited","Node","NodeMap","nodeFact","EdgeEnd","node","dx","dy","quadrant","DirectedEdge","_isForward","sym","nextMin","edgeRing","minEdgeRing","depth","isForward","n","getNumPoints","computeDirectedLabel","NodeFactory","PlanarGraph","nodes","edgeEndList","PolygonBuilder","shellList","LineBuilder","op","ptLocator","lineEdgesList","resultLineList","PointBuilder","resultPointList","PointOnGeometryLocator","SimplePointInAreaLocator","EdgeEndStar","edgeMap","edgeList","ptInAreaLocation","DirectedEdgeStar","resultAreaEdgeList","SCANNING_FOR_INCOMING","LINKING_TO_OUTGOING","OverlayNodeFactory","mce","chainIndex","SweepLineEvent","xValue","eventType","insertEvent","deleteEventIndex","obj","DELETE","INSERT","EdgeSetIntersector","_hasIntersection","hasProper","hasProperInterior","properIntersectionPoint","includeProper","recordIsolated","isSelfIntersection","numIntersections","numTests","bdyNodes","_isDone","isDoneWhenProperInt","SimpleMCSweepLineIntersector","events","IntervalRTreeNode","min","POSITIVE_INFINITY","NEGATIVE_INFINITY","NodeComparator","IntervalRTreeLeafNode","IntervalRTreeBranchNode","node1","node2","n1","n2","buildExtent","SortedPackedIntervalRTree","leaves","LinearComponentExtracter","lines","isForcedToLineString","ArrayListVisitor","IndexedPointInAreaLocator","g","IntervalIndexedGeometry","SegmentVisitor","counter","EdgeIntersection","dist","EdgeIntersectionList","MonotoneChainIndexer","MonotoneChainEdge","e","startIndex","env1","env2","mcb","getChainStartIndices","Depth","j","NULL_VALUE","Edge","eiList","_isIsolated","depthDelta","GeometryGraph","parentGeom","lineEdgeMap","boundaryNodeRule","useBoundaryDeterminationRule","argIndex","boundaryNodes","_hasTooFewPoints","invalidPoint","areaPtLocator","GeometryGraphOperation","resultPrecisionModel","arg","g0","setComputationPrecision","getPrecisionModel","g1","compareTo","OrientedCoordinateArray","_orientation","orientation","EdgeList","ocaMap","OverlayOp","resultGeom","graph","resultPolyList","SnapOverlayOp","cbr","g2","computeSnapTolerance","SnapIfNeededOverlayOp","InteriorPointArea","interiorPoint","maxWidth","SafeBisectorFinder","poly","centreY","hiY","MAX_VALUE","loY","getEnvelopeInternal","getMaxY","getMinY","avg","InteriorPointLine","centroid","minDistance","getCentroid","addInterior","addEndpoints","InteriorPointPoint","MonotoneChainSelectAction","selectedSegment","NodeBase","subnode","Interval","interval","DoubleBits","CVTFWD","NumW","Qty","Sign","Expo","Mant","Bin","Inf","ExW","isFinite","d","Math","pow","abs","Key","computeKey","centre","getMin","getMax","IntervalSize","Root","Bintree","minExtent","PointInRing","MCPointInRing","tree","crossings","buildIndex","MCSelecter","mcp","Angle","Triangle","MinimumBoundingCircle","input","extremalPts","radius","MinimumDiameter","isConvex","convexHullPts","minBaseSeg","minWidthPt","minPtIndex","minWidth","Densifier","distanceTolerance","DensifyTransformer","HalfEdge","_orig","_sym","_next","orig","MarkHalfEdge","_isMarked","EdgeGraph","vertexMap","DissolveHalfEdge","_isStart","DissolveEdgeGraph","LineDissolver","nodeEdgeStack","ringStartEdge","itemEnv","centrex","centrey","getMinX","getMaxX","Quadtree","GeoJSONParser","GeoJSONReader","GeoJSONWriter","WKTReader","p2c","OL3Parser","olReference","ol","ScaledNoder","noder","scaleFactor","offsetX","offsetY","isScaled","isIntegerPrecision","IsSimpleOp","isClosedEndpointsInInterior","nonSimpleLocation","isInBoundary","EndpointInfo","degree","BufferParameters","quadrantSegments","DEFAULT_QUADRANT_SEGMENTS","endCapStyle","CAP_ROUND","joinStyle","JOIN_ROUND","mitreLimit","DEFAULT_MITRE_LIMIT","_isSingleSided","simplifyFactor","DEFAULT_SIMPLIFY_FACTOR","setQuadrantSegments","setEndCapStyle","setJoinStyle","setMitreLimit","RightmostEdgeFinder","minIndex","minCoord","minDe","orientedDe","LinkedList","BufferSubgraph","finder","dirEdgeList","rightMostCoord","BufferInputLineSimplifier","inputLine","distanceTol","isDeleted","angleOrientation","COUNTERCLOCKWISE","OffsetSegmentString","ptList","minimimVertexDistance","OffsetSegmentGenerator","maxCurveSegmentError","filletAngleQuantum","closingSegLengthFactor","segList","bufParams","s0","s1","s2","seg0","seg1","offset0","offset1","side","_hasNarrowConcaveAngle","PI","getQuadrantSegments","getJoinStyle","MAX_CLOSING_SEG_LEN_FACTOR","OffsetCurveBuilder","SubgraphDepthLocater","subgraphs","cga","DepthSegment","upwardSeg","leftDepth","OffsetCurveSetBuilder","curveBuilder","curveList","IntersectionAdder","hasInterior","numInteriorIntersections","numProperIntersections","BufferBuilder","workingPrecisionModel","workingNoder","NodingValidator","HotPixel","originalPt","ptScaled","p0Scaled","p1Scaled","corner","safeEnv","initCorners","MCIndexPointSnapper","HotPixelSnapAction","hotPixel","parentEdge","hotPixelVertexIndex","_isNodeAdded","InteriorIntersectionFinderAdder","interiorIntersections","MCIndexSnapRounder","pointSnapper","setPrecisionModel","getScale","BufferOp","argGeom","resultGeometry","saveException","PolygonExtracter","comps","GeometryLocation","component","segIndex","INSIDE_AREA","PointExtracter","ConnectedElementLocationFilter","locations","DistanceOp","terminateDistance","minDistanceLocation","EdgeString","directedEdges","from","to","edgeDirection","angle","directionPt","atan2","LineMergeDirectedEdge","dirEdge","de0","de1","setDirectedEdges","outEdges","sorted","deStar","LineMergeEdge","line","dirEdges","LineMergeGraph","LineMerger","mergedLineStrings","edgeStrings","PolygonizeDirectedEdge","PolygonizeEdge","ConnectedInteriorTester","geomGraph","disconnectedRingcoord","EdgeEndBuilder","EdgeEndBundle","edgeEnds","getDirectedCoordinate","getLabel","insert","EdgeEndBundleStar","RelateNode","RelateNodeFactory","RelateNodeGraph","ConsistentAreaTester","nodeGraph","IndexedNestedRingTester","rings","totalEnv","nestedPt","TopologyValidationError","errorType","copy","IsValidOp","parentGeometry","isSelfTouchingRingFormingHoleValid","validErr","deList","lowestEdge","ringPts","_isProcessed","_isIncludedSet","_isIncluded","EnvelopeComparator","PolygonizeGraph","Polygonizer","lineStringAdder","LineStringAdder","dangles","cutEdges","invalidRingLines","holeList","polyList","isCheckingRingsValid","extractOnlyPolygonal","RelateComputer","im","isolatedEdges","RectangleContains","rectEnv","rectangle","RectangleLineIntersector","diagUp0","diagUp1","diagDown0","diagDown1","ShortCircuitedGeometryVisitor","RectangleIntersects","EnvelopeIntersectsVisitor","_intersects","GeometryContainsPointVisitor","rectSeq","_containsPoint","getExteriorRing","getCoordinateSequence","RectangleIntersectsSegmentVisitor","rectIntersector","hasIntersection","RelateOp","_relate","GeometryCombiner","skipEmpty","inputGeoms","geoms","extractFactory","PointGeometryUnion","pointGeom","otherGeom","GeometryExtracter","sortIndex","CascadedPolygonUnion","inputPolys","polys","UnaryUnionOp","extract","PrecisionReducerCoordinateOperation","targetPM","removeCollapsed","GeometryPrecisionReducer","changePrecisionModel","isPointwise","DouglasPeuckerLineSimplifier","usePt","DouglasPeuckerSimplifier","isEnsureValidTopology","DPTransformer","TaggedLineSegment","TaggedLineString","parentLine","segs","resultSegs","minimumSize","LineSegmentIndex","LineSegmentVisitor","querySeg","TaggedLineStringSimplifier","inputIndex","outputIndex","linePts","TaggedLinesSimplifier","TopologyPreservingSimplifier","lineSimplifier","linestringMap","LineStringTransformer","LineStringMapBuilderFilter","tps","SplitSegment","segLen","splitPt","minimumLen","getLength","ConstraintSplitPointFinder","NonEncroachingSplitPointFinder","TrianglePredicate","Vertex","_p","_z","ConstraintVertex","_isOnConstraint","constraint","QuadEdge","_rot","vertex","IncrementalDelaunayTriangulator","subdiv","isUsingTolerance","getTolerance","QuadEdgeLocator","LastFoundQuadEdgeLocator","lastEdge","LocateFailureException","msgWithSpatial","TriangleVisitor","QuadEdgeSubdivision","visitedKey","quadEdges","startingEdge","tolerance","edgeCoincidenceTolerance","frameVertex","frameEnv","locator","triEdges","EDGE_COINCIDENCE_TOL_FACTOR","createFrame","initSubdiv","TriangleCircumcentreVisitor","TriangleEdgesListVisitor","triList","TriangleVertexListVisitor","TriangleCoordinatesVisitor","coordList","triCoords","Segment","z1","z2","KdNodeVisitor","KdNode","KdTree","numberOfNodes","BestMatchVisitor","matchNode","matchDist","ConformingDelaunayTriangulator","initialVertices","segVertices","segments","incDel","convexHull","splitFinder","kdt","vertexFactory","computeAreaEnv","DelaunayTriangulationBuilder","siteCoords","ConformingDelaunayTriangulationBuilder","constraintLines","constraintVertexMap","VoronoiDiagramBuilder","clipEnv","diagramEnv","LinearLocation","componentIndex","segmentFraction","loc","normalize","doNormalize","LinearIterator","linearGeom","numLines","currentLine","vertexIndex","linear","getComponentIndex","segmentEndVertexIndex","loadCurrentLine","LocationIndexOfPoint","LocationIndexOfLine","LinearGeometryBuilder","ignoreInvalidLines","fixInvalidLines","lastPt","ExtractLineByLocation","LocationIndexedLine","checkGeometryType","LengthIndexOfPoint","LengthLocationMap","LengthIndexedLine","UnionOp","prototype","defineProperty","arrayLike","relativeStart","parseInt","relativeEnd","val","floor","parseFloat","isNaN","trunc","ceil","extend","target","source","hasOwnProperty","equalsWithTolerance","doubleToLongBits","longBitsToDouble","isInfinite","constructor","inherits","shouldNeverReachHere","assertion","equals","expectedValue","actualValue","ordinateIndex","X","Y","Z","o","CloneNotSupportedException","dz","sqrt","hashCode","Cloneable","f","o1","o2","c1","c2","compX","compare","compY","serialVersionUID","NaN","hasNext","remove","toArray","get","interfaces_","clear","element","oldElement","Iterator_","len","found","arrayList","arrayList_","position_","coll","isChanged","clone","coordArrayType","last","direction","prev","inc","getWidth","getHeight","otherEnvelope","isNull","intersects","intMinX","intMinY","covers","expandToInclude","h","transX","transY","expandBy","deltaX","deltaY","setToNull","q","minq","maxq","minp","maxp","toLocationSymbol","locationValue","log10","ln","log","LOG_10","v1","v2","v3","v4","clamp","wrap","average","append","setCharAt","substr","toString","intValue","isWhitespace","toUpperCase","insertDecimalPoint","magnitude","mag","TEN","divide","gt","lt","ONE","multiply","decimalPointPos","buf","numDigits","MAX_PRINT_DIGITS","digit","rebiasBy10","digitChar","subtract","valueOf","selfAdd","continueExtractingDigits","remMag","negate","isZero","le","selfDivide","yhi","ylo","hc","tc","hy","ty","C","U","u","SPLIT","createNaN","exp","s","selfMultiply","sqr","reciprocal","fhi","flo","ge","isNegative","ax","axdd","diffSq","d2","H","S","T","t","zhi","zlo","hx","tx","ex","toStandardNotation","toSciNotation","specialStr","getSpecialNumberString","sigDigits","extractSignificantDigits","num","charAt","stringOfChar","numZeroes","zeroes","SCI_NOT_ZERO","digits","expStr","SCI_NOT_EXPONENT_CHAR","IllegalStateException","trailingDigits","substring","digitsWithDecimal","isPositive","strlen","signCh","numBeforeDec","ch","isDigit","NumberFormatException","val2","numDecPlaces","xAbs","xLog10","xMag","TWO_PI","PI_2","E","EPS","orientationIndex","orientationIndexFilter","dx1","dy1","dx2","dy2","selfSubtract","signum","signOfDet2x2","intersection","denom1","denom2","denom","numx1","numx2","numx","fracP","doubleValue","numy1","numy2","numy","fracQ","pc","detsum","detleft","detright","det","errbound","DP_SAFE_EPSILON","M","arraycopy","src","srcPos","dest","destPos","getProperty","getX","getY","xInt","yInt","getSortIndex","SORTINDEX_GEOMETRYCOLLECTION","equalsTopo","equalsExact","geometryChangedFilter","norm","compareToSameClass","comp","toGeometry","computeEnvelopeInternal","aElement","bElement","comparison","SORTINDEX_MULTIPOINT","SORTINDEX_MULTILINESTRING","SORTINDEX_MULTIPOLYGON","SORTINDEX_POINT","SORTINDEX_LINESTRING","SORTINDEX_LINEARRING","SORTINDEX_POLYGON","geometryChangedAction","boundaryCount","ENDPOINT_BOUNDARY_RULE","MULTIVALENT_ENDPOINT_BOUNDARY_RULE","MONOVALENT_ENDPOINT_BOUNDARY_RULE","isRing","ptNotInList","testPts","testPt","scroll","firstCoordinate","newCoordinates","coord1","coord2","coordinateComparator","toCoordinateArray","hasRepeatedPoints","removeRepeatedPoints","reverse","mid","tmp","removeNull","nonNull","newCoord","copyDeep","srcStart","destStart","isEqualReversed","pts1","pts2","atLeastNCoordinatesOrNothing","coordinate","increasingDirection","minCoordinate","npts","extractPts","iPts","forwardComp","dir1","dir2","i1","i2","comparePt","values","entrySet","contains","javascript","util","hashSet","hashSet_","cmp","oldValue","fixAfterInsertion","rotateLeft","rotateRight","getFirstEntry","successor","l","treeSet_","sort","comparator","slice","concat","asList","toDimensionSymbol","dimensionValue","SYM_FALSE","TRUE","SYM_TRUE","DONTCARE","SYM_DONTCARE","P","SYM_P","L","SYM_L","A","SYM_A","toDimensionValue","dimensionSymbol","seq","childCoordinates","area","getArea","isEquivalentClass","otherCollection","getBoundaryDimension","sum","numPoints","revGeoms","createGeometryCollection","theseElements","otherElements","gc","thisGeom","getGeometryN","holeComp","filter","isDone","isGeometryChanged","geometryChanged","checkNotGeometryCollection","nLines","revLines","createMultiLineString","getBoundary","mLine","getEmptyMultiPoint","bdyPts","computeBoundaryCoordinates","createPoint","createMultiPointFromCoords","boundaryLineString","boundaryMultiLineString","getStartPoint","createMultiPoint","getEndPoint","addEndpoint","getCoordinateN","entry","getValue","valence","getKey","bop","chars","String","getStackTrace","os","ps","printStackTrace","stackTrace","stringReader","lineNumberReader","readLine","NEWLINE","split","separator","separatorlen","tokenList","tmpString","pos","token","res","SIMPLE_ORDINATE_FORMAT","format","spaces","copyCoord","minDim","dim","setOrdinate","getOrdinate","isEqual","cs1","cs2","cs1Size","fact","newseq","swap","cs","ensureValidRing","createClosedRing","expandEnvelope","isSimple","otherLineString","equal","getPointN","computeLength","createLineString","point","shellCoordinates","signedArea","getNumInteriorRing","prevX","prevY","otherPolygon","thisShell","otherPolygonShell","clockwise","uniqueCoordinates","isCCW","otherShell","shellComp","nHole1","nHole2","thisHole","getInteriorRingN","otherHole","MINIMUM_VALID_SIZE","createMultiPolygon","allRings","polygon","allRingsArray","operation","editInternal","setUserData","getUserData","editGeometryCollection","editPolygon","edit","getClass","getName","collection","collectionForType","newPolygon","createPolygon","hole","coords","editCoordinates","cloneCoordinates","strBuf","instance","instanceObject","MapPolyfill","proto","MapInterface","otherPrecisionModel","getMaximumSignificantDigits","otherSigDigits","FLOATING_SINGLE","description","round","makePrecise","maxSigDigits","mostPrecise","pm1","pm2","maximumPreciseValue","geomList","geomClass","isHeterogeneous","hasGeometryCollection","partClass","isGeometryCollectionOrDerived","toGeometryArray","geom0","toPolygonArray","toLineStringArray","toPointArray","ptSeq","toMultiPolygonArray","multiPolygons","multiPolygonArray","geometryArray","toMultiLineStringArray","multiLineStrings","multiLineStringArray","lineStringArray","toMultiPointArray","multiPoints","multiPointArray","toLinearRingArray","linearRings","linearRingArray","pointArray","polygonArray","createPointFromInternalCoord","exemplar","regExes","wkt","type","replace","matches","typeStr","exec","search","emptyTypeStr","toLowerCase","extractGeometry","getGeometryType","wktType","multipoint","join","linestring","linearring","multilinestring","multipolygon","trim","components","trimParens","parenComma","doubleParenComma","wktArray","read","write","intIndex","computeIntLineIndex","catBuf","isEndPoint","isCollinear","p3","p4","computeIntersect","dist0","getEdgeDistance","dist1","isInteriorIntersection","inputLineIndex","NO_INTERSECTION","computeEdgeDistance","COLLINEAR_INTERSECTION","toLineString","getTopologySummary","ptIndex","pdx","pdy","nonRobustComputeEdgeDistance","DONT_INTERSECT","DO_INTERSECT","COLLINEAR","POINT_INTERSECTION","env0","computeIntersection","n3","n4","normPt","smallestInAbsValue","nearestEndpoint","intersectionWithNormalization","isInSegmentEnvelopes","x3","x4","xabs","intPtDD","out","println","normalizeToEnvCentre","safeHCoordinateIntersection","p1q1p2","p1q2p2","q1p1q2","q1p2q2","n00","n01","n10","n11","minX0","minY0","maxX0","maxY0","minX1","minY1","maxX1","maxY1","intMaxX","intMaxY","intMidX","intMidY","Pq1","Pq2","Qp1","Qp2","computeCollinearIntersection","nearestPt","minDist","distancePointLine","sign","xIntSign","getLocation","locatePointInRing","countSegment","isOnSegment","distanceLineLine","B","D","noIntersection","r_num","s_num","isPointInRing","nPts","hiPt","hiIndex","iPrev","iNext","disc","computeOrientation","distancePointLinePerpendicular","len2","isOnLine","lineIntersector","CLOCKWISE","STRAIGHT","orient0","orient1","getIntersection","projectionFactor","pf0","pf1","newp0","project","newp1","midPoint","closestPt","close00","closestPoint","close01","close10","close11","factor","comp0","temp","segmentLengthFraction","offsetDistance","segx","segy","ux","uy","setCoordinates","inputPt","segFrac","bits0","java","lang","hash0","bits1","isDisjoint","dimensionSymbols","row","col","column","minimumDimensionSymbols","setAtLeast","minimumDimensionValue","dimensionOfGeometryA","dimensionOfGeometryB","isTouches","ai","bi","requiredDimensionSymbols","actualDimensionValue","requiredDimensionSymbol","actualDimensionSymbols","basePt","lineLen","segmentLen","midx","midy","addPoint","isPositiveArea","addTriangle","addLineSegments","cent","setBasePoint","centroid3","area2","addShell","addHole","pop","peek","empty","octPts","computeOctPts","closeRing","cleanRing","linearRing","original","cleanedRing","previousDistinctCoordinate","currentCoordinate","nextCoordinate","isBetween","cleanedRingCoordinates","c3","polyPts","computeOctRing","reducedSet","reducedPts","padArray3","reduce","sortedPts","preSort","cHS","grahamScan","cH","lineOrPolygon","pad","polarCompare","dxp","dyp","dxq","dyq","orient","oq","transformCoordinates","isAllValidLinearRings","transformLinearRing","buildGeometry","transGeomList","transformGeom","transformLineString","transformPoint","transformPolygon","transform","transformMultiPoint","transformMultiLineString","transformMultiPolygon","transformGeometryCollection","seqSize","srcCoords","srcPt","snapVert","findSnapForVertex","snapVertices","snapSegments","distinctPtCount","snapPt","findSegmentIndexToSnap","snapIndex","snapGeom","extractTargetCoordinates","cleanResult","snapTrans","snappedGeom","buffer","computeMinimumSegmentLength","ptSet","minSegLen","snap","snapper0","snapTo","snapper1","computeOverlaySnapTolerance","computeSizeBasedSnapTolerance","getType","fixedSnapTol","SNAP_PRECISION_FACTOR","snapToSelf","snapper","setAllowSnappingToSourceVertices","newPts","snapLine","numBits","signExpBits","numCommonMostSigMantissaBits","zeroLowerBits","bits","numStr","Long","toBinaryString","padStr","bitStr","getBit","nBits","num1","num2","invCoord","getCommonCoordinate","getCommon","xp","yp","isAtomic","UnsupportedOperationException","shellLoc","locateInPolygonRing","holeLoc","locate","updateLocationInfo","locateInternal","ml","mpoly","geomi","computeLocation","octant","adx","ady","minItem","reorder","child","childBoundable","computeBounds","Collections","alen","priQ","isComp1","isComposite","isComp2","expand","nd","bndComposite","bndOther","children","getChildBoundables","bp","getDistance","isLeaves","getBounds","build","childToRemove","getItem","valuesTree","itemsTree","valuesTreeForNode","valuesTreeForChild","boundables","boundablesAtLevel","top","getLevel","boundable","searchBounds","getIntersectsOp","query","visitor","visitItem","createNode","createHigherLevels","removeItem","childToPrune","boundablesOfALevel","parentBoundables","createParentBoundables","maxChildDepth","childDepth","newLevel","sortedChildBoundables","getComparator","lastNode","getNodeCapacity","addChildBoundable","compareDoubles","item1","item2","verticalSlices","createParentBoundablesFromVerticalSlice","intersectsOp","sliceCount","sliceCapacity","slices","boundablesAddedToSlice","searchEnv","yComparator","minLeafCount","xComparator","createParentBoundablesFromVerticalSlices","itemDist","getRoot","nearestNeighbour","initBndPair","maxDistance","distanceLowerBound","minPair","bndPair","poll","currentDistance","expandToQueue","getBoundable","bnd","centreX","aBounds","bBounds","relativeSign","xSign","ySign","compareValue","compareSign0","compareSign1","print","maxSegmentIndex","eiPrev","ei","addEdgeCoordinates","collapsedVertexIndexes","findCollapsesFromInsertedNodes","findCollapsesFromExistingVertices","ei0","ei1","lastSegStartPt","useIntPt1","isInterior","addCollapsedNodes","newEdge","createSplitEdge","collapsedVertexIndex","numVerticesBetween","findCollapseIndex","maxSegIndex","ipt","getData","eiNew","getSegmentOctant","splitEdges","edgePts","split0","pt0","splitn","splitnPts","ptn","safeOctant","addIntersectionNode","addIntersection","normalizedSegmentIndex","nextSegIndex","nextPt","getIntersectionNum","getNodedSubstrings","resultEdgelist","ss","getNodeList","addSplitEdges","mc1","start1","mc2","start2","getLineSegment","overlap","start0","end0","mcs","select","computeSelect","mc","mco","computeOverlapsInternal","end1","p00","p01","p10","p11","mid0","mid1","isNorthern","quad","NE","NW","isOpposite","quad1","quad2","commonHalfPlane","isInHalfPlane","halfPlane","SE","SW","startIndexList","findChainEnd","toIntArray","safeStart","chainQuad","getChains","mcList","segStr","segChains","setId","getEnvelope","inputSegStrings","intersectChains","overlapAction","queryChain","overlapChains","testChain","getId","computeOverlaps","ss1","getContext","ss2","processIntersections","e0","segIndex0","e1","segIndex1","isEndSegment","createAllIntersectionsFinder","setFindAllIntersections","createAnyIntersectionFinder","createIntersectionCounter","setKeepIntersections","checkInteriorIntersections","getIntersections","execute","computeNodes","getErrorMessage","getInteriorIntersection","intSegs","getIntersectionSegments","computeIntersections","isValid","checkValid","mapped","opposite","position","locValue","newLoc","posIndex","locIndex","setAllLocations","setAllLocationsIfNull","isLine","merge","flip","isArea","isAnyNull","isEqualOnSide","allPositionsEqual","toLineLabel","lineLabel","getGeometryCount","de","isFirstEdge","getEdgeRing","mergeLabel","addPoints","setEdgeRing","getNext","getNode","getEdges","getOutgoingDegree","setInResult","getLinearRing","containsPoint","computeMaxNodeDegree","deLabel","holeLR","er","setMinEdgeRing","getNextMin","minEdgeRings","getMinEdgeRing","minEr","linkMinimalDirectedEdges","isVisited","isInResult","isCovered","computeIM","label2","eltIndex","nLoc","setLabel","onLocation","computeMergedLocation","thisLoc","setNode","addNode","className","lastDotPos","lastIndexOf","compareDirection","depthVal","isInteriorAreaEdge","getDepthDelta","isExteriorIfArea0","isExteriorIfArea1","printReverse","setVisited","directionFactor","oppositePos","delta","oppositeDepth","setDepth","depthFactor","currLocation","nextLocation","find","nodeit","linkResultDirectedEdges","linkAllDirectedEdges","ep0","ep1","eCoord","matchInSameDirection","getEdgeEnds","ee","edgesToAdd","de2","setSym","edgeRings","freeHoleList","isHole","toPolygon","getShell","findEdgeRingContaining","setShell","maxEdgeRings","getMaxNodeDegree","linkDirectedEdgesForMinimalEdgeRings","buildMinimalRings","findShell","placePolygonHoles","computePolygons","testEr","testRing","testEnv","minShell","minEnv","tryShell","tryRing","tryEnv","isContained","shellCount","getNodes","buildMaximalEdgeRings","buildMinimalEdgeRings","sortShellsAndHoles","placeFreeHoles","opCode","getGraph","collectLineEdge","collectBoundaryTouchEdge","targetIndex","getArgGeometry","findCoveredLineEdges","collectLines","buildLines","isLineEdge","isResultOfOp","setVisitedEdge","isCoveredSet","isCoveredByA","setCovered","edgesList","isIsolated","labelIsolatedLine","getSym","INTERSECTION","isCoveredByLA","isIncidentEdgeInResult","getDegree","filterCoveredNodeToPoint","extractNonCoveredResultNodes","containsPointInPolygon","iNextCW","startLoc","currLoc","computeEdgeEndLabels","getBoundaryNodeRule","checkAreaLabelsConsistent","lastEdgeIndex","startLabel","eSearch","getGeometry","computeLabel","propagateSideLabels","hasDimensionalCollapseEdge","getResultAreaEdges","firstOut","incoming","state","nextOut","nextIn","setNext","insertEdgeEnd","deLast","quad0","getQuadrant","getDy","nodeLabel","prevOut","firstIn","edgeIndex","findIndex","startDepth","getDepth","targetLastDepth","nextDepth","computeDepths","endIndex","currDepth","nextDe","setEdgeDepths","setNextMin","computeLabelling","eLabel","eLoc","computeIntersectsForChain","pe","ev","isAdjacentSegments","isIntersection","isBoundaryPointInternal","bdyNodes0","bdyNodes1","setIsolated","isTrivialIntersection","isProper","addIntersections","isBoundaryPoint","isDelete","getInsertEvent","setDeleteEventIndex","prepareEvents","isInsert","processOverlaps","getDeleteEventIndex","edges0","edges1","addEdges","testAllSegments","edgeSet","getMonotoneChainEdge","getStartIndexes","ev0","mc0","getObject","ev1","isSameLabel","addEdge","queryMin","queryMax","mid2","buildLevel","buildTree","buildRoot","getLines","forceToLineString","rcc","addLine","getItems","chainIndex0","chainIndex1","depthValue","minDepth","newValue","depthAtLocation","isEqualForward","isEqualReverse","iRev","updateIM","setAtLeastIfValid","determineBoundary","computeRingSelfNodes","computeSelfNodes","isDoneIfProperInt","setIsDoneIfProperInt","esi","createEdgeSetIntersector","isRings","computeAllSegments","addSelfIntersectionNodes","edgelist","setBoundaryNodes","getBoundaryNodes","insertPoint","addPolygonRing","insertEdge","insertBoundaryPoint","isBoundaryNode","lr","cwLeft","cwRight","eiIt","addSelfIntersectionNode","addPolygon","addLineString","addCollection","findEdge","oca","compareOriented","orientation1","orientation2","limit1","limit2","compPt","done1","done2","edgeColl","existingEdge","findEqualEdge","existingLabel","labelToMerge","isPointwiseEqual","opcode","createEmptyResult","mergeSymLabels","newEdges","isCollapsed","getCollapsedEdge","overlayOpCode","computeOverlay","insertUniqueEdge","copyPoints","computeEdgeIntersections","baseSplitEdges","computeSplitEdges","insertUniqueEdges","computeLabelsFromDepths","replaceCollapsedEdges","labelIncompleteNodes","findResultAreaEdges","cancelDuplicateResultEdges","polyBuilder","getPolygons","lineBuilder","pointBuilder","computeGeometry","getNodeIterator","graphNode","getDelta","toLine","updateNodeLabelling","nodeCount","ni","labelIncompleteNode","updateLabelling","overlayOp","geom1","getResultGeometry","isGeometryCollection","MapOp","symDifference","SYMDIFFERENCE","resultDimension","dim0","dim1","UNION","DIFFERENCE","difference","loc0","loc1","remGeom","removeCommonBits","addCommonBits","prepGeom","prepareResult","union","isSuccess","savedException","width","bisector","horizontalBisector","widestIntersection","widestGeometry","bisectY","getBisectorY","process","updateInterval","hasChildren","hasItems","addAllItems","subSize","resultItems","isSearchMatch","addAllItemsFromOverlapping","itemInterval","isPrunable","maxSubDepth","sqd","nodeSize","getSubnodeIndex","subnodeIndex","overlaps","exponent","powerOf2","computeLevel","computeInterval","searchInterval","childNode","createSubnode","getSubnode","getInterval","createExpanded","addInterval","expandInt","largerNode","isZeroWidth","maxAbs","scaledInterval","MIN_BINARY_EXPONENT","insertContained","isZeroArea","collectStats","insertInterval","ensureExtent","foundItems","del","mcEnv","rayEnv","mcSelecter","testMonotoneChain","testLineSegment","toDegrees","radians","PI_TIMES_2","isAcute","dx0","dy0","isObtuse","interiorAngle","anglePrev","angleNext","normalizePositive","angleBetween","tip1","tail","tip2","a1","a2","diff","ang1","ang2","delAngle","toRadians","angleDegrees","getTurn","crossproduct","sin","angleBetweenOriented","angDel","PI_OVER_2","PI_OVER_4","interpolateZ","longestSideLength","circumcentre","area3D","inCentre","m00","m01","m10","m11","v0","lenAB","lenBC","lenCA","maxLen","cx","cy","ay","bx","by","perpendicularBisector","angleBisector","len0","frac","uz","vx","vy","vz","crossx","crossy","crossz","absSq","len1","circum","compute","hullPts","lowestPoint","Q","pointWitMinAngleWithX","R","pointWithMinAngleWithSegment","computeCirclePoints","computeCentre","centrePoint","minSin","minAngPt","minAng","ang","computeMinimumDiameter","convexGeom","computeConvexRingMinDiameter","currMaxIndex","findMaxPerpDistance","computeWidthConvex","getConvexHull","maxPerpDistance","distancePerpendicular","nextPerpDistance","maxIndex","nextIndex","minPara","maxPara","minPerp","maxPerp","paraC","computeC","perpC","maxPerpLine","computeSegmentForLine","minPerpLine","maxParaLine","minParaLine","lineIntersection","getMinimumDiameter","getDiameter","getMinimumRectangle","densifyPoints","precModel","densifiedSegCount","densifiedSegLen","segFract","pointAlong","densify","densifier","setDistanceTolerance","roughGeom","createValidArea","roughAreaGeom","oNext","insertAfter","ecmp","ePrev","save","quadrant2","compareAngularDirection","isMarked","setMarkBoth","setMark","markBoth","mark","eAdj","eAdjDest","createEdge","isValidEdge","eSame","isStart","computeResult","eNode","prevNode","stackEdges","eStartRing","eNext","eStart","updateRingStartEdge","buildRing","getVertexEdges","buildLine","lineString","doneStart","setStart","dissolve","getResult","visitItems","visit","computeQuadLevel","quadSize","dMax","insertNode","addEnv","expandEnv","isZeroX","isZeroY","insertEnv","posEnv","delX","delY","geometryTypes","json","JSON","feature","bbox","featureCollection","features","sub","geoJson","shellGeoJson","holeGeoJson","reducePrecision","convertFromPoint","convertFromLineString","convertFromLinearRing","convertFromPolygon","convertFromMultiPoint","convertFromMultiLineString","convertFromMultiPolygon","convertFromCollection","getLinearRings","multiPoint","getPoints","multiLineString","getLineStrings","multiPolygon","getGeometries","convertToPoint","convertToLineString","convertToLinearRing","convertToPolygon","convertToMultiPoint","convertToMultiLineString","convertToMultiPolygon","convertToCollection","geometryCollection","rescale","nodedSegmentStrings","roundPts","splitSS","intSegStrings","mp","isSimpleLinearGeometry","endPoints","getEdgeIterator","getMaximumSegmentIndex","eiInfo","hasProperIntersection","getProperIntersectionPoint","hasNonEndpointIntersection","hasClosedEndpointIntersection","getEdgeIntersectionList","isSimpleMultiPoint","isSimplePolygonal","isSimpleGeometryCollection","computeSimple","quadSegs","JOIN_BEVEL","JOIN_MITRE","isSingleSided","bufferDistanceError","alpha","cos","CAP_FLAT","CAP_SQUARE","getRightmostSideOfSegment","checkForRightmostCoordinate","pPrev","pNext","usePrev","star","getRightmostEdge","findRightmostEdgeAtNode","findRightmostEdgeAtVertex","getRightmostSide","addLast","removeFirst","shift","startEdge","copySymDepths","outsideDepth","clearVisitedEdges","addReachable","nodesVisited","nodeQueue","startNode","computeNodeDepth","adjNode","edgeEnv","nodeStack","symNode","i0","isConcave","isShallow","isShallowSampled","midIndex","findNextNonDeletedIndex","lastIndex","isMiddleVertexDeleted","isDeletable","NUM_PTS_TO_CHECK","deleteShallowConcavities","collapseLine","simplify","INIT","KEEP","COORDINATE_ARRAY_TYPE","bufPt","isRedundant","addPt","startPt","addStartPoint","computeOffsetSegment","outsideTurn","addCollinear","addOutsideTurn","addInsideTurn","offsetL","offsetR","getEndCapStyle","addFilletArc","squareCapSideOffset","squareCapLOffset","squareCapROffset","isMitreWithinLimit","getMitreLimit","addLimitedMitreJoin","startAngle","endAngle","OFFSET_SEGMENT_SEPARATION_FACTOR","addMitreJoin","addBevelJoin","addFilletCorner","addPts","ang0","angDiff","angDiffHalf","midAng","mitreMidAng","mitreDist","bevelDelta","bevelHalfLen","bevelMidX","bevelMidY","bevelMidPt","mitreMidLine","bevelEndLeft","pointAlongOffset","bevelEndRight","offset","sideSign","totalAngle","nSegs","initAngle","currAngleInc","currAngle","INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR","setMinimumVertexDistance","CURVE_VERTEX_SNAP_DISTANCE_FACTOR","isRightSide","posDistance","segGen","getSegGen","computePointCurve","computeOffsetCurve","curvePts","distTol","simplifyTolerance","addSegments","simp2","initSideSegments","addFirstSegment","addNextSegment","simp1","addLastSegment","simp","addLineEndCap","createCircle","createSquare","computeSingleSidedBufferCurve","computeLineBufferCurve","bufDistance","getSimplifyFactor","getLineCurve","copyCoordinates","computeRingBufferCurve","stabbingRayLeftPt","stabbedSegments","bsg","findStabbedSegments","getDirectedEdges","isHorizontal","ds","minX","maxX","orientIndex","compare0","curve","addCurve","offsetSide","shellCoord","isErodedCompletely","holeCoord","triangleCoord","bufferDistance","tri","getBufferParameters","cwLeftLoc","cwRightLoc","getRingCurve","ringCoord","isTriangleErodedCompletely","envMinDimension","mergeDelta","existingDelta","newDelta","setDepthDelta","subgraphList","processedGraphs","subgraph","getRightmostCoordinate","locater","computeDepth","findResultEdges","reverseOrder","curveSetBuilder","bufferSegStrList","getCurves","createEmptyResultGeometry","computeNodedEdges","createSubgraphs","buildSubgraphs","getNoder","oldLabel","lLoc","rLoc","convertSegStrings","checkEndPtVertexIntersections","ss0","pts0","hasInteriorIntersection","checkCollapses","checkCollapse","segMinx","segMaxx","segMiny","segMaxy","isOutsidePixelEnv","intersectsToleranceSquare","intersectsScaled","copyScaled","pScaled","safeTolerance","SAFE_ENV_EXPANSION_FACTOR","intersectsLeft","intersectsBottom","pixelEnv","getSafeEnvelope","hotPixelSnapAction","isNodeAdded","addSnappedNode","inputSegmentStrings","resultSegStrings","findInteriorIntersections","computeIntersectionSnaps","computeVertexSnaps","intFinderAdder","getInteriorIntersections","edge0","getIndex","snapRound","fixedPM","bufBuilder","setWorkingPrecisionModel","setNoder","precDigits","MAX_PRECISION_DIGITS","bufferReducedPrecision","precisionDigits","sizeBasedScaleFactor","precisionScaleFactor","bufferFixedPrecision","bufferOriginalPrecision","argPM","bufferOp","gBuf","geomBuf","bufOp","params","maxPrecisionDigits","envMax","expandByDistance","bufEnvMax","bufEnvPrecisionDigits","minUnitLog10","CAP_BUTT","singletonList","getLocations","locPtPoly","computeContainmentDistance","polyGeomIndex","locationsIndex","insideLocs","locs","ptLoc","locGeom","computeMinDistance","lines0","lines1","computeMinDistanceLines","updateMinDistance","computeMinDistanceLinesPoints","computeMinDistancePoints","computeFacetDistance","coord0","segClosestPoint","line0","line1","closestPoints","points0","points1","pt1","isWithinDistance","nearestPoints","forwardDirectedEdges","reverseDirectedEdges","coordinateList","directedEdge","getEdgeDirection","getLine","getComponentWithVisitedState","visitedState","visited","setMarked","marked","toEdges","getToNode","getOutEdges","setEdge","getFromNode","addOutEdge","fromNode","sortEdges","modi","getEdgesBetween","node0","commonEdges","retainAll","nodesFound","nodeIterator","getDirEdge","startCoordinate","endCoordinate","endNode","directedEdge0","directedEdge1","findNode","buildEdgeStringsStartingAt","buildEdgeStringsForNonDegree2Nodes","buildEdgeStringStartingWith","edgeIterator","buildEdgeStringsForObviousStartNodes","buildEdgeStringsForIsolatedLoops","edgeString","current","buildEdgeStringsForUnprocessedNodes","findDifferentPoint","findEdgeInSameDirection","findEdgeEnd","intDe","visitLinkedDirectedEdges","visitInteriorRing","setInteriorEdgesInResult","buildEdgeRings","visitShellInteriors","hasUnvisitedShellEdge","eiCurr","eiNext","computeEdgeEnds","createEdgeEndForPrev","createEdgeEndForNext","foundInterior","computeLabelSide","computeLabelOn","computeLabelSides","eb","computeIntersectionNodes","copyNodesAndLabels","eeBuilder","eeList","insertEdgeEnds","edgeIt","setLabelBoundary","isAreaLabelsConsistent","eeb","intersector","isNodeEdgeAreaLabelsConsistent","innerRing","innerRingPts","results","searchRing","searchRingPts","innerRingPt","findPtNotNode","isInside","errMsg","locStr","getMessage","ERROR","REPEATED_POINT","HOLE_OUTSIDE_SHELL","NESTED_HOLES","DISCONNECTED_INTERIOR","SELF_INTERSECTION","RING_SELF_INTERSECTION","NESTED_SHELLS","DUPLICATE_RINGS","TOO_FEW_POINTS","INVALID_COORDINATE","RING_NOT_CLOSED","checkInvalidCoordinates","nestedTester","innerHole","isNonNested","getNestedPoint","cat","isNodeConsistentArea","getInvalidPoint","hasDuplicateRings","shellPts","holePts","shellPt","holePt","checkNoSelfIntersectingRing","cit","isInteriorsConnected","nodeSet","pir","hasTooFewPoints","checkClosedRing","checkTooFewPoints","checkNoSelfIntersectingRings","checkClosedRings","checkConsistentArea","checkHolesInShell","checkHolesNotNested","checkConnectedInteriors","checkShellsNotNested","polyShell","badNestedPt","checkShellInsideHole","checkShellNotNested","testCoords","searchEdge","getRing","startDE","setRing","isInRing","hasShell","holeER","isIncluded","adjRing","isOuterHole","getOuterHole","adjShell","isIncludedSet","setIncluded","isProcessed","findDirEdgesInRing","minShellEnv","tryShellRing","tryShellEnv","obj0","obj1","r0","r1","iNode","computeNextCWEdges","endPt","nStart","nEnd","findLabeledEdgeRings","cutLines","maximalRings","convertMaximalToMinimalEdgeRings","edgeRingList","findEdgeRing","ringEdges","intNodes","findIntersectionNodes","computeNextCCWEdges","nodesToRemove","findNodesOfDegree","dangleLines","deleteAllEdges","nodeOutEdges","toNode","getDegreeNonDeleted","edgeRingStarts","currLabel","prevDE","outDE","firstOutDE","prevInDE","inDE","polygonize","validEdgeRingList","invalidRingList","getLineString","deleteDangles","deleteCutEdges","getEdgeRings","findValidRings","findShellsAndHoles","assignHolesToShells","includeAll","findDisjointShells","extractPolygons","computeHole","findOuterShells","outerHoleER","setProcessed","getPolygon","assignHoleToShell","isMoreToScan","updateIncluded","dimA","dimB","hasProperInteriorIntersection","thisIndex","labelIsolatedEdge","computeDisjointIM","labelIsolatedNodes","computeProperIntersectionIM","ee0","ee1","labelNodeEdges","labelIsolatedEdges","labelIsolatedNode","updateIMFromEdges","ga","gb","isPointContainedInBoundary","isLineStringContainedInBoundary","isContainedInBoundary","isLineSegmentContainedInBoundary","segEnv","isSegUpwards","applyTo","ecpVisitor","riVisitor","elementEnv","rectPt","checkIntersectionWithLineStrings","testLine","checkIntersectionWithSegments","seq1","isRectangle","relate","isCovers","isIntersects","touches","within","coveredBy","relOp","getIntersectionMatrix","intersectionPattern","relateWithCheck","isOverlaps","disjoint","crosses","isCrosses","isContains","elems","elemGeom","extractElements","combine","combiner","createList","obj2","exteriorCoords","ptComp","geomTree","unionTree","disjointGeoms","intersectingGeoms","elem","g0Env","g1Env","unionActual","commonEnv","unionUsingEnvelopeIntersection","STRTREE_NODE_CAPACITY","itemTree","binaryUnion","unionSafe","unionOptimized","restrictToPolygons","reduceToGeometries","common","disjointPolys","g0Int","extractByEnvelope","g1Int","gColl","unionAll","unionPoints","ptGeom","unionNoOpt","unionLines","lineGeom","unionPolygons","unionLA","unionWithNull","reducedCoords","noRepeatedCoordList","noRepeatedCoords","minLength","collapsedCoords","geomToBuffer","changePM","bufGeom","finalGeom","geomEdit","createFactory","finalRemoveCollapsed","newPM","createEditor","inputFactory","reducePW","reducePointwise","fixPolygonalTopology","reducer","setPointwise","simplifySection","tss","rawGeom","rawAreaGeom","removeDegenerateRings","simpResult","resultSegsSize","getSegments","newSeg","sectionIndex","candidateSeg","hasBadOutputIntersection","hasBadInputIntersection","getSegment","addToResult","isValidToSimplify","getResultSize","getMinimumSize","furthestPtIndex","findFurthestPoint","hasBadIntersection","flatten","querySegs","maxDist","midPt","getParentCoordinates","isInLineSection","getParent","taggedLines","tlss","taggedLine","createCoordinateSequence","getResultCoordinates","minSize","minFrac","pointAlongReverse","actualLen","getConstrainedLength","minLen","encroachPt","lineSeg","midPtLen","splitSeg","projPt","projectedSplitPoint","nonEncroachDiam","maxSplitLen","setMinimumLength","splitAt","getSplitPoint","triArea","isInCircleDDNormalized","bdx","bdy","cdx","cdy","abdet","bcdet","cadet","alift","blift","clift","checkRobustInCircle","nonRobustInCircle","isInCircleNonRobust","isInCircleDD","isInCircleDDSlow","isInCircleCC","circumCentre","toPoint","isInCircleDDFast","aTerm","triAreaDDFast","bTerm","cTerm","pTerm","cc","ccRadius","isInCircleNormalized","triAreaDDSlow","isInCircleRobust","t1","t2","cab","cbc","hcc","nre","err","getZ","sa","crossProduct","BEHIND","magn","BEYOND","ORIGIN","DESTINATION","BETWEEN","circleCenter","edgeLength","el","ptLen","isOnConstraint","qe","equalsOriented","invRot","rot","setOrig","makeEdge","q0","q3","base","setDest","oPrev","lNext","beta","t3","t4","connect","isVertexOfEdge","isOnEdge","delete","isInCircle","lPrev","vertices","insertSite","isLive","locateFromEdge","includeFrame","visitTriangles","getTriangleVertices","cellPts","startQE","cellPoly","ea","ec","leftTri","getTriangleEdges","rightTri","vLeftTriOther","isFrameVertex","vRightTriOther","triVisitor","edgeStack","visitedEdges","fetchTriangleToVisit","getTriangles","vd","curr","edgeCount","isFrame","isFrameEdge","getPrimaryEdges","visitedVertices","qd","priQE","getPrimary","eSym","eRot","eRotSym","iter","maxIter","toLineSegment","dPrev","cells","getVertexUniqueEdges","getVoronoiCellPolygon","vorCells","getVoronoiCellPolygons","triPtsList","getTriangleCoordinates","tris","triPt","locEdge","triEdge","ccVertex","_left","_right","findBestMatchNode","increment","insertExact","queryEnv","queryNode","currentNode","odd","discriminant","searchLeft","searchRight","getLeft","getRight","queryEnvelope","leafNode","isOddLevel","isLessThan","setLeft","setRight","toCoordinates","kdnodes","includeRepeated","getCount","update","addConstraintVertices","splits","enforceGabriel","MAX_SPLIT_ITER","getPointArray","hull","computeConvexHull","insertSites","getStart","getEnd","segRadius","closestNonGabriel","testRadius","testDist","segsToInsert","newSegments","segsToRemove","findNonGabrielPoint","findSplitPoint","splitVertex","createVertex","getStartX","getStartY","getStartZ","getEndX","getEndY","getEndZ","removeAll","setOnConstraint","vertexEnv","computeVertexEnvelope","allPointsEnv","computeBoundingBox","setLocator","kdnode","isRepeated","snappedV","siteEnv","toVertices","extractUniqueCoordinates","unique","coordsCopy","verts","containsKey","createVertices","createConstraintSegments","sites","createSiteVertices","cdt","setConstraints","formInitialDelaunay","enforceConstraints","getSubdivision","constraintSegs","getVoronoiDiagram","clipGeometryCollection","clipPoly","clipped","lineComp","nseg","pointAlongSegmentByFraction","setToEnd","lastLine","getSegmentLength","lenToStart","lenToEnd","componentIndex1","segmentIndex1","segmentFraction1","getEndLocation","compareLocationValues","componentIndex0","segmentIndex0","segmentFraction0","getSegmentFraction","getSegmentIndex","indexOfFromStart","minComponentIndex","minSegmentIndex","isEndOfLine","getSegmentStart","getSegmentEnd","segDistance","candidateComponentIndex","candidateSegmentIndex","getVertexIndex","endLoc","closestAfter","indexOfAfter","subLine","locPt","subLineLoc","indicesOf","endLine","rawPts","validCoordinateSequence","allowRepeatedPoints","builder","setFixInvalidLines","isVertex","startSegmentIndex","lastSegmentIndex","newCoordinateArray","computeLinear","indexLow","toLowest","ptMeasure","segmentStartMeasure","segMeasureToPt","segmentNearestMeasure","projFactor","isEndpoint","compIndex","resolveLower","forwardLength","getLocationForward","resolveHigher","positiveIndex","getStartIndex","getEndIndex","locLow","startIndex2","clampIndex","endIndex2","resolveStartLower","locationOf","isEquals","args","_len","_key","centPt","interiorPt","getInteriorPoint","toText"],"mappings":"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","file":"dist/jsts.min.js","sourcesContent":["import extend from '../../../../extend';\nexport default function NumberUtil() {}\nextend(NumberUtil.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NumberUtil;\n\t}\n});\nNumberUtil.equalsWithTolerance = function (x1, x2, tolerance) {\n\treturn Math.abs(x1 - x2) <= tolerance;\n};\n","export default function IllegalArgumentException () {}\n","export default function Double () {}\nDouble.isNaN = n => Number.isNaN(n)\nDouble.doubleToLongBits = n => n\nDouble.longBitsToDouble = n => n\nDouble.isInfinite = n => !Number.isFinite(n)\nDouble.MAX_VALUE = Number.MAX_VALUE\n","export default function Comparable () {}\n","export default function Clonable () {}\n","export default function Comparator () {}\n","export default function Serializable () {}\n","export default function RuntimeException (message) {\n  this.name = 'RuntimeException'\n  this.message = message\n  this.stack = (new Error()).stack\n  Error.call(this, message)\n}\n\nRuntimeException.prototype = Object.create(Error.prototype)\nRuntimeException.prototype.constructor = Error\n","import extend from '../../../../extend';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nimport inherits from '../../../../inherits';\nexport default function AssertionFailedException() {\n\tif (arguments.length === 0) {\n\t\tRuntimeException.call(this);\n\t} else if (arguments.length === 1) {\n\t\tlet message = arguments[0];\n\t\tRuntimeException.call(this, message);\n\t}\n}\ninherits(AssertionFailedException, RuntimeException);\nextend(AssertionFailedException.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn AssertionFailedException;\n\t}\n});\n","import extend from '../../../../extend';\nimport AssertionFailedException from './AssertionFailedException';\nexport default function Assert() {}\nextend(Assert.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Assert;\n\t}\n});\nAssert.shouldNeverReachHere = function () {\n\tif (arguments.length === 0) {\n\t\tAssert.shouldNeverReachHere(null);\n\t} else if (arguments.length === 1) {\n\t\tlet message = arguments[0];\n\t\tthrow new AssertionFailedException(\"Should never reach here\" + (message !== null ? \": \" + message : \"\"));\n\t}\n};\nAssert.isTrue = function () {\n\tif (arguments.length === 1) {\n\t\tlet assertion = arguments[0];\n\t\tAssert.isTrue(assertion, null);\n\t} else if (arguments.length === 2) {\n\t\tlet assertion = arguments[0], message = arguments[1];\n\t\tif (!assertion) {\n\t\t\tif (message === null) {\n\t\t\t\tthrow new AssertionFailedException();\n\t\t\t} else {\n\t\t\t\tthrow new AssertionFailedException(message);\n\t\t\t}\n\t\t}\n\t}\n};\nAssert.equals = function () {\n\tif (arguments.length === 2) {\n\t\tlet expectedValue = arguments[0], actualValue = arguments[1];\n\t\tAssert.equals(expectedValue, actualValue, null);\n\t} else if (arguments.length === 3) {\n\t\tlet expectedValue = arguments[0], actualValue = arguments[1], message = arguments[2];\n\t\tif (!actualValue.equals(expectedValue)) {\n\t\t\tthrow new AssertionFailedException(\"Expected \" + expectedValue + \" but encountered \" + actualValue + (message !== null ? \": \" + message : \"\"));\n\t\t}\n\t}\n};\n","import NumberUtil from '../util/NumberUtil';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Comparator from '../../../../java/util/Comparator';\nimport Serializable from '../../../../java/io/Serializable';\nimport Assert from '../util/Assert';\nexport default function Coordinate() {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.z = null;\n\tif (arguments.length === 0) {\n\t\tCoordinate.call(this, 0.0, 0.0);\n\t} else if (arguments.length === 1) {\n\t\tlet c = arguments[0];\n\t\tCoordinate.call(this, c.x, c.y, c.z);\n\t} else if (arguments.length === 2) {\n\t\tlet x = arguments[0], y = arguments[1];\n\t\tCoordinate.call(this, x, y, Coordinate.NULL_ORDINATE);\n\t} else if (arguments.length === 3) {\n\t\tlet x = arguments[0], y = arguments[1], z = arguments[2];\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n}\nextend(Coordinate.prototype, {\n\tsetOrdinate: function (ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\tthis.x = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Y:\n\t\t\t\tthis.y = value;\n\t\t\t\tbreak;\n\t\t\tcase Coordinate.Z:\n\t\t\t\tthis.z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t\t}\n\t},\n\tequals2D: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\tif (this.x !== other.x) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.y !== other.y) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet c = arguments[0], tolerance = arguments[1];\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\tgetOrdinate: function (ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase Coordinate.X:\n\t\t\t\treturn this.x;\n\t\t\tcase Coordinate.Y:\n\t\t\t\treturn this.y;\n\t\t\tcase Coordinate.Z:\n\t\t\t\treturn this.z;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid ordinate index: \" + ordinateIndex);\n\t},\n\tequals3D: function (other) {\n\t\treturn this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z));\n\t},\n\tequals: function (other) {\n\t\tif (!(other instanceof Coordinate)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.equals2D(other);\n\t},\n\tequalInZ: function (c, tolerance) {\n\t\treturn NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);\n\t},\n\tcompareTo: function (o) {\n\t\tvar other = o;\n\t\tif (this.x < other.x) return -1;\n\t\tif (this.x > other.x) return 1;\n\t\tif (this.y < other.y) return -1;\n\t\tif (this.y > other.y) return 1;\n\t\treturn 0;\n\t},\n\tclone: function () {\n\t\ttry {\n\t\t\tvar coord = null;\n\t\t\treturn coord;\n\t\t} catch (e) {\n\t\t\tif (e instanceof CloneNotSupportedException) {\n\t\t\t\tAssert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\");\n\t\t\t\treturn null;\n\t\t\t} else throw e;\n\t\t} finally {}\n\t},\n\tcopy: function () {\n\t\treturn new Coordinate(this);\n\t},\n\ttoString: function () {\n\t\treturn \"(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\n\t},\n\tdistance3D: function (c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\tvar dz = this.z - c.z;\n\t\treturn Math.sqrt(dx * dx + dy * dy + dz * dz);\n\t},\n\tdistance: function (c) {\n\t\tvar dx = this.x - c.x;\n\t\tvar dy = this.y - c.y;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t},\n\thashCode: function () {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this.x);\n\t\tresult = 37 * result + Coordinate.hashCode(this.y);\n\t\treturn result;\n\t},\n\tsetCoordinate: function (other) {\n\t\tthis.x = other.x;\n\t\tthis.y = other.y;\n\t\tthis.z = other.z;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable, Cloneable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn Coordinate;\n\t}\n});\nCoordinate.hashCode = function () {\n\tif (arguments.length === 1) {\n\t\tlet x = arguments[0];\n\t\tvar f = Double.doubleToLongBits(x);\n\t\treturn Math.trunc(f ^ f >>> 32);\n\t}\n};\nfunction DimensionalComparator() {\n\tthis.dimensionsToTest = 2;\n\tif (arguments.length === 0) {\n\t\tDimensionalComparator.call(this, 2);\n\t} else if (arguments.length === 1) {\n\t\tlet dimensionsToTest = arguments[0];\n\t\tif (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException(\"only 2 or 3 dimensions may be specified\");\n\t\tthis.dimensionsToTest = dimensionsToTest;\n\t}\n}\nextend(DimensionalComparator.prototype, {\n\tcompare: function (o1, o2) {\n\t\tvar c1 = o1;\n\t\tvar c2 = o2;\n\t\tvar compX = DimensionalComparator.compare(c1.x, c2.x);\n\t\tif (compX !== 0) return compX;\n\t\tvar compY = DimensionalComparator.compare(c1.y, c2.y);\n\t\tif (compY !== 0) return compY;\n\t\tif (this.dimensionsToTest <= 2) return 0;\n\t\tvar compZ = DimensionalComparator.compare(c1.z, c2.z);\n\t\treturn compZ;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function () {\n\t\treturn DimensionalComparator;\n\t}\n});\nDimensionalComparator.compare = function (a, b) {\n\tif (a < b) return -1;\n\tif (a > b) return 1;\n\tif (Double.isNaN(a)) {\n\t\tif (Double.isNaN(b)) return 0;\n\t\treturn -1;\n\t}\n\tif (Double.isNaN(b)) return 1;\n\treturn 0;\n};\nCoordinate.DimensionalComparator = DimensionalComparator;\nCoordinate.serialVersionUID = 6683108902428366910;\nCoordinate.NULL_ORDINATE = Double.NaN;\nCoordinate.X = 0;\nCoordinate.Y = 1;\nCoordinate.Z = 2;\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nexport default function Iterator() {};\n\n/**\n * Returns true if the iteration has more elements.\n * @return {boolean}\n */\nIterator.prototype.hasNext = function() {};\n\n/**\n * Returns the next element in the iteration.\n * @return {Object}\n */\nIterator.prototype.next = function() {};\n\n/**\n * Removes from the underlying collection the last element returned by the\n * iterator (optional operation).\n */\nIterator.prototype.remove = function() {};\n","import Iterator from './Iterator'\n\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n *\n * @constructor\n * @private\n */\nexport default function Collection() {};\n\n/**\n * Ensures that this collection contains the specified element (optional\n * operation).\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.add = function() {};\n\n\n/**\n * Appends all of the elements in the specified collection to the end of this\n * list, in the order that they are returned by the specified collection's\n * iterator (optional operation).\n * @param {javascript.util.Collection} c\n * @return {boolean}\n */\nCollection.prototype.addAll = function() {};\n\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nCollection.prototype.isEmpty = function() {};\n\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {javascript.util.Iterator}\n */\nCollection.prototype.iterator = function() {};\n\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {number}\n */\nCollection.prototype.size = function() {};\n\n\n/**\n * Returns an array containing all of the elements in this collection.\n * @return {Array}\n */\nCollection.prototype.toArray = function() {};\n\n\n/**\n * Removes a single instance of the specified element from this collection if it\n * is present. (optional)\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.remove = function() {};\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function IndexOutOfBoundsException(message) {\n  this.message = message || '';\n};\nIndexOutOfBoundsException.prototype = new Error();\n\n/**\n * @type {string}\n */\nIndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';\n","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n *\n * @extends {javascript.util.Collection}\n * @constructor\n * @private\n */\nexport default function List() { };\nList.prototype = Object.create(Collection.prototype);\nList.prototype.constructor = List\n\n/**\n * Returns the element at the specified position in this list.\n * @param {number} index\n * @return {Object}\n */\nList.prototype.get = function() { };\n\n\n/**\n * Replaces the element at the specified position in this list with the\n * specified element (optional operation).\n * @param {number} index\n * @param {Object} e\n * @return {Object}\n */\nList.prototype.set = function() { };\n\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nList.prototype.isEmpty = function() { };\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function NoSuchElementException(message) {\n  this.message = message || '';\n};\nNoSuchElementException.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nNoSuchElementException.prototype.name = 'NoSuchElementException';\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function OperationNotSupported(message) {\n  this.message = message || '';\n};\nOperationNotSupported.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nOperationNotSupported.prototype.name = 'OperationNotSupported';\n","import Collection from './Collection'\nimport IndexOutOfBoundsException from './IndexOutOfBoundsException'\nimport Iterator from './Iterator'\nimport List from './List'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n *\n * @extends List\n * @private\n */\nexport default function ArrayList () {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nArrayList.prototype = Object.create(List.prototype)\nArrayList.prototype.constructor = ArrayList;\n\nArrayList.prototype.ensureCapacity = function () {}\nArrayList.prototype.interfaces_ = function () { return [List, Collection] }\n\n/**\n * @override\n */\nArrayList.prototype.add = function(e) {\n  if (arguments.length === 1) {\n    this.array_.push(e)\n  } else {\n    this.array_.splice(arguments[0], arguments[1])\n  }\n  return true\n};\n\nArrayList.prototype.clear = function() {\n  this.array_ = []\n}\n\n/**\n * @override\n */\nArrayList.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.set = function(index, element) {\n  var oldElement = this.array_[index];\n  this.array_[index] = element;\n  return oldElement;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.get = function(index) {\n  if (index < 0 || index >= this.size()) {\n    throw new IndexOutOfBoundsException();\n  }\n\n  return this.array_[index];\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nArrayList.prototype.remove = function(o) {\n  var found = false;\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    if (this.array_[i] === o) {\n      this.array_.splice(i, 1);\n      found = true;\n      break;\n    }\n  }\n\n  return found;\n};\n\n\n\n/**\n * @extends {Iterator}\n * @param {ArrayList} arrayList\n * @constructor\n * @private\n */\nvar Iterator_ = function(arrayList) {\n  /**\n   * @type {ArrayList}\n   * @private\n  */\n  this.arrayList_ = arrayList;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.arrayList_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.arrayList_.get(this.position_++);\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.arrayList_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n/**\n * TODO: should be in ListIterator\n * @override\n */\nIterator_.prototype.set = function(element) {\n  return this.arrayList_.set(this.position_ - 1, element);\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  this.arrayList_.remove(this.arrayList_.get(this.position_));\n};\n","import Coordinate from './Coordinate';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport inherits from '../../../../inherits';\nexport default function CoordinateList() {\n\tArrayList.apply(this);\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet coord = arguments[0];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, true);\n\t} else if (arguments.length === 2) {\n\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\tthis.ensureCapacity(coord.length);\n\t\tthis.add(coord, allowRepeated);\n\t}\n}\ninherits(CoordinateList, ArrayList);\nextend(CoordinateList.prototype, {\n\tgetCoordinate: function (i) {\n\t\treturn this.get(i);\n\t},\n\taddAll: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet coll = arguments[0], allowRepeated = arguments[1];\n\t\t\tvar isChanged = false;\n\t\t\tfor (var i = coll.iterator(); i.hasNext(); ) {\n\t\t\t\tthis.add(i.next(), allowRepeated);\n\t\t\t\tisChanged = true;\n\t\t\t}\n\t\t\treturn isChanged;\n\t\t} else return ArrayList.prototype.addAll.apply(this, arguments);\n\t},\n\tclone: function () {\n\t\tvar clone = ArrayList.prototype.clone.call(this);\n\t\tfor (var i = 0; i < this.size(); i++) {\n\t\t\tclone.add(i, this.get(i).copy());\n\t\t}\n\t\treturn clone;\n\t},\n\ttoCoordinateArray: function () {\n\t\treturn this.toArray(CoordinateList.coordArrayType);\n\t},\n\tadd: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet coord = arguments[0];\n\t\t\tArrayList.prototype.add.call(this, coord);\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tthis.add(coord, allowRepeated, true);\n\t\t\t\treturn true;\n\t\t\t} else if (arguments[0] instanceof Coordinate && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tif (this.size() >= 1) {\n\t\t\t\t\t\tvar last = this.get(this.size() - 1);\n\t\t\t\t\t\tif (last.equals2D(coord)) return null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList.prototype.add.call(this, coord);\n\t\t\t} else if (arguments[0] instanceof Object && typeof arguments[1] === \"boolean\") {\n\t\t\t\tlet obj = arguments[0], allowRepeated = arguments[1];\n\t\t\t\tthis.add(obj, allowRepeated);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (typeof arguments[2] === \"boolean\" && (arguments[0] instanceof Array && typeof arguments[1] === \"boolean\")) {\n\t\t\t\tlet coord = arguments[0], allowRepeated = arguments[1], direction = arguments[2];\n\t\t\t\tif (direction) {\n\t\t\t\t\tfor (var i = 0; i < coord.length; i++) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i = coord.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {\n\t\t\t\tlet i = arguments[0], coord = arguments[1], allowRepeated = arguments[2];\n\t\t\t\tif (!allowRepeated) {\n\t\t\t\t\tvar size = this.size();\n\t\t\t\t\tif (size > 0) {\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tvar prev = this.get(i - 1);\n\t\t\t\t\t\t\tif (prev.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < size) {\n\t\t\t\t\t\t\tvar next = this.get(i);\n\t\t\t\t\t\t\tif (next.equals2D(coord)) return null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tArrayList.prototype.add.call(this, i, coord);\n\t\t\t}\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet coord = arguments[0], allowRepeated = arguments[1], start = arguments[2], end = arguments[3];\n\t\t\tvar inc = 1;\n\t\t\tif (start > end) inc = -1;\n\t\t\tfor (var i = start; i !== end; i += inc) {\n\t\t\t\tthis.add(coord[i], allowRepeated);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\tcloseRing: function () {\n\t\tif (this.size() > 0) this.add(new Coordinate(this.get(0)), false);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateList;\n\t}\n});\nCoordinateList.coordArrayType = new Array(0).fill(null);\n","import Coordinate from './Coordinate';\nimport extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default function Envelope() {\n\tthis.minx = null;\n\tthis.maxx = null;\n\tthis.miny = null;\n\tthis.maxy = null;\n\tif (arguments.length === 0) {\n\t\tthis.init();\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\tlet env = arguments[0];\n\t\t\tthis.init(env);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t} else if (arguments.length === 4) {\n\t\tlet x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];\n\t\tthis.init(x1, x2, y1, y2);\n\t}\n}\nextend(Envelope.prototype, {\n\tgetArea: function () {\n\t\treturn this.getWidth() * this.getHeight();\n\t},\n\tequals: function (other) {\n\t\tif (!(other instanceof Envelope)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherEnvelope = other;\n\t\tif (this.isNull()) {\n\t\t\treturn otherEnvelope.isNull();\n\t\t}\n\t\treturn this.maxx === otherEnvelope.getMaxX() && this.maxy === otherEnvelope.getMaxY() && this.minx === otherEnvelope.getMinX() && this.miny === otherEnvelope.getMinY();\n\t},\n\tintersection: function (env) {\n\t\tif (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();\n\t\tvar intMinX = this.minx > env.minx ? this.minx : env.minx;\n\t\tvar intMinY = this.miny > env.miny ? this.miny : env.miny;\n\t\tvar intMaxX = this.maxx < env.maxx ? this.maxx : env.maxx;\n\t\tvar intMaxY = this.maxy < env.maxy ? this.maxy : env.maxy;\n\t\treturn new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n\t},\n\tisNull: function () {\n\t\treturn this.maxx < this.minx;\n\t},\n\tgetMaxX: function () {\n\t\treturn this.maxx;\n\t},\n\tcovers: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.covers(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn other.getMinX() >= this.minx && other.getMaxX() <= this.maxx && other.getMinY() >= this.miny && other.getMaxY() <= this.maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) return false;\n\t\t\treturn x >= this.minx && x <= this.maxx && y >= this.miny && y <= this.maxy;\n\t\t}\n\t},\n\tintersects: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (this.isNull() || other.isNull()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn !(other.minx > this.maxx || other.maxx < this.minx || other.miny > this.maxy || other.maxy < this.miny);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.intersects(p.x, p.y);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) return false;\n\t\t\treturn !(x > this.maxx || x < this.minx || y > this.maxy || y < this.miny);\n\t\t}\n\t},\n\tgetMinY: function () {\n\t\treturn this.miny;\n\t},\n\tgetMinX: function () {\n\t\treturn this.minx;\n\t},\n\texpandToInclude: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\tthis.expandToInclude(p.x, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\tif (other.isNull()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (this.isNull()) {\n\t\t\t\t\tthis.minx = other.getMinX();\n\t\t\t\t\tthis.maxx = other.getMaxX();\n\t\t\t\t\tthis.miny = other.getMinY();\n\t\t\t\t\tthis.maxy = other.getMaxY();\n\t\t\t\t} else {\n\t\t\t\t\tif (other.minx < this.minx) {\n\t\t\t\t\t\tthis.minx = other.minx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other.maxx > this.maxx) {\n\t\t\t\t\t\tthis.maxx = other.maxx;\n\t\t\t\t\t}\n\t\t\t\t\tif (other.miny < this.miny) {\n\t\t\t\t\t\tthis.miny = other.miny;\n\t\t\t\t\t}\n\t\t\t\t\tif (other.maxy > this.maxy) {\n\t\t\t\t\t\tthis.maxy = other.maxy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\tif (this.isNull()) {\n\t\t\t\tthis.minx = x;\n\t\t\t\tthis.maxx = x;\n\t\t\t\tthis.miny = y;\n\t\t\t\tthis.maxy = y;\n\t\t\t} else {\n\t\t\t\tif (x < this.minx) {\n\t\t\t\t\tthis.minx = x;\n\t\t\t\t}\n\t\t\t\tif (x > this.maxx) {\n\t\t\t\t\tthis.maxx = x;\n\t\t\t\t}\n\t\t\t\tif (y < this.miny) {\n\t\t\t\t\tthis.miny = y;\n\t\t\t\t}\n\t\t\t\tif (y > this.maxy) {\n\t\t\t\t\tthis.maxy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tminExtent: function () {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w < h) return w;\n\t\treturn h;\n\t},\n\tgetWidth: function () {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.maxx - this.minx;\n\t},\n\tcompareTo: function (o) {\n\t\tvar env = o;\n\t\tif (this.isNull()) {\n\t\t\tif (env.isNull()) return 0;\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (env.isNull()) return 1;\n\t\t}\n\t\tif (this.minx < env.minx) return -1;\n\t\tif (this.minx > env.minx) return 1;\n\t\tif (this.miny < env.miny) return -1;\n\t\tif (this.miny > env.miny) return 1;\n\t\tif (this.maxx < env.maxx) return -1;\n\t\tif (this.maxx > env.maxx) return 1;\n\t\tif (this.maxy < env.maxy) return -1;\n\t\tif (this.maxy > env.maxy) return 1;\n\t\treturn 0;\n\t},\n\ttranslate: function (transX, transY) {\n\t\tif (this.isNull()) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n\t},\n\ttoString: function () {\n\t\treturn \"Env[\" + this.minx + \" : \" + this.maxx + \", \" + this.miny + \" : \" + this.maxy + \"]\";\n\t},\n\tsetToNull: function () {\n\t\tthis.minx = 0;\n\t\tthis.maxx = -1;\n\t\tthis.miny = 0;\n\t\tthis.maxy = -1;\n\t},\n\tgetHeight: function () {\n\t\tif (this.isNull()) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.maxy - this.miny;\n\t},\n\tmaxExtent: function () {\n\t\tif (this.isNull()) return 0.0;\n\t\tvar w = this.getWidth();\n\t\tvar h = this.getHeight();\n\t\tif (w > h) return w;\n\t\treturn h;\n\t},\n\texpandBy: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet distance = arguments[0];\n\t\t\tthis.expandBy(distance, distance);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet deltaX = arguments[0], deltaY = arguments[1];\n\t\t\tif (this.isNull()) return null;\n\t\t\tthis.minx -= deltaX;\n\t\t\tthis.maxx += deltaX;\n\t\t\tthis.miny -= deltaY;\n\t\t\tthis.maxy += deltaY;\n\t\t\tif (this.minx > this.maxx || this.miny > this.maxy) this.setToNull();\n\t\t}\n\t},\n\tcontains: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Envelope) {\n\t\t\t\tlet other = arguments[0];\n\t\t\t\treturn this.covers(other);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.covers(p);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet x = arguments[0], y = arguments[1];\n\t\t\treturn this.covers(x, y);\n\t\t}\n\t},\n\tcentre: function () {\n\t\tif (this.isNull()) return null;\n\t\treturn new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n\t},\n\tinit: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.setToNull();\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\tthis.init(p.x, p.x, p.y, p.y);\n\t\t\t} else if (arguments[0] instanceof Envelope) {\n\t\t\t\tlet env = arguments[0];\n\t\t\t\tthis.minx = env.minx;\n\t\t\t\tthis.maxx = env.maxx;\n\t\t\t\tthis.miny = env.miny;\n\t\t\t\tthis.maxy = env.maxy;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.init(p1.x, p2.x, p1.y, p2.y);\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];\n\t\t\tif (x1 < x2) {\n\t\t\t\tthis.minx = x1;\n\t\t\t\tthis.maxx = x2;\n\t\t\t} else {\n\t\t\t\tthis.minx = x2;\n\t\t\t\tthis.maxx = x1;\n\t\t\t}\n\t\t\tif (y1 < y2) {\n\t\t\t\tthis.miny = y1;\n\t\t\t\tthis.maxy = y2;\n\t\t\t} else {\n\t\t\t\tthis.miny = y2;\n\t\t\t\tthis.maxy = y1;\n\t\t\t}\n\t\t}\n\t},\n\tgetMaxY: function () {\n\t\treturn this.maxy;\n\t},\n\tdistance: function (env) {\n\t\tif (this.intersects(env)) return 0;\n\t\tvar dx = 0.0;\n\t\tif (this.maxx < env.minx) dx = env.minx - this.maxx; else if (this.minx > env.maxx) dx = this.minx - env.maxx;\n\t\tvar dy = 0.0;\n\t\tif (this.maxy < env.miny) dy = env.miny - this.maxy; else if (this.miny > env.maxy) dy = this.miny - env.maxy;\n\t\tif (dx === 0.0) return dy;\n\t\tif (dy === 0.0) return dx;\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t},\n\thashCode: function () {\n\t\tvar result = 17;\n\t\tresult = 37 * result + Coordinate.hashCode(this.minx);\n\t\tresult = 37 * result + Coordinate.hashCode(this.maxx);\n\t\tresult = 37 * result + Coordinate.hashCode(this.miny);\n\t\tresult = 37 * result + Coordinate.hashCode(this.maxy);\n\t\treturn result;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn Envelope;\n\t}\n});\nEnvelope.intersects = function () {\n\tif (arguments.length === 3) {\n\t\tlet p1 = arguments[0], p2 = arguments[1], q = arguments[2];\n\t\tif (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t} else if (arguments.length === 4) {\n\t\tlet p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];\n\t\tvar minq = Math.min(q1.x, q2.x);\n\t\tvar maxq = Math.max(q1.x, q2.x);\n\t\tvar minp = Math.min(p1.x, p2.x);\n\t\tvar maxp = Math.max(p1.x, p2.x);\n\t\tif (minp > maxq) return false;\n\t\tif (maxp < minq) return false;\n\t\tminq = Math.min(q1.y, q2.y);\n\t\tmaxq = Math.max(q1.y, q2.y);\n\t\tminp = Math.min(p1.y, p2.y);\n\t\tmaxp = Math.max(p1.y, p2.y);\n\t\tif (minp > maxq) return false;\n\t\tif (maxp < minq) return false;\n\t\treturn true;\n\t}\n};\nEnvelope.serialVersionUID = 5873921885273102420;\n","export default function Exception () {}\n","import extend from '../../../../extend';\nimport Exception from '../../../../java/lang/Exception';\nimport inherits from '../../../../inherits';\nexport default function NotRepresentableException() {\n\tException.call(this, \"Projective point not representable on the Cartesian plane.\");\n}\ninherits(NotRepresentableException, Exception);\nextend(NotRepresentableException.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NotRepresentableException;\n\t}\n});\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nexport default function Location() {}\nextend(Location.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Location;\n\t}\n});\nLocation.toLocationSymbol = function (locationValue) {\n\tswitch (locationValue) {\n\t\tcase Location.EXTERIOR:\n\t\t\treturn 'e';\n\t\tcase Location.BOUNDARY:\n\t\t\treturn 'b';\n\t\tcase Location.INTERIOR:\n\t\t\treturn 'i';\n\t\tcase Location.NONE:\n\t\t\treturn '-';\n\t}\n\tthrow new IllegalArgumentException(\"Unknown location value: \" + locationValue);\n};\nLocation.INTERIOR = 0;\nLocation.BOUNDARY = 1;\nLocation.EXTERIOR = 2;\nLocation.NONE = -1;\n","import Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nexport default function MathUtil() {}\nextend(MathUtil.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MathUtil;\n\t}\n});\nMathUtil.log10 = function (x) {\n\tvar ln = Math.log(x);\n\tif (Double.isInfinite(ln)) return ln;\n\tif (Double.isNaN(ln)) return ln;\n\treturn ln / MathUtil.LOG_10;\n};\nMathUtil.min = function (v1, v2, v3, v4) {\n\tvar min = v1;\n\tif (v2 < min) min = v2;\n\tif (v3 < min) min = v3;\n\tif (v4 < min) min = v4;\n\treturn min;\n};\nMathUtil.clamp = function () {\n\tif (typeof arguments[2] === \"number\" && (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\")) {\n\t\tlet x = arguments[0], min = arguments[1], max = arguments[2];\n\t\tif (x < min) return min;\n\t\tif (x > max) return max;\n\t\treturn x;\n\t} else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {\n\t\tlet x = arguments[0], min = arguments[1], max = arguments[2];\n\t\tif (x < min) return min;\n\t\tif (x > max) return max;\n\t\treturn x;\n\t}\n};\nMathUtil.wrap = function (index, max) {\n\tif (index < 0) {\n\t\treturn max - -index % max;\n\t}\n\treturn index % max;\n};\nMathUtil.max = function () {\n\tif (arguments.length === 3) {\n\t\tlet v1 = arguments[0], v2 = arguments[1], v3 = arguments[2];\n\t\tvar max = v1;\n\t\tif (v2 > max) max = v2;\n\t\tif (v3 > max) max = v3;\n\t\treturn max;\n\t} else if (arguments.length === 4) {\n\t\tlet v1 = arguments[0], v2 = arguments[1], v3 = arguments[2], v4 = arguments[3];\n\t\tvar max = v1;\n\t\tif (v2 > max) max = v2;\n\t\tif (v3 > max) max = v3;\n\t\tif (v4 > max) max = v4;\n\t\treturn max;\n\t}\n};\nMathUtil.average = function (x1, x2) {\n\treturn (x1 + x2) / 2.0;\n};\nMathUtil.LOG_10 = Math.log(10);\n","export default function StringBuffer (str) {\n  this.str = str\n}\n\nStringBuffer.prototype.append = function (e) {\n  this.str += e\n}\n\nStringBuffer.prototype.setCharAt = function (i, c) {\n  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1)\n}\n\nStringBuffer.prototype.toString = function (e) {\n  return this.str\n}\n","export default function Integer (value) {\n  this.value = value\n}\n\nInteger.prototype.intValue = function () {\n  return this.value\n}\nInteger.prototype.compareTo = function (o) {\n  if (this.value < o) return -1\n  if (this.value > o) return 1\n  return 0\n}\n\nInteger.isNaN = n => Number.isNaN(n)\n","export default function Character () {}\nCharacter.isWhitespace = c => ((c <= 32 && c >= 0) || c == 127)\nCharacter.toUpperCase = c => c.toUpperCase()\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport Integer from '../../../../java/lang/Integer';\nimport Character from '../../../../java/lang/Character';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default function DD() {\n\tthis.hi = 0.0;\n\tthis.lo = 0.0;\n\tif (arguments.length === 0) {\n\t\tthis.init(0.0);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tlet x = arguments[0];\n\t\t\tthis.init(x);\n\t\t} else if (arguments[0] instanceof DD) {\n\t\t\tlet dd = arguments[0];\n\t\t\tthis.init(dd);\n\t\t} else if (typeof arguments[0] === \"string\") {\n\t\t\tlet str = arguments[0];\n\t\t\tDD.call(this, DD.parse(str));\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet hi = arguments[0], lo = arguments[1];\n\t\tthis.init(hi, lo);\n\t}\n}\nextend(DD.prototype, {\n\tle: function (y) {\n\t\treturn this.hi < y.hi || this.hi === y.hi && this.lo <= y.lo;\n\t},\n\textractSignificantDigits: function (insertDecimalPoint, magnitude) {\n\t\tvar y = this.abs();\n\t\tvar mag = DD.magnitude(y.hi);\n\t\tvar scale = DD.TEN.pow(mag);\n\t\ty = y.divide(scale);\n\t\tif (y.gt(DD.TEN)) {\n\t\t\ty = y.divide(DD.TEN);\n\t\t\tmag += 1;\n\t\t} else if (y.lt(DD.ONE)) {\n\t\t\ty = y.multiply(DD.TEN);\n\t\t\tmag -= 1;\n\t\t}\n\t\tvar decimalPointPos = mag + 1;\n\t\tvar buf = new StringBuffer();\n\t\tvar numDigits = DD.MAX_PRINT_DIGITS - 1;\n\t\tfor (var i = 0; i <= numDigits; i++) {\n\t\t\tif (insertDecimalPoint && i === decimalPointPos) {\n\t\t\t\tbuf.append('.');\n\t\t\t}\n\t\t\tvar digit = Math.trunc(y.hi);\n\t\t\tif (digit < 0 || digit > 9) {}\n\t\t\tif (digit < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar rebiasBy10 = false;\n\t\t\tvar digitChar = 0;\n\t\t\tif (digit > 9) {\n\t\t\t\trebiasBy10 = true;\n\t\t\t\tdigitChar = '9';\n\t\t\t} else {\n\t\t\t\tdigitChar = '0' + digit;\n\t\t\t}\n\t\t\tbuf.append(digitChar);\n\t\t\ty = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n\t\t\tif (rebiasBy10) y.selfAdd(DD.TEN);\n\t\t\tvar continueExtractingDigits = true;\n\t\t\tvar remMag = DD.magnitude(y.hi);\n\t\t\tif (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;\n\t\t\tif (!continueExtractingDigits) break;\n\t\t}\n\t\tmagnitude[0] = mag;\n\t\treturn buf.toString();\n\t},\n\tsqr: function () {\n\t\treturn this.multiply(this);\n\t},\n\tdoubleValue: function () {\n\t\treturn this.hi + this.lo;\n\t},\n\tsubtract: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.add(y.negate());\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.add(-y);\n\t\t}\n\t},\n\tequals: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn this.hi === y.hi && this.lo === y.lo;\n\t\t}\n\t},\n\tisZero: function () {\n\t\treturn this.hi === 0.0 && this.lo === 0.0;\n\t},\n\tselfSubtract: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y.hi, -y.lo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (this.isNaN()) return this;\n\t\t\treturn this.selfAdd(-y, 0.0);\n\t\t}\n\t},\n\tgetSpecialNumberString: function () {\n\t\tif (this.isZero()) return \"0.0\";\n\t\tif (this.isNaN()) return \"NaN \";\n\t\treturn null;\n\t},\n\tmin: function (x) {\n\t\tif (this.le(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t},\n\tselfDivide: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfDivide(y.hi, y.lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfDivide(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\t\tC = this.hi / yhi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * yhi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - yhi;\n\t\t\tU = C * yhi;\n\t\t\thy = u - hy;\n\t\t\tty = yhi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this.hi - U - u + this.lo - C * ylo) / yhi;\n\t\t\tu = C + c;\n\t\t\tthis.hi = u;\n\t\t\tthis.lo = C - u + c;\n\t\t\treturn this;\n\t\t}\n\t},\n\tdump: function () {\n\t\treturn \"DD<\" + this.hi + \", \" + this.lo + \">\";\n\t},\n\tdivide: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\t\tC = this.hi / y.hi;\n\t\t\tc = DD.SPLIT * C;\n\t\t\thc = c - C;\n\t\t\tu = DD.SPLIT * y.hi;\n\t\t\thc = c - hc;\n\t\t\ttc = C - hc;\n\t\t\thy = u - y.hi;\n\t\t\tU = C * y.hi;\n\t\t\thy = u - hy;\n\t\t\tty = y.hi - hy;\n\t\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\t\tc = (this.hi - U - u + this.lo - C * y.lo) / y.hi;\n\t\t\tu = C + c;\n\t\t\tvar zhi = u;\n\t\t\tvar zlo = C - u + c;\n\t\t\treturn new DD(zhi, zlo);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfDivide(y, 0.0);\n\t\t}\n\t},\n\tge: function (y) {\n\t\treturn this.hi > y.hi || this.hi === y.hi && this.lo >= y.lo;\n\t},\n\tpow: function (exp) {\n\t\tif (exp === 0.0) return DD.valueOf(1.0);\n\t\tvar r = new DD(this);\n\t\tvar s = DD.valueOf(1.0);\n\t\tvar n = Math.abs(exp);\n\t\tif (n > 1) {\n\t\t\twhile (n > 0) {\n\t\t\t\tif (n % 2 === 1) {\n\t\t\t\t\ts.selfMultiply(r);\n\t\t\t\t}\n\t\t\t\tn /= 2;\n\t\t\t\tif (n > 0) r = r.sqr();\n\t\t\t}\n\t\t} else {\n\t\t\ts = r;\n\t\t}\n\t\tif (exp < 0) return s.reciprocal();\n\t\treturn s;\n\t},\n\tceil: function () {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.ceil(this.hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this.hi) {\n\t\t\tflo = Math.ceil(this.lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t},\n\tcompareTo: function (o) {\n\t\tvar other = o;\n\t\tif (this.hi < other.hi) return -1;\n\t\tif (this.hi > other.hi) return 1;\n\t\tif (this.lo < other.lo) return -1;\n\t\tif (this.lo > other.lo) return 1;\n\t\treturn 0;\n\t},\n\trint: function () {\n\t\tif (this.isNaN()) return this;\n\t\tvar plus5 = this.add(0.5);\n\t\treturn plus5.floor();\n\t},\n\tsetValue: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet value = arguments[0];\n\t\t\tthis.init(value);\n\t\t\treturn this;\n\t\t}\n\t},\n\tmax: function (x) {\n\t\tif (this.ge(x)) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\treturn x;\n\t\t}\n\t},\n\tsqrt: function () {\n\t\tif (this.isZero()) return DD.valueOf(0.0);\n\t\tif (this.isNegative()) {\n\t\t\treturn DD.NaN;\n\t\t}\n\t\tvar x = 1.0 / Math.sqrt(this.hi);\n\t\tvar ax = this.hi * x;\n\t\tvar axdd = DD.valueOf(ax);\n\t\tvar diffSq = this.subtract(axdd.sqr());\n\t\tvar d2 = diffSq.hi * (x * 0.5);\n\t\treturn axdd.add(d2);\n\t},\n\tselfAdd: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfAdd(y.hi, y.lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\tvar H = null, h = null, S = null, s = null, e = null, f = null;\n\t\t\t\tS = this.hi + y;\n\t\t\t\te = S - this.hi;\n\t\t\t\ts = S - e;\n\t\t\t\ts = y - e + (this.hi - s);\n\t\t\t\tf = s + this.lo;\n\t\t\t\tH = S + f;\n\t\t\t\th = f + (S - H);\n\t\t\t\tthis.hi = H + h;\n\t\t\t\tthis.lo = h + (H - this.hi);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar H = null, h = null, T = null, t = null, S = null, s = null, e = null, f = null;\n\t\t\tS = this.hi + yhi;\n\t\t\tT = this.lo + ylo;\n\t\t\te = S - this.hi;\n\t\t\tf = T - this.lo;\n\t\t\ts = S - e;\n\t\t\tt = T - f;\n\t\t\ts = yhi - e + (this.hi - s);\n\t\t\tt = ylo - f + (this.lo - t);\n\t\t\te = s + T;\n\t\t\tH = S + e;\n\t\t\th = e + (S - H);\n\t\t\te = t + h;\n\t\t\tvar zhi = H + e;\n\t\t\tvar zlo = e + (H - zhi);\n\t\t\tthis.hi = zhi;\n\t\t\tthis.lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t},\n\tselfMultiply: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof DD) {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y.hi, y.lo);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet y = arguments[0];\n\t\t\t\treturn this.selfMultiply(y, 0.0);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet yhi = arguments[0], ylo = arguments[1];\n\t\t\tvar hx = null, tx = null, hy = null, ty = null, C = null, c = null;\n\t\t\tC = DD.SPLIT * this.hi;\n\t\t\thx = C - this.hi;\n\t\t\tc = DD.SPLIT * yhi;\n\t\t\thx = C - hx;\n\t\t\ttx = this.hi - hx;\n\t\t\thy = c - yhi;\n\t\t\tC = this.hi * yhi;\n\t\t\thy = c - hy;\n\t\t\tty = yhi - hy;\n\t\t\tc = hx * hy - C + hx * ty + tx * hy + tx * ty + (this.hi * ylo + this.lo * yhi);\n\t\t\tvar zhi = C + c;\n\t\t\thx = C - zhi;\n\t\t\tvar zlo = c + hx;\n\t\t\tthis.hi = zhi;\n\t\t\tthis.lo = zlo;\n\t\t\treturn this;\n\t\t}\n\t},\n\tselfSqr: function () {\n\t\treturn this.selfMultiply(this);\n\t},\n\tfloor: function () {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tvar fhi = Math.floor(this.hi);\n\t\tvar flo = 0.0;\n\t\tif (fhi === this.hi) {\n\t\t\tflo = Math.floor(this.lo);\n\t\t}\n\t\treturn new DD(fhi, flo);\n\t},\n\tnegate: function () {\n\t\tif (this.isNaN()) return this;\n\t\treturn new DD(-this.hi, -this.lo);\n\t},\n\tclone: function () {\n\t\ttry {\n\t\t\treturn null;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof CloneNotSupportedException) {\n\t\t\t\treturn null;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t},\n\tmultiply: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\tif (y.isNaN()) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\tif (Double.isNaN(y)) return DD.createNaN();\n\t\t\treturn DD.copy(this).selfMultiply(y, 0.0);\n\t\t}\n\t},\n\tisNaN: function () {\n\t\treturn Double.isNaN(this.hi);\n\t},\n\tintValue: function () {\n\t\treturn Math.trunc(this.hi);\n\t},\n\ttoString: function () {\n\t\tvar mag = DD.magnitude(this.hi);\n\t\tif (mag >= -3 && mag <= 20) return this.toStandardNotation();\n\t\treturn this.toSciNotation();\n\t},\n\ttoStandardNotation: function () {\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar sigDigits = this.extractSignificantDigits(true, magnitude);\n\t\tvar decimalPointPos = magnitude[0] + 1;\n\t\tvar num = sigDigits;\n\t\tif (sigDigits.charAt(0) === '.') {\n\t\t\tnum = \"0\" + sigDigits;\n\t\t} else if (decimalPointPos < 0) {\n\t\t\tnum = \"0.\" + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n\t\t} else if (sigDigits.indexOf('.') === -1) {\n\t\t\tvar numZeroes = decimalPointPos - sigDigits.length;\n\t\t\tvar zeroes = DD.stringOfChar('0', numZeroes);\n\t\t\tnum = sigDigits + zeroes + \".0\";\n\t\t}\n\t\tif (this.isNegative()) return \"-\" + num;\n\t\treturn num;\n\t},\n\treciprocal: function () {\n\t\tvar hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;\n\t\tC = 1.0 / this.hi;\n\t\tc = DD.SPLIT * C;\n\t\thc = c - C;\n\t\tu = DD.SPLIT * this.hi;\n\t\thc = c - hc;\n\t\ttc = C - hc;\n\t\thy = u - this.hi;\n\t\tU = C * this.hi;\n\t\thy = u - hy;\n\t\tty = this.hi - hy;\n\t\tu = hc * hy - U + hc * ty + tc * hy + tc * ty;\n\t\tc = (1.0 - U - u - C * this.lo) / this.hi;\n\t\tvar zhi = C + c;\n\t\tvar zlo = C - zhi + c;\n\t\treturn new DD(zhi, zlo);\n\t},\n\ttoSciNotation: function () {\n\t\tif (this.isZero()) return DD.SCI_NOT_ZERO;\n\t\tvar specialStr = this.getSpecialNumberString();\n\t\tif (specialStr !== null) return specialStr;\n\t\tvar magnitude = new Array(1).fill(null);\n\t\tvar digits = this.extractSignificantDigits(false, magnitude);\n\t\tvar expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n\t\tif (digits.charAt(0) === '0') {\n\t\t\tthrow new IllegalStateException(\"Found leading zero: \" + digits);\n\t\t}\n\t\tvar trailingDigits = \"\";\n\t\tif (digits.length > 1) trailingDigits = digits.substring(1);\n\t\tvar digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\n\t\tif (this.isNegative()) return \"-\" + digitsWithDecimal + expStr;\n\t\treturn digitsWithDecimal + expStr;\n\t},\n\tabs: function () {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isNegative()) return this.negate();\n\t\treturn new DD(this);\n\t},\n\tisPositive: function () {\n\t\treturn this.hi > 0.0 || this.hi === 0.0 && this.lo > 0.0;\n\t},\n\tlt: function (y) {\n\t\treturn this.hi < y.hi || this.hi === y.hi && this.lo < y.lo;\n\t},\n\tadd: function () {\n\t\tif (arguments[0] instanceof DD) {\n\t\t\tlet y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet y = arguments[0];\n\t\t\treturn DD.copy(this).selfAdd(y);\n\t\t}\n\t},\n\tinit: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (typeof arguments[0] === \"number\") {\n\t\t\t\tlet x = arguments[0];\n\t\t\t\tthis.hi = x;\n\t\t\t\tthis.lo = 0.0;\n\t\t\t} else if (arguments[0] instanceof DD) {\n\t\t\t\tlet dd = arguments[0];\n\t\t\t\tthis.hi = dd.hi;\n\t\t\t\tthis.lo = dd.lo;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet hi = arguments[0], lo = arguments[1];\n\t\t\tthis.hi = hi;\n\t\t\tthis.lo = lo;\n\t\t}\n\t},\n\tgt: function (y) {\n\t\treturn this.hi > y.hi || this.hi === y.hi && this.lo > y.lo;\n\t},\n\tisNegative: function () {\n\t\treturn this.hi < 0.0 || this.hi === 0.0 && this.lo < 0.0;\n\t},\n\ttrunc: function () {\n\t\tif (this.isNaN()) return DD.NaN;\n\t\tif (this.isPositive()) return this.floor(); else return this.ceil();\n\t},\n\tsignum: function () {\n\t\tif (this.hi > 0) return 1;\n\t\tif (this.hi < 0) return -1;\n\t\tif (this.lo > 0) return 1;\n\t\tif (this.lo < 0) return -1;\n\t\treturn 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable, Comparable, Cloneable];\n\t},\n\tgetClass: function () {\n\t\treturn DD;\n\t}\n});\nDD.sqr = function (x) {\n\treturn DD.valueOf(x).selfMultiply(x);\n};\nDD.valueOf = function () {\n\tif (typeof arguments[0] === \"string\") {\n\t\tlet str = arguments[0];\n\t\treturn DD.parse(str);\n\t} else if (typeof arguments[0] === \"number\") {\n\t\tlet x = arguments[0];\n\t\treturn new DD(x);\n\t}\n};\nDD.sqrt = function (x) {\n\treturn DD.valueOf(x).sqrt();\n};\nDD.parse = function (str) {\n\tvar i = 0;\n\tvar strlen = str.length;\n\twhile (Character.isWhitespace(str.charAt(i))) i++;\n\tvar isNegative = false;\n\tif (i < strlen) {\n\t\tvar signCh = str.charAt(i);\n\t\tif (signCh === '-' || signCh === '+') {\n\t\t\ti++;\n\t\t\tif (signCh === '-') isNegative = true;\n\t\t}\n\t}\n\tvar val = new DD();\n\tvar numDigits = 0;\n\tvar numBeforeDec = 0;\n\tvar exp = 0;\n\twhile (true) {\n\t\tif (i >= strlen) break;\n\t\tvar ch = str.charAt(i);\n\t\ti++;\n\t\tif (Character.isDigit(ch)) {\n\t\t\tvar d = ch - '0';\n\t\t\tval.selfMultiply(DD.TEN);\n\t\t\tval.selfAdd(d);\n\t\t\tnumDigits++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch === '.') {\n\t\t\tnumBeforeDec = numDigits;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch === 'e' || ch === 'E') {\n\t\t\tvar expStr = str.substring(i);\n\t\t\ttry {\n\t\t\t\texp = Integer.parseInt(expStr);\n\t\t\t} catch (ex) {\n\t\t\t\tif (ex instanceof NumberFormatException) {\n\t\t\t\t\tthrow new NumberFormatException(\"Invalid exponent \" + expStr + \" in string \" + str);\n\t\t\t\t} else throw ex;\n\t\t\t} finally {}\n\t\t\tbreak;\n\t\t}\n\t\tthrow new NumberFormatException(\"Unexpected character '\" + ch + \"' at position \" + i + \" in string \" + str);\n\t}\n\tvar val2 = val;\n\tvar numDecPlaces = numDigits - numBeforeDec - exp;\n\tif (numDecPlaces === 0) {\n\t\tval2 = val;\n\t} else if (numDecPlaces > 0) {\n\t\tvar scale = DD.TEN.pow(numDecPlaces);\n\t\tval2 = val.divide(scale);\n\t} else if (numDecPlaces < 0) {\n\t\tvar scale = DD.TEN.pow(-numDecPlaces);\n\t\tval2 = val.multiply(scale);\n\t}\n\tif (isNegative) {\n\t\treturn val2.negate();\n\t}\n\treturn val2;\n};\nDD.createNaN = function () {\n\treturn new DD(Double.NaN, Double.NaN);\n};\nDD.copy = function (dd) {\n\treturn new DD(dd);\n};\nDD.magnitude = function (x) {\n\tvar xAbs = Math.abs(x);\n\tvar xLog10 = Math.log(xAbs) / Math.log(10);\n\tvar xMag = Math.trunc(Math.floor(xLog10));\n\tvar xApprox = Math.pow(10, xMag);\n\tif (xApprox * 10 <= xAbs) xMag += 1;\n\treturn xMag;\n};\nDD.stringOfChar = function (ch, len) {\n\tvar buf = new StringBuffer();\n\tfor (var i = 0; i < len; i++) {\n\t\tbuf.append(ch);\n\t}\n\treturn buf.toString();\n};\nDD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\nDD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\nDD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\nDD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\nDD.NaN = new DD(Double.NaN, Double.NaN);\nDD.EPS = 1.23259516440783e-32;\nDD.SPLIT = 134217729.0;\nDD.MAX_PRINT_DIGITS = 32;\nDD.TEN = DD.valueOf(10.0);\nDD.ONE = DD.valueOf(1.0);\nDD.SCI_NOT_EXPONENT_CHAR = \"E\";\nDD.SCI_NOT_ZERO = \"0.0E0\";\n","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport DD from '../math/DD';\nexport default function CGAlgorithmsDD() {}\nextend(CGAlgorithmsDD.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CGAlgorithmsDD;\n\t}\n});\nCGAlgorithmsDD.orientationIndex = function (p1, p2, q) {\n\tvar index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n\tif (index <= 1) return index;\n\tvar dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n\tvar dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n\tvar dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n\tvar dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n\treturn dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n};\nCGAlgorithmsDD.signOfDet2x2 = function (x1, y1, x2, y2) {\n\tvar det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n\treturn det.signum();\n};\nCGAlgorithmsDD.intersection = function (p1, p2, q1, q2) {\n\tvar denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n\tvar denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n\tvar denom = denom1.subtract(denom2);\n\tvar numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\tvar numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\tvar numx = numx1.subtract(numx2);\n\tvar fracP = numx.selfDivide(denom).doubleValue();\n\tvar x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n\tvar numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n\tvar numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n\tvar numy = numy1.subtract(numy2);\n\tvar fracQ = numy.selfDivide(denom).doubleValue();\n\tvar y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n\treturn new Coordinate(x, y);\n};\nCGAlgorithmsDD.orientationIndexFilter = function (pa, pb, pc) {\n\tvar detsum = null;\n\tvar detleft = (pa.x - pc.x) * (pb.y - pc.y);\n\tvar detright = (pa.y - pc.y) * (pb.x - pc.x);\n\tvar det = detleft - detright;\n\tif (detleft > 0.0) {\n\t\tif (detright <= 0.0) {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t} else {\n\t\t\tdetsum = detleft + detright;\n\t\t}\n\t} else if (detleft < 0.0) {\n\t\tif (detright >= 0.0) {\n\t\t\treturn CGAlgorithmsDD.signum(det);\n\t\t} else {\n\t\t\tdetsum = -detleft - detright;\n\t\t}\n\t} else {\n\t\treturn CGAlgorithmsDD.signum(det);\n\t}\n\tvar errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n\tif (det >= errbound || -det >= errbound) {\n\t\treturn CGAlgorithmsDD.signum(det);\n\t}\n\treturn 2;\n};\nCGAlgorithmsDD.signum = function (x) {\n\tif (x > 0) return 1;\n\tif (x < 0) return -1;\n\treturn 0;\n};\nCGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;\n","import extend from '../../../../extend';\nimport Cloneable from '../../../../java/lang/Cloneable';\nexport default function CoordinateSequence() {}\nextend(CoordinateSequence.prototype, {\n\tsetOrdinate: function (index, ordinateIndex, value) {},\n\tsize: function () {},\n\tgetOrdinate: function (index, ordinateIndex) {},\n\tgetCoordinate: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], coord = arguments[1];\n\t\t}\n\t},\n\tgetCoordinateCopy: function (i) {},\n\tgetDimension: function () {},\n\tgetX: function (index) {},\n\tclone: function () {},\n\texpandEnvelope: function (env) {},\n\tcopy: function () {},\n\tgetY: function (index) {},\n\ttoCoordinateArray: function () {},\n\tinterfaces_: function () {\n\t\treturn [Cloneable];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateSequence;\n\t}\n});\nCoordinateSequence.X = 0;\nCoordinateSequence.Y = 1;\nCoordinateSequence.Z = 2;\nCoordinateSequence.M = 3;\n","export default function System () { }\n\nSystem.arraycopy = (src, srcPos, dest, destPos, len) => {\n  let c = 0\n  for (let i = srcPos; i < srcPos + len; i++) {\n    dest[destPos + c] = src[i]\n    c++\n  }\n}\n\nSystem.getProperty = (name) => {\n  return {\n    'line.separator': '\\n'\n  }[name]\n}\n","import NotRepresentableException from './NotRepresentableException';\nimport Coordinate from '../geom/Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nexport default function HCoordinate() {\n\tthis.x = null;\n\tthis.y = null;\n\tthis.w = null;\n\tif (arguments.length === 0) {\n\t\tthis.x = 0.0;\n\t\tthis.y = 0.0;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 1) {\n\t\tlet p = arguments[0];\n\t\tthis.x = p.x;\n\t\tthis.y = p.y;\n\t\tthis.w = 1.0;\n\t} else if (arguments.length === 2) {\n\t\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\t\tlet _x = arguments[0], _y = arguments[1];\n\t\t\tthis.x = _x;\n\t\t\tthis.y = _y;\n\t\t\tthis.w = 1.0;\n\t\t} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.x = p1.y * p2.w - p2.y * p1.w;\n\t\t\tthis.y = p2.x * p1.w - p1.x * p2.w;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\t\tlet p1 = arguments[0], p2 = arguments[1];\n\t\t\tthis.x = p1.y - p2.y;\n\t\t\tthis.y = p2.x - p1.x;\n\t\t\tthis.w = p1.x * p2.y - p2.x * p1.y;\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tlet _x = arguments[0], _y = arguments[1], _w = arguments[2];\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t\tthis.w = _w;\n\t} else if (arguments.length === 4) {\n\t\tlet p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];\n\t\tvar px = p1.y - p2.y;\n\t\tvar py = p2.x - p1.x;\n\t\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\t\tvar qx = q1.y - q2.y;\n\t\tvar qy = q2.x - q1.x;\n\t\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\t\tthis.x = py * qw - qy * pw;\n\t\tthis.y = qx * pw - px * qw;\n\t\tthis.w = px * qy - qx * py;\n\t}\n}\nextend(HCoordinate.prototype, {\n\tgetY: function () {\n\t\tvar a = this.y / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t},\n\tgetX: function () {\n\t\tvar a = this.x / this.w;\n\t\tif (Double.isNaN(a) || Double.isInfinite(a)) {\n\t\t\tthrow new NotRepresentableException();\n\t\t}\n\t\treturn a;\n\t},\n\tgetCoordinate: function () {\n\t\tvar p = new Coordinate();\n\t\tp.x = this.getX();\n\t\tp.y = this.getY();\n\t\treturn p;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn HCoordinate;\n\t}\n});\nHCoordinate.intersection = function (p1, p2, q1, q2) {\n\tvar px = p1.y - p2.y;\n\tvar py = p2.x - p1.x;\n\tvar pw = p1.x * p2.y - p2.x * p1.y;\n\tvar qx = q1.y - q2.y;\n\tvar qy = q2.x - q1.x;\n\tvar qw = q1.x * q2.y - q2.x * q1.y;\n\tvar x = py * qw - qy * pw;\n\tvar y = qx * pw - px * qw;\n\tvar w = px * qy - qx * py;\n\tvar xInt = x / w;\n\tvar yInt = y / w;\n\tif (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {\n\t\tthrow new NotRepresentableException();\n\t}\n\treturn new Coordinate(xInt, yInt);\n};\n","import hasInterface from '../../../../hasInterface';\nimport extend from '../../../../extend';\nimport CoordinateSequence from './CoordinateSequence';\nexport default function CoordinateSequenceFactory() {}\nextend(CoordinateSequenceFactory.prototype, {\n\tcreate: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordSeq = arguments[0];\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateSequenceFactory;\n\t}\n});\n","import extend from '../../../../extend';\nexport default function GeometryComponentFilter() {}\nextend(GeometryComponentFilter.prototype, {\n\tfilter: function (geom) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryComponentFilter;\n\t}\n});\n","import Comparable from '../../../../java/lang/Comparable';\nimport Cloneable from '../../../../java/lang/Cloneable';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Serializable from '../../../../java/io/Serializable';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nimport extend from '../../../../extend';\nimport inherits from '../../../../inherits';\nexport default function Geometry() {\n\tthis.envelope = null;\n\tthis.factory = null;\n\tthis.SRID = null;\n\tthis.userData = null;\n\tlet factory = arguments[0];\n\tthis.factory = factory;\n\tthis.SRID = factory.getSRID();\n}\nextend(Geometry.prototype, {\n\tisGeometryCollection: function () {\n\t\treturn this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION;\n\t},\n\tgetFactory: function () {\n\t\treturn this.factory;\n\t},\n\tgetGeometryN: function (n) {\n\t\treturn this;\n\t},\n\tgetArea: function () {\n\t\treturn 0.0;\n\t},\n\tisRectangle: function () {\n\t\treturn false;\n\t},\n\tequals: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Geometry) {\n\t\t\t\tlet g = arguments[0];\n\t\t\t\tif (g === null) return false;\n\t\t\t\treturn this.equalsTopo(g);\n\t\t\t} else if (arguments[0] instanceof Object) {\n\t\t\t\tlet o = arguments[0];\n\t\t\t\tif (!(o instanceof Geometry)) return false;\n\t\t\t\tvar g = o;\n\t\t\t\treturn this.equalsExact(g);\n\t\t\t}\n\t\t}\n\t},\n\tequalsExact: function (other) {\n\t\treturn this === other || this.equalsExact(other, 0);\n\t},\n\tgeometryChanged: function () {\n\t\tthis.apply(Geometry.geometryChangedFilter);\n\t},\n\tgeometryChangedAction: function () {\n\t\tthis.envelope = null;\n\t},\n\tequalsNorm: function (g) {\n\t\tif (g === null) return false;\n\t\treturn this.norm().equalsExact(g.norm());\n\t},\n\tgetLength: function () {\n\t\treturn 0.0;\n\t},\n\tgetNumGeometries: function () {\n\t\treturn 1;\n\t},\n\tcompareTo: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar other = o;\n\t\t\tif (this.getSortIndex() !== other.getSortIndex()) {\n\t\t\t\treturn this.getSortIndex() - other.getSortIndex();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar other = o;\n\t\t\tif (this.getSortIndex() !== other.getSortIndex()) {\n\t\t\t\treturn this.getSortIndex() - other.getSortIndex();\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (other.isEmpty()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn this.compareToSameClass(o, comp);\n\t\t}\n\t},\n\tgetUserData: function () {\n\t\treturn this.userData;\n\t},\n\tgetSRID: function () {\n\t\treturn this.SRID;\n\t},\n\tgetEnvelope: function () {\n\t\treturn this.getFactory().toGeometry(this.getEnvelopeInternal());\n\t},\n\tcheckNotGeometryCollection: function (g) {\n\t\tif (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {\n\t\t\tthrow new IllegalArgumentException(\"This method does not support GeometryCollection arguments\");\n\t\t}\n\t},\n\tequal: function (a, b, tolerance) {\n\t\tif (tolerance === 0) {\n\t\t\treturn a.equals(b);\n\t\t}\n\t\treturn a.distance(b) <= tolerance;\n\t},\n\tnorm: function () {\n\t\tvar copy = this.copy();\n\t\tcopy.normalize();\n\t\treturn copy;\n\t},\n\tgetPrecisionModel: function () {\n\t\treturn this.factory.getPrecisionModel();\n\t},\n\tgetEnvelopeInternal: function () {\n\t\tif (this.envelope === null) {\n\t\t\tthis.envelope = this.computeEnvelopeInternal();\n\t\t}\n\t\treturn new Envelope(this.envelope);\n\t},\n\tsetSRID: function (SRID) {\n\t\tthis.SRID = SRID;\n\t},\n\tsetUserData: function (userData) {\n\t\tthis.userData = userData;\n\t},\n\tcompare: function (a, b) {\n\t\tvar i = a.iterator();\n\t\tvar j = b.iterator();\n\t\twhile (i.hasNext() && j.hasNext()) {\n\t\t\tvar aElement = i.next();\n\t\t\tvar bElement = j.next();\n\t\t\tvar comparison = aElement.compareTo(bElement);\n\t\t\tif (comparison !== 0) {\n\t\t\t\treturn comparison;\n\t\t\t}\n\t\t}\n\t\tif (i.hasNext()) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (j.hasNext()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t},\n\thashCode: function () {\n\t\treturn this.getEnvelopeInternal().hashCode();\n\t},\n\tisGeometryCollectionOrDerived: function () {\n\t\tif (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Cloneable, Comparable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn Geometry;\n\t}\n});\nGeometry.hasNonEmptyElements = function (geometries) {\n\tfor (var i = 0; i < geometries.length; i++) {\n\t\tif (!geometries[i].isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nGeometry.hasNullElements = function (array) {\n\tfor (var i = 0; i < array.length; i++) {\n\t\tif (array[i] === null) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nGeometry.serialVersionUID = 8763622679187376702;\nGeometry.SORTINDEX_POINT = 0;\nGeometry.SORTINDEX_MULTIPOINT = 1;\nGeometry.SORTINDEX_LINESTRING = 2;\nGeometry.SORTINDEX_LINEARRING = 3;\nGeometry.SORTINDEX_MULTILINESTRING = 4;\nGeometry.SORTINDEX_POLYGON = 5;\nGeometry.SORTINDEX_MULTIPOLYGON = 6;\nGeometry.SORTINDEX_GEOMETRYCOLLECTION = 7;\nGeometry.geometryChangedFilter = {\n\tinterfaces_: function () {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tfilter: function (geom) {\n\t\tgeom.geometryChangedAction();\n\t}\n};\n","import extend from '../../../../extend';\nexport default function CoordinateFilter() {}\nextend(CoordinateFilter.prototype, {\n\tfilter: function (coord) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateFilter;\n\t}\n});\n","import extend from '../../../../extend';\nexport default function BoundaryNodeRule() {}\nextend(BoundaryNodeRule.prototype, {\n\tisInBoundary: function (boundaryCount) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BoundaryNodeRule;\n\t}\n});\nfunction Mod2BoundaryNodeRule() {}\nextend(Mod2BoundaryNodeRule.prototype, {\n\tisInBoundary: function (boundaryCount) {\n\t\treturn boundaryCount % 2 === 1;\n\t},\n\tinterfaces_: function () {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function () {\n\t\treturn Mod2BoundaryNodeRule;\n\t}\n});\nfunction EndPointBoundaryNodeRule() {}\nextend(EndPointBoundaryNodeRule.prototype, {\n\tisInBoundary: function (boundaryCount) {\n\t\treturn boundaryCount > 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function () {\n\t\treturn EndPointBoundaryNodeRule;\n\t}\n});\nfunction MultiValentEndPointBoundaryNodeRule() {}\nextend(MultiValentEndPointBoundaryNodeRule.prototype, {\n\tisInBoundary: function (boundaryCount) {\n\t\treturn boundaryCount > 1;\n\t},\n\tinterfaces_: function () {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function () {\n\t\treturn MultiValentEndPointBoundaryNodeRule;\n\t}\n});\nfunction MonoValentEndPointBoundaryNodeRule() {}\nextend(MonoValentEndPointBoundaryNodeRule.prototype, {\n\tisInBoundary: function (boundaryCount) {\n\t\treturn boundaryCount === 1;\n\t},\n\tinterfaces_: function () {\n\t\treturn [BoundaryNodeRule];\n\t},\n\tgetClass: function () {\n\t\treturn MonoValentEndPointBoundaryNodeRule;\n\t}\n});\nBoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;\nBoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;\nBoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;\nBoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();\nBoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();\nBoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();\nBoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n","import CoordinateList from './CoordinateList';\nimport Coordinate from './Coordinate';\nimport extend from '../../../../extend';\nimport MathUtil from '../math/MathUtil';\nimport System from '../../../../java/lang/System';\nimport Comparator from '../../../../java/util/Comparator';\nimport Envelope from './Envelope';\nexport default function CoordinateArrays() {}\nextend(CoordinateArrays.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateArrays;\n\t}\n});\nCoordinateArrays.isRing = function (pts) {\n\tif (pts.length < 4) return false;\n\tif (!pts[0].equals2D(pts[pts.length - 1])) return false;\n\treturn true;\n};\nCoordinateArrays.ptNotInList = function (testPts, pts) {\n\tfor (var i = 0; i < testPts.length; i++) {\n\t\tvar testPt = testPts[i];\n\t\tif (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;\n\t}\n\treturn null;\n};\nCoordinateArrays.scroll = function (coordinates, firstCoordinate) {\n\tvar i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n\tif (i < 0) return null;\n\tvar newCoordinates = new Array(coordinates.length).fill(null);\n\tSystem.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n\tSystem.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n\tSystem.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n};\nCoordinateArrays.equals = function () {\n\tif (arguments.length === 2) {\n\t\tlet coord1 = arguments[0], coord2 = arguments[1];\n\t\tif (coord1 === coord2) return true;\n\t\tif (coord1 === null || coord2 === null) return false;\n\t\tif (coord1.length !== coord2.length) return false;\n\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\tif (!coord1[i].equals(coord2[i])) return false;\n\t\t}\n\t\treturn true;\n\t} else if (arguments.length === 3) {\n\t\tlet coord1 = arguments[0], coord2 = arguments[1], coordinateComparator = arguments[2];\n\t\tif (coord1 === coord2) return true;\n\t\tif (coord1 === null || coord2 === null) return false;\n\t\tif (coord1.length !== coord2.length) return false;\n\t\tfor (var i = 0; i < coord1.length; i++) {\n\t\t\tif (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\nCoordinateArrays.intersection = function (coordinates, env) {\n\tvar coordList = new CoordinateList();\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tif (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);\n\t}\n\treturn coordList.toCoordinateArray();\n};\nCoordinateArrays.hasRepeatedPoints = function (coord) {\n\tfor (var i = 1; i < coord.length; i++) {\n\t\tif (coord[i - 1].equals(coord[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nCoordinateArrays.removeRepeatedPoints = function (coord) {\n\tif (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;\n\tvar coordList = new CoordinateList(coord, false);\n\treturn coordList.toCoordinateArray();\n};\nCoordinateArrays.reverse = function (coord) {\n\tvar last = coord.length - 1;\n\tvar mid = Math.trunc(last / 2);\n\tfor (var i = 0; i <= mid; i++) {\n\t\tvar tmp = coord[i];\n\t\tcoord[i] = coord[last - i];\n\t\tcoord[last - i] = tmp;\n\t}\n};\nCoordinateArrays.removeNull = function (coord) {\n\tvar nonNull = 0;\n\tfor (var i = 0; i < coord.length; i++) {\n\t\tif (coord[i] !== null) nonNull++;\n\t}\n\tvar newCoord = new Array(nonNull).fill(null);\n\tif (nonNull === 0) return newCoord;\n\tvar j = 0;\n\tfor (var i = 0; i < coord.length; i++) {\n\t\tif (coord[i] !== null) newCoord[j++] = coord[i];\n\t}\n\treturn newCoord;\n};\nCoordinateArrays.copyDeep = function () {\n\tif (arguments.length === 1) {\n\t\tlet coordinates = arguments[0];\n\t\tvar copy = new Array(coordinates.length).fill(null);\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tcopy[i] = new Coordinate(coordinates[i]);\n\t\t}\n\t\treturn copy;\n\t} else if (arguments.length === 5) {\n\t\tlet src = arguments[0], srcStart = arguments[1], dest = arguments[2], destStart = arguments[3], length = arguments[4];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tdest[destStart + i] = new Coordinate(src[srcStart + i]);\n\t\t}\n\t}\n};\nCoordinateArrays.isEqualReversed = function (pts1, pts2) {\n\tfor (var i = 0; i < pts1.length; i++) {\n\t\tvar p1 = pts1[i];\n\t\tvar p2 = pts2[pts1.length - i - 1];\n\t\tif (p1.compareTo(p2) !== 0) return false;\n\t}\n\treturn true;\n};\nCoordinateArrays.envelope = function (coordinates) {\n\tvar env = new Envelope();\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tenv.expandToInclude(coordinates[i]);\n\t}\n\treturn env;\n};\nCoordinateArrays.toCoordinateArray = function (coordList) {\n\treturn coordList.toArray(CoordinateArrays.coordArrayType);\n};\nCoordinateArrays.atLeastNCoordinatesOrNothing = function (n, c) {\n\treturn c.length >= n ? c : [];\n};\nCoordinateArrays.indexOf = function (coordinate, coordinates) {\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tif (coordinate.equals(coordinates[i])) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nCoordinateArrays.increasingDirection = function (pts) {\n\tfor (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n\t\tvar j = pts.length - 1 - i;\n\t\tvar comp = pts[i].compareTo(pts[j]);\n\t\tif (comp !== 0) return comp;\n\t}\n\treturn 1;\n};\nCoordinateArrays.compare = function (pts1, pts2) {\n\tvar i = 0;\n\twhile (i < pts1.length && i < pts2.length) {\n\t\tvar compare = pts1[i].compareTo(pts2[i]);\n\t\tif (compare !== 0) return compare;\n\t\ti++;\n\t}\n\tif (i < pts2.length) return -1;\n\tif (i < pts1.length) return 1;\n\treturn 0;\n};\nCoordinateArrays.minCoordinate = function (coordinates) {\n\tvar minCoord = null;\n\tfor (var i = 0; i < coordinates.length; i++) {\n\t\tif (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n\t\t\tminCoord = coordinates[i];\n\t\t}\n\t}\n\treturn minCoord;\n};\nCoordinateArrays.extract = function (pts, start, end) {\n\tstart = MathUtil.clamp(start, 0, pts.length);\n\tend = MathUtil.clamp(end, -1, pts.length);\n\tvar npts = end - start + 1;\n\tif (end < 0) npts = 0;\n\tif (start >= pts.length) npts = 0;\n\tif (end < start) npts = 0;\n\tvar extractPts = new Array(npts).fill(null);\n\tif (npts === 0) return extractPts;\n\tvar iPts = 0;\n\tfor (var i = start; i <= end; i++) {\n\t\textractPts[iPts++] = pts[i];\n\t}\n\treturn extractPts;\n};\nfunction ForwardComparator() {}\nextend(ForwardComparator.prototype, {\n\tcompare: function (o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\treturn CoordinateArrays.compare(pts1, pts2);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function () {\n\t\treturn ForwardComparator;\n\t}\n});\nfunction BidirectionalComparator() {}\nextend(BidirectionalComparator.prototype, {\n\tcompare: function (o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar forwardComp = CoordinateArrays.compare(pts1, pts2);\n\t\tvar isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n\t\tif (isEqualRev) return 0;\n\t\treturn forwardComp;\n\t},\n\tOLDcompare: function (o1, o2) {\n\t\tvar pts1 = o1;\n\t\tvar pts2 = o2;\n\t\tif (pts1.length < pts2.length) return -1;\n\t\tif (pts1.length > pts2.length) return 1;\n\t\tif (pts1.length === 0) return 0;\n\t\tvar dir1 = CoordinateArrays.increasingDirection(pts1);\n\t\tvar dir2 = CoordinateArrays.increasingDirection(pts2);\n\t\tvar i1 = dir1 > 0 ? 0 : pts1.length - 1;\n\t\tvar i2 = dir2 > 0 ? 0 : pts1.length - 1;\n\t\tfor (var i = 0; i < pts1.length; i++) {\n\t\t\tvar comparePt = pts1[i1].compareTo(pts2[i2]);\n\t\t\tif (comparePt !== 0) return comparePt;\n\t\t\ti1 += dir1;\n\t\t\ti2 += dir2;\n\t\t}\n\t\treturn 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function () {\n\t\treturn BidirectionalComparator;\n\t}\n});\nCoordinateArrays.ForwardComparator = ForwardComparator;\nCoordinateArrays.BidirectionalComparator = BidirectionalComparator;\nCoordinateArrays.coordArrayType = new Array(0).fill(null);\n","/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n *\n * @constructor\n * @private\n */\nexport default function Map() {};\n\n\n/**\n * Returns the value to which the specified key is mapped, or null if this map\n * contains no mapping for the key.\n * @param {Object} key\n * @return {Object}\n */\nMap.prototype.get = function() {};\n\n\n/**\n * Associates the specified value with the specified key in this map (optional\n * operation).\n * @param {Object} key\n * @param {Object} value\n * @return {Object}\n */\nMap.prototype.put = function() {};\n\n\n/**\n * Returns the number of key-value mappings in this map.\n * @return {number}\n */\nMap.prototype.size = function() {};\n\n\n/**\n * Returns a Collection view of the values contained in this map.\n * @return {javascript.util.Collection}\n */\nMap.prototype.values = function() {};\n\n/**\n * Returns a {@link Set} view of the mappings contained in this map.\n * The set is backed by the map, so changes to the map are\n * reflected in the set, and vice-versa.  If the map is modified\n * while an iteration over the set is in progress (except through\n * the iterator's own <tt>remove</tt> operation, or through the\n * <tt>setValue</tt> operation on a map entry returned by the\n * iterator) the results of the iteration are undefined.  The set\n * supports element removal, which removes the corresponding\n * mapping from the map, via the <tt>Iterator.remove</tt>,\n * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n * <tt>clear</tt> operations.  It does not support the\n * <tt>add</tt> or <tt>addAll</tt> operations.\n *\n * @return {Set} a set view of the mappings contained in this map\n */\nMap.prototype.entrySet = function() {};\n","import Map from './Map'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n *\n * @extends {Map}\n * @constructor\n * @private\n */\nexport default function SortedMap() {};\nSortedMap.prototype = new Map();\n","import Collection from './Collection'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */\nexport default function Set() {};\nSet.prototype = new Collection();\n\n\n/**\n * Returns true if this set contains the specified element. More formally,\n * returns true if and only if this set contains an element e such that (o==null ?\n * e==null : o.equals(e)).\n * @param {Object} e\n * @return {boolean}\n */\nSet.prototype.contains = function() {};\n","import Collection from './Collection'\nimport Iterator from './Iterator'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\nimport Set from './Set'\n\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n *\n * @extends {javascript.util.Set}\n * @constructor\n * @private\n */\nexport default function HashSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nHashSet.prototype = new Set();\n\n\n/**\n * @override\n */\nHashSet.prototype.contains = function(o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e === o) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.add = function(o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.remove = function(o) {\n  throw new javascript.util.OperationNotSupported();\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nHashSet.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n\n/**\n * @extends {Iterator}\n * @param {HashSet} hashSet\n * @constructor\n * @private\n */\nvar Iterator_ = function(hashSet) {\n  /**\n   * @type {HashSet}\n   * @private\n   */\n  this.hashSet_ = hashSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.hashSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.hashSet_.array_[this.position_++];\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.hashSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  throw new OperationNotSupported();\n};\n","import ArrayList from './ArrayList'\nimport SortedMap from './SortedMap'\nimport HashSet from './HashSet'\n\nconst BLACK = 0\nconst RED = 1\nfunction colorOf (p) { return (p == null ? BLACK : p.color) }\nfunction parentOf (p) { return (p == null ? null : p.parent) }\nfunction setColor (p, c) { if (p !== null) p.color = c }\nfunction leftOf (p) { return (p == null ? null : p.left) }\nfunction rightOf (p) { return (p == null ? null : p.right) }\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n *\n * @extends {SortedMap}\n * @constructor\n * @private\n */\nexport default function TreeMap() {\n  /**\n   * @type {Object}\n   * @private\n   */\n  this.root_ = null;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.size_ = 0;\n};\nTreeMap.prototype = new SortedMap();\n\n\n/**\n * @override\n */\nTreeMap.prototype.get = function(key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) {\n      p = p.left;\n    } else if (cmp > 0) {\n      p = p.right;\n    } else {\n      return p.value;\n    }\n  }\n  return null;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.put = function(key, value) {\n  if (this.root_ === null) {\n    this.root_ = {\n      key: key,\n      value: value,\n      left: null,\n      right: null,\n      parent: null,\n      color: BLACK,\n      getValue() { return this.value },\n      getKey() { return this.key }\n    };\n    this.size_ = 1;\n    return null;\n  }\n  var t = this.root_, parent, cmp;\n  do {\n    parent = t;\n    cmp = key['compareTo'](t.key);\n    if (cmp < 0) {\n      t = t.left;\n    } else if (cmp > 0) {\n      t = t.right;\n    } else {\n      var oldValue = t.value;\n      t.value = value;\n      return oldValue;\n    }\n  } while (t !== null);\n  var e = {\n    key: key,\n    left: null,\n    right: null,\n    value: value,\n    parent: parent,\n    color: BLACK,\n    getValue() { return this.value },\n    getKey() { return this.key }\n  };\n  if (cmp < 0) {\n    parent.left = e;\n  } else {\n    parent.right = e;\n  }\n  this.fixAfterInsertion(e);\n  this.size_++;\n  return null;\n};\n\n\n/**\n * @param {Object} x\n */\nTreeMap.prototype.fixAfterInsertion = function(x) {\n  x.color = RED;\n  while (x != null && x != this.root_ && x.parent.color == RED) {\n    if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n      var y = rightOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == rightOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateLeft(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateRight(parentOf(parentOf(x)));\n      }\n    } else {\n      var y = leftOf(parentOf(parentOf(x)));\n      if (colorOf(y) == RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x == leftOf(parentOf(x))) {\n          x = parentOf(x);\n          this.rotateRight(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this.rotateLeft(parentOf(parentOf(x)));\n      }\n    }\n  }\n  this.root_.color = BLACK;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.values = function() {\n  var arrayList = new ArrayList();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    arrayList.add(p.value);\n    while ((p = TreeMap.successor(p)) !== null) {\n      arrayList.add(p.value);\n    }\n  }\n  return arrayList;\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.entrySet = function() {\n  var hashSet = new HashSet();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    hashSet.add(p);\n    while ((p = TreeMap.successor(p)) !== null) {\n      hashSet.add(p);\n    }\n  }\n  return hashSet;\n};\n\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateLeft = function(p) {\n  if (p != null) {\n    var r = p.right;\n    p.right = r.left;\n    if (r.left != null)\n      r.left.parent = p;\n    r.parent = p.parent;\n    if (p.parent == null)\n      this.root_ = r;\n    else if (p.parent.left == p)\n      p.parent.left = r;\n    else\n      p.parent.right = r;\n    r.left = p;\n    p.parent = r;\n  }\n};\n\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateRight = function(p) {\n  if (p != null) {\n    var l = p.left;\n    p.left = l.right;\n    if (l.right != null) l.right.parent = p;\n    l.parent = p.parent;\n    if (p.parent == null)\n      this.root_ = l;\n    else if (p.parent.right == p)\n      p.parent.right = l;\n    else p.parent.left = l;\n    l.right = p;\n    p.parent = l;\n  }\n};\n\n\n/**\n * @return {Object}\n */\nTreeMap.prototype.getFirstEntry = function() {\n  var p = this.root_;\n  if (p != null) {\n    while (p.left != null) {\n      p = p.left;\n    }\n  }\n  return p;\n};\n\n\n/**\n * @param {Object} t\n * @return {Object}\n * @private\n */\nTreeMap.successor = function(t) {\n  if (t === null)\n    return null;\n  else if (t.right !== null) {\n    var p = t.right;\n    while (p.left !== null) {\n      p = p.left;\n    }\n    return p;\n  } else {\n    var p = t.parent;\n    var ch = t;\n    while (p !== null && ch === p.right) {\n      ch = p;\n      p = p.parent;\n    }\n    return p;\n  }\n};\n\n\n/**\n * @override\n */\nTreeMap.prototype.size = function() {\n  return this.size_;\n};\n","import extend from '../../../../extend';\nexport default function Lineal() {}\nextend(Lineal.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Lineal;\n\t}\n});\n","import Set from './Set'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n *\n * @extends {Set}\n * @constructor\n * @private\n */\nexport default function SortedSet() {};\nSortedSet.prototype = new Set();\n","import Collection from './Collection'\nimport Iterator from './Iterator'\nimport NoSuchElementException from './NoSuchElementException'\nimport OperationNotSupported from './OperationNotSupported'\nimport SortedSet from './SortedSet'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n *\n * @extends {SortedSet}\n * @constructor\n * @private\n */\nexport default function TreeSet() {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n};\nTreeSet.prototype = new SortedSet();\n\n\n/**\n * @override\n */\nTreeSet.prototype.contains = function(o) {\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.add = function(o) {\n  if (this.contains(o)) {\n    return false;\n  }\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this.array_[i];\n    if (e['compareTo'](o) === 1) {\n      this.array_.splice(i, 0, o);\n      return true;\n    }\n  }\n\n  this.array_.push(o);\n\n  return true;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.addAll = function(c) {\n  for (var i = c.iterator(); i.hasNext();) {\n    this.add(i.next());\n  }\n  return true;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.remove = function(e) {\n  throw new OperationNotSupported();\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.isEmpty = function() {\n  return this.array_.length === 0;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n\n\n/**\n * @override\n */\nTreeSet.prototype.iterator = function() {\n  return new Iterator_(this);\n};\n\n\n\n/**\n * @extends {javascript.util.Iterator}\n * @param {javascript.util.TreeSet} treeSet\n * @constructor\n * @private\n */\nvar Iterator_ = function(treeSet) {\n  /**\n   * @type {javascript.util.TreeSet}\n   * @private\n   */\n  this.treeSet_ = treeSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.next = function() {\n  if (this.position_ === this.treeSet_.size()) {\n    throw new NoSuchElementException();\n  }\n  return this.treeSet_.array_[this.position_++];\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.hasNext = function() {\n  if (this.position_ < this.treeSet_.size()) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @override\n */\nIterator_.prototype.remove = function() {\n  throw new OperationNotSupported();\n};\n","import ArrayList from './ArrayList'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n *\n * @constructor\n * @private\n */\nexport default function Arrays() {};\n\n/**\n */\nArrays.sort = function() {\n  var a = arguments[0], i, t, comparator, compare;\n  if (arguments.length === 1) {\n    compare = function(a, b) {\n      return a.compareTo(b);\n    }\n    a.sort(compare);\n    return;\n  } else if (arguments.length === 2) {\n    comparator = arguments[1];\n    compare = function(a, b) {\n      return comparator['compare'](a, b);\n    };\n    a.sort(compare);\n  } else if (arguments.length === 3) {\n    t = a.slice(arguments[1], arguments[2]);\n    t.sort();\n    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  } else if (arguments.length === 4) {\n    t = a.slice(arguments[1], arguments[2]);\n    comparator = arguments[3];\n    compare = function(a, b) {\n      return comparator['compare'](a, b);\n    };\n    t.sort(compare);\n    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n    return;\n  }\n};\n\n\n/**\n * @param {Array} array\n * @return {ArrayList}\n */\nArrays.asList = function(array) {\n  var arrayList = new ArrayList();\n  for (var i = 0, len = array.length; i < len; i++) {\n    arrayList.add(array[i]);\n  }\n  return arrayList;\n};\n","import IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport Character from '../../../../java/lang/Character';\nexport default function Dimension() {}\nextend(Dimension.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Dimension;\n\t}\n});\nDimension.toDimensionSymbol = function (dimensionValue) {\n\tswitch (dimensionValue) {\n\t\tcase Dimension.FALSE:\n\t\t\treturn Dimension.SYM_FALSE;\n\t\tcase Dimension.TRUE:\n\t\t\treturn Dimension.SYM_TRUE;\n\t\tcase Dimension.DONTCARE:\n\t\t\treturn Dimension.SYM_DONTCARE;\n\t\tcase Dimension.P:\n\t\t\treturn Dimension.SYM_P;\n\t\tcase Dimension.L:\n\t\t\treturn Dimension.SYM_L;\n\t\tcase Dimension.A:\n\t\t\treturn Dimension.SYM_A;\n\t}\n\tthrow new IllegalArgumentException(\"Unknown dimension value: \" + dimensionValue);\n};\nDimension.toDimensionValue = function (dimensionSymbol) {\n\tswitch (Character.toUpperCase(dimensionSymbol)) {\n\t\tcase Dimension.SYM_FALSE:\n\t\t\treturn Dimension.FALSE;\n\t\tcase Dimension.SYM_TRUE:\n\t\t\treturn Dimension.TRUE;\n\t\tcase Dimension.SYM_DONTCARE:\n\t\t\treturn Dimension.DONTCARE;\n\t\tcase Dimension.SYM_P:\n\t\t\treturn Dimension.P;\n\t\tcase Dimension.SYM_L:\n\t\t\treturn Dimension.L;\n\t\tcase Dimension.SYM_A:\n\t\t\treturn Dimension.A;\n\t}\n\tthrow new IllegalArgumentException(\"Unknown dimension symbol: \" + dimensionSymbol);\n};\nDimension.P = 0;\nDimension.L = 1;\nDimension.A = 2;\nDimension.FALSE = -1;\nDimension.TRUE = -2;\nDimension.DONTCARE = -3;\nDimension.SYM_FALSE = 'F';\nDimension.SYM_TRUE = 'T';\nDimension.SYM_DONTCARE = '*';\nDimension.SYM_P = '0';\nDimension.SYM_L = '1';\nDimension.SYM_A = '2';\n","import extend from '../../../../extend';\nexport default function GeometryFilter() {}\nextend(GeometryFilter.prototype, {\n\tfilter: function (geom) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryFilter;\n\t}\n});\n","import extend from '../../../../extend';\nexport default function CoordinateSequenceFilter() {}\nextend(CoordinateSequenceFilter.prototype, {\n\tfilter: function (seq, i) {},\n\tisDone: function () {},\n\tisGeometryChanged: function () {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateSequenceFilter;\n\t}\n});\n","import TreeSet from '../../../../java/util/TreeSet';\nimport Geometry from './Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nimport inherits from '../../../../inherits';\nexport default function GeometryCollection() {\n\tthis.geometries = null;\n\tlet geometries = arguments[0], factory = arguments[1];\n\tGeometry.call(this, factory);\n\tif (geometries === null) {\n\t\tgeometries = [];\n\t}\n\tif (Geometry.hasNullElements(geometries)) {\n\t\tthrow new IllegalArgumentException(\"geometries must not contain null elements\");\n\t}\n\tthis.geometries = geometries;\n}\ninherits(GeometryCollection, Geometry);\nextend(GeometryCollection.prototype, {\n\tcomputeEnvelopeInternal: function () {\n\t\tvar envelope = new Envelope();\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tenvelope.expandToInclude(this.geometries[i].getEnvelopeInternal());\n\t\t}\n\t\treturn envelope;\n\t},\n\tgetGeometryN: function (n) {\n\t\treturn this.geometries[n];\n\t},\n\tgetSortIndex: function () {\n\t\treturn Geometry.SORTINDEX_GEOMETRYCOLLECTION;\n\t},\n\tgetCoordinates: function () {\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tvar childCoordinates = this.geometries[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t},\n\tgetArea: function () {\n\t\tvar area = 0.0;\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tarea += this.geometries[i].getArea();\n\t\t}\n\t\treturn area;\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherCollection = other;\n\t\t\tif (this.geometries.length !== otherCollection.geometries.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\t\tif (!this.geometries[i].equalsExact(otherCollection.geometries[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function () {\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tthis.geometries[i].normalize();\n\t\t}\n\t\tArrays.sort(this.geometries);\n\t},\n\tgetCoordinate: function () {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this.geometries[0].getCoordinate();\n\t},\n\tgetBoundaryDimension: function () {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this.geometries[i].getBoundaryDimension());\n\t\t}\n\t\treturn dimension;\n\t},\n\tgetDimension: function () {\n\t\tvar dimension = Dimension.FALSE;\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tdimension = Math.max(dimension, this.geometries[i].getDimension());\n\t\t}\n\t\treturn dimension;\n\t},\n\tgetLength: function () {\n\t\tvar sum = 0.0;\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tsum += this.geometries[i].getLength();\n\t\t}\n\t\treturn sum;\n\t},\n\tgetNumPoints: function () {\n\t\tvar numPoints = 0;\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tnumPoints += this.geometries[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t},\n\tgetNumGeometries: function () {\n\t\treturn this.geometries.length;\n\t},\n\treverse: function () {\n\t\tvar n = this.geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\trevGeoms[i] = this.geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createGeometryCollection(revGeoms);\n\t},\n\tcompareToSameClass: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar theseElements = new TreeSet(Arrays.asList(this.geometries));\n\t\t\tvar otherElements = new TreeSet(Arrays.asList(o.geometries));\n\t\t\treturn this.compare(theseElements, otherElements);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar gc = o;\n\t\t\tvar n1 = this.getNumGeometries();\n\t\t\tvar n2 = gc.getNumGeometries();\n\t\t\tvar i = 0;\n\t\t\twhile (i < n1 && i < n2) {\n\t\t\t\tvar thisGeom = this.getGeometryN(i);\n\t\t\t\tvar otherGeom = gc.getGeometryN(i);\n\t\t\t\tvar holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < n1) return 1;\n\t\t\tif (i < n2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t},\n\tapply: function () {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\t\tthis.geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.geometries.length === 0) return null;\n\t\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\t\tthis.geometries[i].apply(filter);\n\t\t\t\tif (filter.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\t\tthis.geometries[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\t\tthis.geometries[i].apply(filter);\n\t\t\t}\n\t\t}\n\t},\n\tgetBoundary: function () {\n\t\tthis.checkNotGeometryCollection(this);\n\t\tAssert.shouldNeverReachHere();\n\t\treturn null;\n\t},\n\tclone: function () {\n\t\tvar gc = Geometry.prototype.clone.call(this);\n\t\tgc.geometries = new Array(this.geometries.length).fill(null);\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tgc.geometries[i] = this.geometries[i].clone();\n\t\t}\n\t\treturn gc;\n\t},\n\tgetGeometryType: function () {\n\t\treturn \"GeometryCollection\";\n\t},\n\tcopy: function () {\n\t\tvar geometries = new Array(this.geometries.length).fill(null);\n\t\tfor (var i = 0; i < geometries.length; i++) {\n\t\t\tgeometries[i] = this.geometries[i].copy();\n\t\t}\n\t\treturn new GeometryCollection(geometries, this.factory);\n\t},\n\tisEmpty: function () {\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tif (!this.geometries[i].isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryCollection;\n\t}\n});\nGeometryCollection.serialVersionUID = -5694727726395021467;\n","import Geometry from './Geometry';\nimport BoundaryOp from '../operation/BoundaryOp';\nimport extend from '../../../../extend';\nimport Lineal from './Lineal';\nimport GeometryCollection from './GeometryCollection';\nimport Dimension from './Dimension';\nimport inherits from '../../../../inherits';\nexport default function MultiLineString() {\n\tlet lineStrings = arguments[0], factory = arguments[1];\n\tGeometryCollection.call(this, lineStrings, factory);\n}\ninherits(MultiLineString, GeometryCollection);\nextend(MultiLineString.prototype, {\n\tgetSortIndex: function () {\n\t\treturn Geometry.SORTINDEX_MULTILINESTRING;\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n\t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n\t},\n\tgetBoundaryDimension: function () {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t},\n\tisClosed: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tif (!this.geometries[i].isClosed()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tgetDimension: function () {\n\t\treturn 1;\n\t},\n\treverse: function () {\n\t\tvar nLines = this.geometries.length;\n\t\tvar revLines = new Array(nLines).fill(null);\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\trevLines[nLines - 1 - i] = this.geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiLineString(revLines);\n\t},\n\tgetBoundary: function () {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t},\n\tgetGeometryType: function () {\n\t\treturn \"MultiLineString\";\n\t},\n\tcopy: function () {\n\t\tvar lineStrings = new Array(this.geometries.length).fill(null);\n\t\tfor (var i = 0; i < lineStrings.length; i++) {\n\t\t\tlineStrings[i] = this.geometries[i].copy();\n\t\t}\n\t\treturn new MultiLineString(lineStrings, this.factory);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Lineal];\n\t},\n\tgetClass: function () {\n\t\treturn MultiLineString;\n\t}\n});\nMultiLineString.serialVersionUID = 8166665132445433741;\n","import LineString from '../geom/LineString';\nimport BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport extend from '../../../../extend';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nimport MultiLineString from '../geom/MultiLineString';\nexport default function BoundaryOp() {\n\tthis.geom = null;\n\tthis.geomFact = null;\n\tthis.bnRule = null;\n\tthis.endpointMap = null;\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\tBoundaryOp.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);\n\t} else if (arguments.length === 2) {\n\t\tlet geom = arguments[0], bnRule = arguments[1];\n\t\tthis.geom = geom;\n\t\tthis.geomFact = geom.getFactory();\n\t\tthis.bnRule = bnRule;\n\t}\n}\nextend(BoundaryOp.prototype, {\n\tboundaryMultiLineString: function (mLine) {\n\t\tif (this.geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tvar bdyPts = this.computeBoundaryCoordinates(mLine);\n\t\tif (bdyPts.length === 1) {\n\t\t\treturn this.geomFact.createPoint(bdyPts[0]);\n\t\t}\n\t\treturn this.geomFact.createMultiPointFromCoords(bdyPts);\n\t},\n\tgetBoundary: function () {\n\t\tif (this.geom instanceof LineString) return this.boundaryLineString(this.geom);\n\t\tif (this.geom instanceof MultiLineString) return this.boundaryMultiLineString(this.geom);\n\t\treturn this.geom.getBoundary();\n\t},\n\tboundaryLineString: function (line) {\n\t\tif (this.geom.isEmpty()) {\n\t\t\treturn this.getEmptyMultiPoint();\n\t\t}\n\t\tif (line.isClosed()) {\n\t\t\tvar closedEndpointOnBoundary = this.bnRule.isInBoundary(2);\n\t\t\tif (closedEndpointOnBoundary) {\n\t\t\t\treturn line.getStartPoint();\n\t\t\t} else {\n\t\t\t\treturn this.geomFact.createMultiPoint();\n\t\t\t}\n\t\t}\n\t\treturn this.geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);\n\t},\n\tgetEmptyMultiPoint: function () {\n\t\treturn this.geomFact.createMultiPoint();\n\t},\n\tcomputeBoundaryCoordinates: function (mLine) {\n\t\tvar bdyPts = new ArrayList();\n\t\tthis.endpointMap = new TreeMap();\n\t\tfor (var i = 0; i < mLine.getNumGeometries(); i++) {\n\t\t\tvar line = mLine.getGeometryN(i);\n\t\t\tif (line.getNumPoints() === 0) continue;\n\t\t\tthis.addEndpoint(line.getCoordinateN(0));\n\t\t\tthis.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n\t\t}\n\t\tfor (var it = this.endpointMap.entrySet().iterator(); it.hasNext(); ) {\n\t\t\tvar entry = it.next();\n\t\t\tvar counter = entry.getValue();\n\t\t\tvar valence = counter.count;\n\t\t\tif (this.bnRule.isInBoundary(valence)) {\n\t\t\t\tbdyPts.add(entry.getKey());\n\t\t\t}\n\t\t}\n\t\treturn CoordinateArrays.toCoordinateArray(bdyPts);\n\t},\n\taddEndpoint: function (pt) {\n\t\tvar counter = this.endpointMap.get(pt);\n\t\tif (counter === null) {\n\t\t\tcounter = new Counter();\n\t\t\tthis.endpointMap.put(pt, counter);\n\t\t}\n\t\tcounter.count++;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BoundaryOp;\n\t}\n});\nBoundaryOp.getBoundary = function () {\n\tif (arguments.length === 1) {\n\t\tlet g = arguments[0];\n\t\tvar bop = new BoundaryOp(g);\n\t\treturn bop.getBoundary();\n\t} else if (arguments.length === 2) {\n\t\tlet g = arguments[0], bnRule = arguments[1];\n\t\tvar bop = new BoundaryOp(g, bnRule);\n\t\treturn bop.getBoundary();\n\t}\n};\nfunction Counter() {\n\tthis.count = null;\n}\nextend(Counter.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Counter;\n\t}\n});\n","export default function PrintStream () {}\n","export default function StringReader () {}\n","export default function DecimalFormat () {}\n","export default function ByteArrayOutputStream () {}\n","export default function IOException () {}\n","export default function LineNumberReader () {}\n","import PrintStream from '../../../../java/io/PrintStream';\nimport StringReader from '../../../../java/io/StringReader';\nimport DecimalFormat from '../../../../java/text/DecimalFormat';\nimport extend from '../../../../extend';\nimport System from '../../../../java/lang/System';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport ByteArrayOutputStream from '../../../../java/io/ByteArrayOutputStream';\nimport Assert from './Assert';\nimport IOException from '../../../../java/io/IOException';\nimport LineNumberReader from '../../../../java/io/LineNumberReader';\nexport default function StringUtil() {}\nextend(StringUtil.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn StringUtil;\n\t}\n});\nStringUtil.chars = function (c, n) {\n\tvar ch = new Array(n).fill(null);\n\tfor (var i = 0; i < n; i++) {\n\t\tch[i] = c;\n\t}\n\treturn new String(ch);\n};\nStringUtil.getStackTrace = function () {\n\tif (arguments.length === 1) {\n\t\tlet t = arguments[0];\n\t\tvar os = new ByteArrayOutputStream();\n\t\tvar ps = new PrintStream(os);\n\t\tt.printStackTrace(ps);\n\t\treturn os.toString();\n\t} else if (arguments.length === 2) {\n\t\tlet t = arguments[0], depth = arguments[1];\n\t\tvar stackTrace = \"\";\n\t\tvar stringReader = new StringReader(StringUtil.getStackTrace(t));\n\t\tvar lineNumberReader = new LineNumberReader(stringReader);\n\t\tfor (var i = 0; i < depth; i++) {\n\t\t\ttry {\n\t\t\t\tstackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n\t\t\t} catch (e) {\n\t\t\t\tif (e instanceof IOException) {\n\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t} else throw e;\n\t\t\t} finally {}\n\t\t}\n\t\treturn stackTrace;\n\t}\n};\nStringUtil.split = function (s, separator) {\n\tvar separatorlen = separator.length;\n\tvar tokenList = new ArrayList();\n\tvar tmpString = \"\" + s;\n\tvar pos = tmpString.indexOf(separator);\n\twhile (pos >= 0) {\n\t\tvar token = tmpString.substring(0, pos);\n\t\ttokenList.add(token);\n\t\ttmpString = tmpString.substring(pos + separatorlen);\n\t\tpos = tmpString.indexOf(separator);\n\t}\n\tif (tmpString.length > 0) tokenList.add(tmpString);\n\tvar res = new Array(tokenList.size()).fill(null);\n\tfor (var i = 0; i < res.length; i++) {\n\t\tres[i] = tokenList.get(i);\n\t}\n\treturn res;\n};\nStringUtil.toString = function () {\n\tif (arguments.length === 1) {\n\t\tlet d = arguments[0];\n\t\treturn StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);\n\t}\n};\nStringUtil.spaces = function (n) {\n\treturn StringUtil.chars(' ', n);\n};\nStringUtil.NEWLINE = System.getProperty(\"line.separator\");\nStringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat(\"0.#\");\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport StringUtil from '../util/StringUtil';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport CoordinateSequence from './CoordinateSequence';\nexport default function CoordinateSequences() {}\nextend(CoordinateSequences.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateSequences;\n\t}\n});\nCoordinateSequences.copyCoord = function (src, srcPos, dest, destPos) {\n\tvar minDim = Math.min(src.getDimension(), dest.getDimension());\n\tfor (var dim = 0; dim < minDim; dim++) {\n\t\tdest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n\t}\n};\nCoordinateSequences.isRing = function (seq) {\n\tvar n = seq.size();\n\tif (n === 0) return true;\n\tif (n <= 3) return false;\n\treturn seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n};\nCoordinateSequences.isEqual = function (cs1, cs2) {\n\tvar cs1Size = cs1.size();\n\tvar cs2Size = cs2.size();\n\tif (cs1Size !== cs2Size) return false;\n\tvar dim = Math.min(cs1.getDimension(), cs2.getDimension());\n\tfor (var i = 0; i < cs1Size; i++) {\n\t\tfor (var d = 0; d < dim; d++) {\n\t\t\tvar v1 = cs1.getOrdinate(i, d);\n\t\t\tvar v2 = cs2.getOrdinate(i, d);\n\t\t\tif (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;\n\t\t\tif (Double.isNaN(v1) && Double.isNaN(v2)) continue;\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\nCoordinateSequences.extend = function (fact, seq, size) {\n\tvar newseq = fact.create(size, seq.getDimension());\n\tvar n = seq.size();\n\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\tif (n > 0) {\n\t\tfor (var i = n; i < size; i++) CoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n\t}\n\treturn newseq;\n};\nCoordinateSequences.reverse = function (seq) {\n\tvar last = seq.size() - 1;\n\tvar mid = Math.trunc(last / 2);\n\tfor (var i = 0; i <= mid; i++) {\n\t\tCoordinateSequences.swap(seq, i, last - i);\n\t}\n};\nCoordinateSequences.swap = function (seq, i, j) {\n\tif (i === j) return null;\n\tfor (var dim = 0; dim < seq.getDimension(); dim++) {\n\t\tvar tmp = seq.getOrdinate(i, dim);\n\t\tseq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n\t\tseq.setOrdinate(j, dim, tmp);\n\t}\n};\nCoordinateSequences.copy = function (src, srcPos, dest, destPos, length) {\n\tfor (var i = 0; i < length; i++) {\n\t\tCoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n\t}\n};\nCoordinateSequences.toString = function () {\n\tif (arguments.length === 1) {\n\t\tlet cs = arguments[0];\n\t\tvar size = cs.size();\n\t\tif (size === 0) return \"()\";\n\t\tvar dim = cs.getDimension();\n\t\tvar buf = new StringBuffer();\n\t\tbuf.append('(');\n\t\tfor (var i = 0; i < size; i++) {\n\t\t\tif (i > 0) buf.append(\" \");\n\t\t\tfor (var d = 0; d < dim; d++) {\n\t\t\t\tif (d > 0) buf.append(\",\");\n\t\t\t\tbuf.append(StringUtil.toString(cs.getOrdinate(i, d)));\n\t\t\t}\n\t\t}\n\t\tbuf.append(')');\n\t\treturn buf.toString();\n\t}\n};\nCoordinateSequences.ensureValidRing = function (fact, seq) {\n\tvar n = seq.size();\n\tif (n === 0) return seq;\n\tif (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);\n\tvar isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n\tif (isClosed) return seq;\n\treturn CoordinateSequences.createClosedRing(fact, seq, n + 1);\n};\nCoordinateSequences.createClosedRing = function (fact, seq, size) {\n\tvar newseq = fact.create(size, seq.getDimension());\n\tvar n = seq.size();\n\tCoordinateSequences.copy(seq, 0, newseq, 0, n);\n\tfor (var i = n; i < size; i++) CoordinateSequences.copy(seq, 0, newseq, i, 1);\n\treturn newseq;\n};\n","import CGAlgorithms from '../algorithm/CGAlgorithms';\nimport Geometry from './Geometry';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport BoundaryOp from '../operation/BoundaryOp';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport Lineal from './Lineal';\nimport CoordinateSequences from './CoordinateSequences';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Envelope from './Envelope';\nimport inherits from '../../../../inherits';\nexport default function LineString() {\n\tthis.points = null;\n\tlet points = arguments[0], factory = arguments[1];\n\tGeometry.call(this, factory);\n\tthis.init(points);\n}\ninherits(LineString, Geometry);\nextend(LineString.prototype, {\n\tcomputeEnvelopeInternal: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\treturn this.points.expandEnvelope(new Envelope());\n\t},\n\tisRing: function () {\n\t\treturn this.isClosed() && this.isSimple();\n\t},\n\tgetSortIndex: function () {\n\t\treturn Geometry.SORTINDEX_LINESTRING;\n\t},\n\tgetCoordinates: function () {\n\t\treturn this.points.toCoordinateArray();\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherLineString = other;\n\t\t\tif (this.points.size() !== otherLineString.points.size()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this.points.size(); i++) {\n\t\t\t\tif (!this.equal(this.points.getCoordinate(i), otherLineString.points.getCoordinate(i), tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function () {\n\t\tfor (var i = 0; i < Math.trunc(this.points.size() / 2); i++) {\n\t\t\tvar j = this.points.size() - 1 - i;\n\t\t\tif (!this.points.getCoordinate(i).equals(this.points.getCoordinate(j))) {\n\t\t\t\tif (this.points.getCoordinate(i).compareTo(this.points.getCoordinate(j)) > 0) {\n\t\t\t\t\tCoordinateSequences.reverse(this.points);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function () {\n\t\tif (this.isEmpty()) return null;\n\t\treturn this.points.getCoordinate(0);\n\t},\n\tgetBoundaryDimension: function () {\n\t\tif (this.isClosed()) {\n\t\t\treturn Dimension.FALSE;\n\t\t}\n\t\treturn 0;\n\t},\n\tisClosed: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n\t},\n\tgetEndPoint: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(this.getNumPoints() - 1);\n\t},\n\tgetDimension: function () {\n\t\treturn 1;\n\t},\n\tgetLength: function () {\n\t\treturn CGAlgorithms.computeLength(this.points);\n\t},\n\tgetNumPoints: function () {\n\t\treturn this.points.size();\n\t},\n\treverse: function () {\n\t\tvar seq = this.points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar revLine = this.getFactory().createLineString(seq);\n\t\treturn revLine;\n\t},\n\tcompareToSameClass: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar line = o;\n\t\t\tvar i = 0;\n\t\t\tvar j = 0;\n\t\t\twhile (i < this.points.size() && j < line.points.size()) {\n\t\t\t\tvar comparison = this.points.getCoordinate(i).compareTo(line.points.getCoordinate(j));\n\t\t\t\tif (comparison !== 0) {\n\t\t\t\t\treturn comparison;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (i < this.points.size()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (j < line.points.size()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar line = o;\n\t\t\treturn comp.compare(this.points, line.points);\n\t\t}\n\t},\n\tapply: function () {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfor (var i = 0; i < this.points.size(); i++) {\n\t\t\t\tfilter.filter(this.points.getCoordinate(i));\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.points.size() === 0) return null;\n\t\t\tfor (var i = 0; i < this.points.size(); i++) {\n\t\t\t\tfilter.filter(this.points, i);\n\t\t\t\tif (filter.isDone()) break;\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t},\n\tgetBoundary: function () {\n\t\treturn new BoundaryOp(this).getBoundary();\n\t},\n\tisEquivalentClass: function (other) {\n\t\treturn other instanceof LineString;\n\t},\n\tclone: function () {\n\t\tvar ls = Geometry.prototype.clone.call(this);\n\t\tls.points = this.points.clone();\n\t\treturn ls;\n\t},\n\tgetCoordinateN: function (n) {\n\t\treturn this.points.getCoordinate(n);\n\t},\n\tgetGeometryType: function () {\n\t\treturn \"LineString\";\n\t},\n\tcopy: function () {\n\t\treturn new LineString(this.points.copy(), this.factory);\n\t},\n\tgetCoordinateSequence: function () {\n\t\treturn this.points;\n\t},\n\tisEmpty: function () {\n\t\treturn this.points.size() === 0;\n\t},\n\tinit: function (points) {\n\t\tif (points === null) {\n\t\t\tpoints = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tif (points.size() === 1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LineString (found \" + points.size() + \" - must be 0 or >= 2)\");\n\t\t}\n\t\tthis.points = points;\n\t},\n\tisCoordinate: function (pt) {\n\t\tfor (var i = 0; i < this.points.size(); i++) {\n\t\t\tif (this.points.getCoordinate(i).equals(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetStartPoint: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.getPointN(0);\n\t},\n\tgetPointN: function (n) {\n\t\treturn this.getFactory().createPoint(this.points.getCoordinate(n));\n\t},\n\tinterfaces_: function () {\n\t\treturn [Lineal];\n\t},\n\tgetClass: function () {\n\t\treturn LineString;\n\t}\n});\nLineString.serialVersionUID = 3110669828065365560;\n","import extend from '../../../../extend';\nexport default function Puntal() {}\nextend(Puntal.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Puntal;\n\t}\n});\n","import Geometry from './Geometry';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport extend from '../../../../extend';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport Dimension from './Dimension';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport Puntal from './Puntal';\nimport Envelope from './Envelope';\nimport Assert from '../util/Assert';\nimport inherits from '../../../../inherits';\nexport default function Point() {\n\tthis.coordinates = null;\n\tlet coordinates = arguments[0], factory = arguments[1];\n\tGeometry.call(this, factory);\n\tthis.init(coordinates);\n}\ninherits(Point, Geometry);\nextend(Point.prototype, {\n\tcomputeEnvelopeInternal: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn new Envelope();\n\t\t}\n\t\tvar env = new Envelope();\n\t\tenv.expandToInclude(this.coordinates.getX(0), this.coordinates.getY(0));\n\t\treturn env;\n\t},\n\tgetSortIndex: function () {\n\t\treturn Geometry.SORTINDEX_POINT;\n\t},\n\tgetCoordinates: function () {\n\t\treturn this.isEmpty() ? [] : [this.getCoordinate()];\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.isEmpty() && other.isEmpty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.isEmpty() !== other.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function () {},\n\tgetCoordinate: function () {\n\t\treturn this.coordinates.size() !== 0 ? this.coordinates.getCoordinate(0) : null;\n\t},\n\tgetBoundaryDimension: function () {\n\t\treturn Dimension.FALSE;\n\t},\n\tgetDimension: function () {\n\t\treturn 0;\n\t},\n\tgetNumPoints: function () {\n\t\treturn this.isEmpty() ? 0 : 1;\n\t},\n\treverse: function () {\n\t\treturn this.copy();\n\t},\n\tgetX: function () {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getX called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().x;\n\t},\n\tcompareToSameClass: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\tvar point = other;\n\t\t\treturn this.getCoordinate().compareTo(point.getCoordinate());\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet other = arguments[0], comp = arguments[1];\n\t\t\tvar point = other;\n\t\t\treturn comp.compare(this.coordinates, point.coordinates);\n\t\t}\n\t},\n\tapply: function () {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfilter.filter(this.getCoordinate());\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tif (this.isEmpty()) return null;\n\t\t\tfilter.filter(this.coordinates, 0);\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t}\n\t},\n\tgetBoundary: function () {\n\t\treturn this.getFactory().createGeometryCollection(null);\n\t},\n\tclone: function () {\n\t\tvar p = Geometry.prototype.clone.call(this);\n\t\tp.coordinates = this.coordinates.clone();\n\t\treturn p;\n\t},\n\tgetGeometryType: function () {\n\t\treturn \"Point\";\n\t},\n\tcopy: function () {\n\t\treturn new Point(this.coordinates.copy(), this.factory);\n\t},\n\tgetCoordinateSequence: function () {\n\t\treturn this.coordinates;\n\t},\n\tgetY: function () {\n\t\tif (this.getCoordinate() === null) {\n\t\t\tthrow new IllegalStateException(\"getY called on empty Point\");\n\t\t}\n\t\treturn this.getCoordinate().y;\n\t},\n\tisEmpty: function () {\n\t\treturn this.coordinates.size() === 0;\n\t},\n\tinit: function (coordinates) {\n\t\tif (coordinates === null) {\n\t\t\tcoordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n\t\t}\n\t\tAssert.isTrue(coordinates.size() <= 1);\n\t\tthis.coordinates = coordinates;\n\t},\n\tisSimple: function () {\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Puntal];\n\t},\n\tgetClass: function () {\n\t\treturn Point;\n\t}\n});\nPoint.serialVersionUID = 4902022702746614570;\n","import extend from '../../../../extend';\nexport default function Polygonal() {}\nextend(Polygonal.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Polygonal;\n\t}\n});\n","import CGAlgorithms from '../algorithm/CGAlgorithms';\nimport Geometry from './Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport CoordinateFilter from './CoordinateFilter';\nimport hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport System from '../../../../java/lang/System';\nimport GeometryComponentFilter from './GeometryComponentFilter';\nimport CoordinateArrays from './CoordinateArrays';\nimport Polygonal from './Polygonal';\nimport GeometryFilter from './GeometryFilter';\nimport CoordinateSequenceFilter from './CoordinateSequenceFilter';\nimport inherits from '../../../../inherits';\nexport default function Polygon() {\n\tthis.shell = null;\n\tthis.holes = null;\n\tlet shell = arguments[0], holes = arguments[1], factory = arguments[2];\n\tGeometry.call(this, factory);\n\tif (shell === null) {\n\t\tshell = this.getFactory().createLinearRing();\n\t}\n\tif (holes === null) {\n\t\tholes = [];\n\t}\n\tif (Geometry.hasNullElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"holes must not contain null elements\");\n\t}\n\tif (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {\n\t\tthrow new IllegalArgumentException(\"shell is empty but holes are not\");\n\t}\n\tthis.shell = shell;\n\tthis.holes = holes;\n}\ninherits(Polygon, Geometry);\nextend(Polygon.prototype, {\n\tcomputeEnvelopeInternal: function () {\n\t\treturn this.shell.getEnvelopeInternal();\n\t},\n\tgetSortIndex: function () {\n\t\treturn Geometry.SORTINDEX_POLYGON;\n\t},\n\tgetCoordinates: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn [];\n\t\t}\n\t\tvar coordinates = new Array(this.getNumPoints()).fill(null);\n\t\tvar k = -1;\n\t\tvar shellCoordinates = this.shell.getCoordinates();\n\t\tfor (var x = 0; x < shellCoordinates.length; x++) {\n\t\t\tk++;\n\t\t\tcoordinates[k] = shellCoordinates[x];\n\t\t}\n\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\tvar childCoordinates = this.holes[i].getCoordinates();\n\t\t\tfor (var j = 0; j < childCoordinates.length; j++) {\n\t\t\t\tk++;\n\t\t\t\tcoordinates[k] = childCoordinates[j];\n\t\t\t}\n\t\t}\n\t\treturn coordinates;\n\t},\n\tgetArea: function () {\n\t\tvar area = 0.0;\n\t\tarea += Math.abs(CGAlgorithms.signedArea(this.shell.getCoordinateSequence()));\n\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\tarea -= Math.abs(CGAlgorithms.signedArea(this.holes[i].getCoordinateSequence()));\n\t\t}\n\t\treturn area;\n\t},\n\tisRectangle: function () {\n\t\tif (this.getNumInteriorRing() !== 0) return false;\n\t\tif (this.shell === null) return false;\n\t\tif (this.shell.getNumPoints() !== 5) return false;\n\t\tvar seq = this.shell.getCoordinateSequence();\n\t\tvar env = this.getEnvelopeInternal();\n\t\tfor (var i = 0; i < 5; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tif (!(x === env.getMinX() || x === env.getMaxX())) return false;\n\t\t\tvar y = seq.getY(i);\n\t\t\tif (!(y === env.getMinY() || y === env.getMaxY())) return false;\n\t\t}\n\t\tvar prevX = seq.getX(0);\n\t\tvar prevY = seq.getY(0);\n\t\tfor (var i = 1; i <= 4; i++) {\n\t\t\tvar x = seq.getX(i);\n\t\t\tvar y = seq.getY(i);\n\t\t\tvar xChanged = x !== prevX;\n\t\t\tvar yChanged = y !== prevY;\n\t\t\tif (xChanged === yChanged) return false;\n\t\t\tprevX = x;\n\t\t\tprevY = y;\n\t\t}\n\t\treturn true;\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar otherPolygon = other;\n\t\t\tvar thisShell = this.shell;\n\t\t\tvar otherPolygonShell = otherPolygon.shell;\n\t\t\tif (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.holes.length !== otherPolygon.holes.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\t\tif (!this.holes[i].equalsExact(otherPolygon.holes[i], tolerance)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else return Geometry.prototype.equalsExact.apply(this, arguments);\n\t},\n\tnormalize: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.normalize(this.shell, true);\n\t\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\t\tthis.normalize(this.holes[i], false);\n\t\t\t}\n\t\t\tArrays.sort(this.holes);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet ring = arguments[0], clockwise = arguments[1];\n\t\t\tif (ring.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n\t\t\tSystem.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n\t\t\tvar minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n\t\t\tCoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n\t\t\tSystem.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n\t\t\tring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n\t\t\tif (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {\n\t\t\t\tCoordinateArrays.reverse(ring.getCoordinates());\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.shell.getCoordinate();\n\t},\n\tgetNumInteriorRing: function () {\n\t\treturn this.holes.length;\n\t},\n\tgetBoundaryDimension: function () {\n\t\treturn 1;\n\t},\n\tgetDimension: function () {\n\t\treturn 2;\n\t},\n\tgetLength: function () {\n\t\tvar len = 0.0;\n\t\tlen += this.shell.getLength();\n\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\tlen += this.holes[i].getLength();\n\t\t}\n\t\treturn len;\n\t},\n\tgetNumPoints: function () {\n\t\tvar numPoints = this.shell.getNumPoints();\n\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\tnumPoints += this.holes[i].getNumPoints();\n\t\t}\n\t\treturn numPoints;\n\t},\n\treverse: function () {\n\t\tvar poly = this.copy();\n\t\tpoly.shell = this.shell.copy().reverse();\n\t\tpoly.holes = new Array(this.holes.length).fill(null);\n\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\tpoly.holes[i] = this.holes[i].copy().reverse();\n\t\t}\n\t\treturn poly;\n\t},\n\tconvexHull: function () {\n\t\treturn this.getExteriorRing().convexHull();\n\t},\n\tcompareToSameClass: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet o = arguments[0];\n\t\t\tvar thisShell = this.shell;\n\t\t\tvar otherShell = o.shell;\n\t\t\treturn thisShell.compareToSameClass(otherShell);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet o = arguments[0], comp = arguments[1];\n\t\t\tvar poly = o;\n\t\t\tvar thisShell = this.shell;\n\t\t\tvar otherShell = poly.shell;\n\t\t\tvar shellComp = thisShell.compareToSameClass(otherShell, comp);\n\t\t\tif (shellComp !== 0) return shellComp;\n\t\t\tvar nHole1 = this.getNumInteriorRing();\n\t\t\tvar nHole2 = poly.getNumInteriorRing();\n\t\t\tvar i = 0;\n\t\t\twhile (i < nHole1 && i < nHole2) {\n\t\t\t\tvar thisHole = this.getInteriorRingN(i);\n\t\t\t\tvar otherHole = poly.getInteriorRingN(i);\n\t\t\t\tvar holeComp = thisHole.compareToSameClass(otherHole, comp);\n\t\t\t\tif (holeComp !== 0) return holeComp;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i < nHole1) return 1;\n\t\t\tif (i < nHole2) return -1;\n\t\t\treturn 0;\n\t\t}\n\t},\n\tapply: function () {\n\t\tif (hasInterface(arguments[0], CoordinateFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tthis.shell.apply(filter);\n\t\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\t\tthis.holes[i].apply(filter);\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tthis.shell.apply(filter);\n\t\t\tif (!filter.isDone()) {\n\t\t\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\t\t\tthis.holes[i].apply(filter);\n\t\t\t\t\tif (filter.isDone()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (filter.isGeometryChanged()) this.geometryChanged();\n\t\t} else if (hasInterface(arguments[0], GeometryFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t} else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n\t\t\tlet filter = arguments[0];\n\t\t\tfilter.filter(this);\n\t\t\tthis.shell.apply(filter);\n\t\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\t\tthis.holes[i].apply(filter);\n\t\t\t}\n\t\t}\n\t},\n\tgetBoundary: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar rings = new Array(this.holes.length + 1).fill(null);\n\t\trings[0] = this.shell;\n\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\trings[i + 1] = this.holes[i];\n\t\t}\n\t\tif (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n\t\treturn this.getFactory().createMultiLineString(rings);\n\t},\n\tclone: function () {\n\t\tvar poly = Geometry.prototype.clone.call(this);\n\t\tpoly.shell = this.shell.clone();\n\t\tpoly.holes = new Array(this.holes.length).fill(null);\n\t\tfor (var i = 0; i < this.holes.length; i++) {\n\t\t\tpoly.holes[i] = this.holes[i].clone();\n\t\t}\n\t\treturn poly;\n\t},\n\tgetGeometryType: function () {\n\t\treturn \"Polygon\";\n\t},\n\tcopy: function () {\n\t\tvar shell = this.shell.copy();\n\t\tvar holes = new Array(this.holes.length).fill(null);\n\t\tfor (var i = 0; i < holes.length; i++) {\n\t\t\tholes[i] = this.holes[i].copy();\n\t\t}\n\t\treturn new Polygon(shell, holes, this.factory);\n\t},\n\tgetExteriorRing: function () {\n\t\treturn this.shell;\n\t},\n\tisEmpty: function () {\n\t\treturn this.shell.isEmpty();\n\t},\n\tgetInteriorRingN: function (n) {\n\t\treturn this.holes[n];\n\t},\n\tinterfaces_: function () {\n\t\treturn [Polygonal];\n\t},\n\tgetClass: function () {\n\t\treturn Polygon;\n\t}\n});\nPolygon.serialVersionUID = -3494792200821764533;\n","import Geometry from './Geometry';\nimport extend from '../../../../extend';\nimport GeometryCollection from './GeometryCollection';\nimport Dimension from './Dimension';\nimport Puntal from './Puntal';\nimport inherits from '../../../../inherits';\nexport default function MultiPoint() {\n\tlet points = arguments[0], factory = arguments[1];\n\tGeometryCollection.call(this, points, factory);\n}\ninherits(MultiPoint, GeometryCollection);\nextend(MultiPoint.prototype, {\n\tgetSortIndex: function () {\n\t\treturn Geometry.SORTINDEX_MULTIPOINT;\n\t},\n\tisValid: function () {\n\t\treturn true;\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n\t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n\t},\n\tgetCoordinate: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet n = arguments[0];\n\t\t\treturn this.geometries[n].getCoordinate();\n\t\t} else return GeometryCollection.prototype.getCoordinate.apply(this, arguments);\n\t},\n\tgetBoundaryDimension: function () {\n\t\treturn Dimension.FALSE;\n\t},\n\tgetDimension: function () {\n\t\treturn 0;\n\t},\n\tgetBoundary: function () {\n\t\treturn this.getFactory().createGeometryCollection(null);\n\t},\n\tgetGeometryType: function () {\n\t\treturn \"MultiPoint\";\n\t},\n\tcopy: function () {\n\t\tvar points = new Array(this.geometries.length).fill(null);\n\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\tpoints[i] = this.geometries[i].copy();\n\t\t}\n\t\treturn new MultiPoint(points, this.factory);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Puntal];\n\t},\n\tgetClass: function () {\n\t\treturn MultiPoint;\n\t}\n});\nMultiPoint.serialVersionUID = -8048474874175355449;\n","import LineString from './LineString';\nimport Geometry from './Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport GeometryFactory from './GeometryFactory';\nimport Coordinate from './Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport CoordinateSequences from './CoordinateSequences';\nimport CoordinateSequence from './CoordinateSequence';\nimport Dimension from './Dimension';\nimport inherits from '../../../../inherits';\nexport default function LinearRing() {\n\tif (arguments[0] instanceof Coordinate && arguments[1] instanceof GeometryFactory) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tLinearRing.call(this, factory.getCoordinateSequenceFactory().create(points), factory);\n\t} else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {\n\t\tlet points = arguments[0], factory = arguments[1];\n\t\tLineString.call(this, points, factory);\n\t\tthis.validateConstruction();\n\t}\n}\ninherits(LinearRing, LineString);\nextend(LinearRing.prototype, {\n\tgetSortIndex: function () {\n\t\treturn Geometry.SORTINDEX_LINEARRING;\n\t},\n\tgetBoundaryDimension: function () {\n\t\treturn Dimension.FALSE;\n\t},\n\tisClosed: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn LineString.prototype.isClosed.call(this);\n\t},\n\treverse: function () {\n\t\tvar seq = this.points.copy();\n\t\tCoordinateSequences.reverse(seq);\n\t\tvar rev = this.getFactory().createLinearRing(seq);\n\t\treturn rev;\n\t},\n\tvalidateConstruction: function () {\n\t\tif (!this.isEmpty() && !LineString.prototype.isClosed.call(this)) {\n\t\t\tthrow new IllegalArgumentException(\"Points of LinearRing do not form a closed linestring\");\n\t\t}\n\t\tif (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid number of points in LinearRing (found \" + this.getCoordinateSequence().size() + \" - must be 0 or >= 4)\");\n\t\t}\n\t},\n\tgetGeometryType: function () {\n\t\treturn \"LinearRing\";\n\t},\n\tcopy: function () {\n\t\treturn new LinearRing(this.points.copy(), this.factory);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LinearRing;\n\t}\n});\nLinearRing.MINIMUM_VALID_SIZE = 4;\nLinearRing.serialVersionUID = -4261142084085851829;\n","import Geometry from './Geometry';\nimport extend from '../../../../extend';\nimport GeometryCollection from './GeometryCollection';\nimport Polygonal from './Polygonal';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport inherits from '../../../../inherits';\nexport default function MultiPolygon() {\n\tlet polygons = arguments[0], factory = arguments[1];\n\tGeometryCollection.call(this, polygons, factory);\n}\ninherits(MultiPolygon, GeometryCollection);\nextend(MultiPolygon.prototype, {\n\tgetSortIndex: function () {\n\t\treturn Geometry.SORTINDEX_MULTIPOLYGON;\n\t},\n\tequalsExact: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet other = arguments[0], tolerance = arguments[1];\n\t\t\tif (!this.isEquivalentClass(other)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn GeometryCollection.prototype.equalsExact.call(this, other, tolerance);\n\t\t} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);\n\t},\n\tgetBoundaryDimension: function () {\n\t\treturn 1;\n\t},\n\tgetDimension: function () {\n\t\treturn 2;\n\t},\n\treverse: function () {\n\t\tvar n = this.geometries.length;\n\t\tvar revGeoms = new Array(n).fill(null);\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\trevGeoms[i] = this.geometries[i].reverse();\n\t\t}\n\t\treturn this.getFactory().createMultiPolygon(revGeoms);\n\t},\n\tgetBoundary: function () {\n\t\tif (this.isEmpty()) {\n\t\t\treturn this.getFactory().createMultiLineString();\n\t\t}\n\t\tvar allRings = new ArrayList();\n\t\tfor (var i = 0; i < this.geometries.length; i++) {\n\t\t\tvar polygon = this.geometries[i];\n\t\t\tvar rings = polygon.getBoundary();\n\t\t\tfor (var j = 0; j < rings.getNumGeometries(); j++) {\n\t\t\t\tallRings.add(rings.getGeometryN(j));\n\t\t\t}\n\t\t}\n\t\tvar allRingsArray = new Array(allRings.size()).fill(null);\n\t\treturn this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n\t},\n\tgetGeometryType: function () {\n\t\treturn \"MultiPolygon\";\n\t},\n\tcopy: function () {\n\t\tvar polygons = new Array(this.geometries.length).fill(null);\n\t\tfor (var i = 0; i < polygons.length; i++) {\n\t\t\tpolygons[i] = this.geometries[i].copy();\n\t\t}\n\t\treturn new MultiPolygon(polygons, this.factory);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Polygonal];\n\t},\n\tgetClass: function () {\n\t\treturn MultiPolygon;\n\t}\n});\nMultiPolygon.serialVersionUID = -551033529766975875;\n","import LineString from '../LineString';\nimport Point from '../Point';\nimport Polygon from '../Polygon';\nimport MultiPoint from '../MultiPoint';\nimport LinearRing from '../LinearRing';\nimport extend from '../../../../../extend';\nimport MultiPolygon from '../MultiPolygon';\nimport GeometryCollection from '../GeometryCollection';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport MultiLineString from '../MultiLineString';\nexport default function GeometryEditor() {\n\tthis.factory = null;\n\tthis.isUserDataCopied = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet factory = arguments[0];\n\t\tthis.factory = factory;\n\t}\n}\nextend(GeometryEditor.prototype, {\n\tsetCopyUserData: function (isUserDataCopied) {\n\t\tthis.isUserDataCopied = isUserDataCopied;\n\t},\n\tedit: function (geometry, operation) {\n\t\tif (geometry === null) return null;\n\t\tvar result = this.editInternal(geometry, operation);\n\t\tif (this.isUserDataCopied) {\n\t\t\tresult.setUserData(geometry.getUserData());\n\t\t}\n\t\treturn result;\n\t},\n\teditInternal: function (geometry, operation) {\n\t\tif (this.factory === null) this.factory = geometry.getFactory();\n\t\tif (geometry instanceof GeometryCollection) {\n\t\t\treturn this.editGeometryCollection(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Polygon) {\n\t\t\treturn this.editPolygon(geometry, operation);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn operation.edit(geometry, this.factory);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn operation.edit(geometry, this.factory);\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"Unsupported Geometry class: \" + geometry.getClass().getName());\n\t\treturn null;\n\t},\n\teditGeometryCollection: function (collection, operation) {\n\t\tvar collectionForType = operation.edit(collection, this.factory);\n\t\tvar geometries = new ArrayList();\n\t\tfor (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n\t\t\tvar geometry = this.edit(collectionForType.getGeometryN(i), operation);\n\t\t\tif (geometry === null || geometry.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgeometries.add(geometry);\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPoint) {\n\t\t\treturn this.factory.createMultiPoint(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiLineString) {\n\t\t\treturn this.factory.createMultiLineString(geometries.toArray([]));\n\t\t}\n\t\tif (collectionForType.getClass() === MultiPolygon) {\n\t\t\treturn this.factory.createMultiPolygon(geometries.toArray([]));\n\t\t}\n\t\treturn this.factory.createGeometryCollection(geometries.toArray([]));\n\t},\n\teditPolygon: function (polygon, operation) {\n\t\tvar newPolygon = operation.edit(polygon, this.factory);\n\t\tif (newPolygon === null) newPolygon = this.factory.createPolygon(null);\n\t\tif (newPolygon.isEmpty()) {\n\t\t\treturn newPolygon;\n\t\t}\n\t\tvar shell = this.edit(newPolygon.getExteriorRing(), operation);\n\t\tif (shell === null || shell.isEmpty()) {\n\t\t\treturn this.factory.createPolygon();\n\t\t}\n\t\tvar holes = new ArrayList();\n\t\tfor (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n\t\t\tvar hole = this.edit(newPolygon.getInteriorRingN(i), operation);\n\t\t\tif (hole === null || hole.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tholes.add(hole);\n\t\t}\n\t\treturn this.factory.createPolygon(shell, holes.toArray([]));\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryEditor;\n\t}\n});\nfunction GeometryEditorOperation() {}\nGeometryEditor.GeometryEditorOperation = GeometryEditorOperation;\nfunction NoOpGeometryOperation() {}\nextend(NoOpGeometryOperation.prototype, {\n\tedit: function (geometry, factory) {\n\t\treturn geometry;\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryEditorOperation];\n\t},\n\tgetClass: function () {\n\t\treturn NoOpGeometryOperation;\n\t}\n});\nfunction CoordinateOperation() {}\nextend(CoordinateOperation.prototype, {\n\tedit: function (geometry, factory) {\n\t\tvar coords = this.editCoordinates(geometry.getCoordinates(), geometry);\n\t\tif (coords === null) return geometry;\n\t\tif (geometry instanceof LinearRing) {\n\t\t\treturn factory.createLinearRing(coords);\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn factory.createLineString(coords);\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\tif (coords.length > 0) {\n\t\t\t\treturn factory.createPoint(coords[0]);\n\t\t\t} else {\n\t\t\t\treturn factory.createPoint();\n\t\t\t}\n\t\t}\n\t\treturn geometry;\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryEditorOperation];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateOperation;\n\t}\n});\nfunction CoordinateSequenceOperation() {}\nextend(CoordinateSequenceOperation.prototype, {\n\tedit: function (geometry, factory) {\n\t\tif (geometry instanceof LinearRing) {\n\t\t\treturn factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof LineString) {\n\t\t\treturn factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\tif (geometry instanceof Point) {\n\t\t\treturn factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n\t\t}\n\t\treturn geometry;\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryEditorOperation];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateSequenceOperation;\n\t}\n});\nGeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;\nGeometryEditor.CoordinateOperation = CoordinateOperation;\nGeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;\n","import StringBuffer from '../../../../../java/lang/StringBuffer';\nimport hasInterface from '../../../../../hasInterface';\nimport Coordinate from '../Coordinate';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport Double from '../../../../../java/lang/Double';\nimport extend from '../../../../../extend';\nimport CoordinateSequence from '../CoordinateSequence';\nimport Serializable from '../../../../../java/io/Serializable';\nexport default function CoordinateArraySequence() {\n\tthis.dimension = 3;\n\tthis.coordinates = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet coordinates = arguments[0];\n\t\t\tCoordinateArraySequence.call(this, coordinates, 3);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet size = arguments[0];\n\t\t\tthis.coordinates = new Array(size).fill(null);\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis.coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\tlet coordSeq = arguments[0];\n\t\t\tif (coordSeq === null) {\n\t\t\t\tthis.coordinates = new Array(0).fill(null);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis.dimension = coordSeq.getDimension();\n\t\t\tthis.coordinates = new Array(coordSeq.size()).fill(null);\n\t\t\tfor (var i = 0; i < this.coordinates.length; i++) {\n\t\t\t\tthis.coordinates[i] = coordSeq.getCoordinateCopy(i);\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tif (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n\t\t\tlet coordinates = arguments[0], dimension = arguments[1];\n\t\t\tthis.coordinates = coordinates;\n\t\t\tthis.dimension = dimension;\n\t\t\tif (coordinates === null) this.coordinates = new Array(0).fill(null);\n\t\t} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t\tthis.coordinates = new Array(size).fill(null);\n\t\t\tthis.dimension = dimension;\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tthis.coordinates[i] = new Coordinate();\n\t\t\t}\n\t\t}\n\t}\n}\nextend(CoordinateArraySequence.prototype, {\n\tsetOrdinate: function (index, ordinateIndex, value) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\tthis.coordinates[index].x = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\tthis.coordinates[index].y = value;\n\t\t\t\tbreak;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\tthis.coordinates[index].z = value;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"invalid ordinateIndex\");\n\t\t}\n\t},\n\tsize: function () {\n\t\treturn this.coordinates.length;\n\t},\n\tgetOrdinate: function (index, ordinateIndex) {\n\t\tswitch (ordinateIndex) {\n\t\t\tcase CoordinateSequence.X:\n\t\t\t\treturn this.coordinates[index].x;\n\t\t\tcase CoordinateSequence.Y:\n\t\t\t\treturn this.coordinates[index].y;\n\t\t\tcase CoordinateSequence.Z:\n\t\t\t\treturn this.coordinates[index].z;\n\t\t}\n\t\treturn Double.NaN;\n\t},\n\tgetCoordinate: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this.coordinates[i];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], coord = arguments[1];\n\t\t\tcoord.x = this.coordinates[index].x;\n\t\t\tcoord.y = this.coordinates[index].y;\n\t\t\tcoord.z = this.coordinates[index].z;\n\t\t}\n\t},\n\tgetCoordinateCopy: function (i) {\n\t\treturn new Coordinate(this.coordinates[i]);\n\t},\n\tgetDimension: function () {\n\t\treturn this.dimension;\n\t},\n\tgetX: function (index) {\n\t\treturn this.coordinates[index].x;\n\t},\n\tclone: function () {\n\t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n\t\tfor (var i = 0; i < this.coordinates.length; i++) {\n\t\t\tcloneCoordinates[i] = this.coordinates[i].clone();\n\t\t}\n\t\treturn new CoordinateArraySequence(cloneCoordinates, this.dimension);\n\t},\n\texpandEnvelope: function (env) {\n\t\tfor (var i = 0; i < this.coordinates.length; i++) {\n\t\t\tenv.expandToInclude(this.coordinates[i]);\n\t\t}\n\t\treturn env;\n\t},\n\tcopy: function () {\n\t\tvar cloneCoordinates = new Array(this.size()).fill(null);\n\t\tfor (var i = 0; i < this.coordinates.length; i++) {\n\t\t\tcloneCoordinates[i] = this.coordinates[i].copy();\n\t\t}\n\t\treturn new CoordinateArraySequence(cloneCoordinates, this.dimension);\n\t},\n\ttoString: function () {\n\t\tif (this.coordinates.length > 0) {\n\t\t\tvar strBuf = new StringBuffer(17 * this.coordinates.length);\n\t\t\tstrBuf.append('(');\n\t\t\tstrBuf.append(this.coordinates[0]);\n\t\t\tfor (var i = 1; i < this.coordinates.length; i++) {\n\t\t\t\tstrBuf.append(\", \");\n\t\t\t\tstrBuf.append(this.coordinates[i]);\n\t\t\t}\n\t\t\tstrBuf.append(')');\n\t\t\treturn strBuf.toString();\n\t\t} else {\n\t\t\treturn \"()\";\n\t\t}\n\t},\n\tgetY: function (index) {\n\t\treturn this.coordinates[index].y;\n\t},\n\ttoCoordinateArray: function () {\n\t\treturn this.coordinates;\n\t},\n\tinterfaces_: function () {\n\t\treturn [CoordinateSequence, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateArraySequence;\n\t}\n});\nCoordinateArraySequence.serialVersionUID = -915438501601840650;\n","import CoordinateSequenceFactory from '../CoordinateSequenceFactory';\nimport hasInterface from '../../../../../hasInterface';\nimport CoordinateArraySequence from './CoordinateArraySequence';\nimport extend from '../../../../../extend';\nimport CoordinateSequence from '../CoordinateSequence';\nimport Serializable from '../../../../../java/io/Serializable';\nexport default function CoordinateArraySequenceFactory() {}\nextend(CoordinateArraySequenceFactory.prototype, {\n\treadResolve: function () {\n\t\treturn CoordinateArraySequenceFactory.instance();\n\t},\n\tcreate: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordinates);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordSeq = arguments[0];\n\t\t\t\treturn new CoordinateArraySequence(coordSeq);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet size = arguments[0], dimension = arguments[1];\n\t\t\tif (dimension > 3) dimension = 3;\n\t\t\tif (dimension < 2) return new CoordinateArraySequence(size);\n\t\t\treturn new CoordinateArraySequence(size, dimension);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [CoordinateSequenceFactory, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn CoordinateArraySequenceFactory;\n\t}\n});\nCoordinateArraySequenceFactory.instance = function () {\n\treturn CoordinateArraySequenceFactory.instanceObject;\n};\nCoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;\nCoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();\n","// shared pointer\nvar i\n// shortcuts\nvar defineProperty = Object.defineProperty\nfunction is (a, b) { return (a === b) || (a !== a && b !== b) } // eslint-disable-line\n\nexport default createCollection({\n  // WeakMap#delete(key:void*):boolean\n  'delete': sharedDelete,\n  // :was Map#get(key:void*[, d3fault:void*]):void*\n  // Map#has(key:void*):boolean\n  has: mapHas,\n  // Map#get(key:void*):boolean\n  get: sharedGet,\n  // Map#set(key:void*, value:void*):void\n  set: sharedSet,\n  // Map#keys(void):Iterator\n  keys: sharedKeys,\n  // Map#values(void):Iterator\n  values: sharedValues,\n  // Map#entries(void):Iterator\n  entries: mapEntries,\n  // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`\n  forEach: sharedForEach,\n  // Map#clear():\n  clear: sharedClear\n})\n\n/**\n * ES6 collection constructor\n * @return {Function} a collection class\n */\nfunction createCollection (proto, objectOnly) {\n  function Collection (a) {\n    if (!this || this.constructor !== Collection) return new Collection(a)\n    this._keys = []\n    this._values = []\n    this._itp = [] // iteration pointers\n    this.objectOnly = objectOnly\n\n    // parse initial iterable argument passed\n    if (a) init.call(this, a)\n  }\n\n  // define size for non object-only collections\n  if (!objectOnly) {\n    defineProperty(proto, 'size', {\n      get: sharedSize\n    })\n  }\n\n  // set prototype\n  proto.constructor = Collection\n  Collection.prototype = proto\n\n  return Collection\n}\n\n/** parse initial iterable argument passed */\nfunction init (a) {\n  // init Set argument, like `[1,2,3,{}]`\n  if (this.add) a.forEach(this.add, this)\n  // init Map argument like `[[1,2], [{}, 4]]`\n  else a.forEach(function (a) { this.set(a[0], a[1]) }, this)\n}\n\n/** delete */\nfunction sharedDelete (key) {\n  if (this.has(key)) {\n    this._keys.splice(i, 1)\n    this._values.splice(i, 1)\n    // update iteration pointers\n    this._itp.forEach(function (p) { if (i < p[0]) p[0]-- })\n  }\n  // Aurora here does it while Canary doesn't\n  return i > -1\n}\n\nfunction sharedGet (key) {\n  return this.has(key) ? this._values[i] : undefined\n}\n\nfunction has (list, key) {\n  if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key')\n  // NaN or 0 passed\n  if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} // eslint-disable-line\n  else i = list.indexOf(key)\n  return i > -1\n}\n\nfunction mapHas (value) {\n  return has.call(this, this._keys, value)\n}\n\n/** @chainable */\nfunction sharedSet (key, value) {\n  this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value\n  return this\n}\n\nfunction sharedClear () {\n  (this._keys || 0).length =\n    this._values.length = 0\n}\n\n/** keys, values, and iterate related methods */\nfunction sharedKeys () {\n  return sharedIterator(this._itp, this._keys)\n}\n\nfunction sharedValues () {\n  return sharedIterator(this._itp, this._values)\n}\n\nfunction mapEntries () {\n  return sharedIterator(this._itp, this._keys, this._values)\n}\n\nfunction sharedIterator (itp, array, array2) {\n  var p = [0]\n  var done = false\n  itp.push(p)\n  return {\n    next: function () {\n      var v\n      var k = p[0]\n      if (!done && k < array.length) {\n        v = array2 ? [array[k], array2[k]] : array[k]\n        p[0]++\n      } else {\n        done = true\n        itp.splice(itp.indexOf(p), 1)\n      }\n      return { done: done, value: v }\n    }\n  }\n}\n\nfunction sharedSize () {\n  return this._values.length\n}\n\nfunction sharedForEach (callback, context) {\n  var it = this.entries()\n  for (;;) {\n    var r = it.next()\n    if (r.done) break\n    callback.call(context, r.value[1], r.value[0], this)\n  }\n}\n","import ArrayList from './ArrayList'\nimport MapInterface from './Map'\nimport HashSet from './HashSet'\nimport MapPolyfill from '../../Map'\n\nlet MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? MapPolyfill : Map\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n *\n * @extends {javascript.util.Map}\n * @constructor\n * @private\n */\nexport default function HashMap () {\n  /**\n   * @type {Object}\n   * @private\n  */\n  this.map_ = new MapImpl()\n}\nHashMap.prototype = new MapInterface()\n\n/**\n * @override\n */\nHashMap.prototype.get = function (key) {\n  return this.map_.get(key) || null\n}\n\n/**\n * @override\n */\nHashMap.prototype.put = function (key, value) {\n  this.map_.set(key, value)\n  return value\n}\n\n/**\n * @override\n */\nHashMap.prototype.values = function () {\n  const arrayList = new ArrayList()\n  const it = this.map_.values()\n  let o = it.next()\n  while (!o.done) {\n    arrayList.add(o.value)\n    o = it.next()\n  }\n  return arrayList\n}\n\n/**\n * @override\n */\nHashMap.prototype.entrySet = function () {\n  const hashSet = new HashSet()\n  this.map_.entries().forEach(entry => hashSet.add(entry))\n  return hashSet\n}\n\n/**\n * @override\n */\nHashMap.prototype.size = function () {\n  return this.map_.size()\n}\n","import HashMap from '../../../../java/util/HashMap';\nimport Coordinate from './Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport Integer from '../../../../java/lang/Integer';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Serializable from '../../../../java/io/Serializable';\nexport default function PrecisionModel() {\n\tthis.modelType = null;\n\tthis.scale = null;\n\tif (arguments.length === 0) {\n\t\tthis.modelType = PrecisionModel.FLOATING;\n\t} else if (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Type) {\n\t\t\tlet modelType = arguments[0];\n\t\t\tthis.modelType = modelType;\n\t\t\tif (modelType === PrecisionModel.FIXED) {\n\t\t\t\tthis.setScale(1.0);\n\t\t\t}\n\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\tlet scale = arguments[0];\n\t\t\tthis.modelType = PrecisionModel.FIXED;\n\t\t\tthis.setScale(scale);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tlet pm = arguments[0];\n\t\t\tthis.modelType = pm.modelType;\n\t\t\tthis.scale = pm.scale;\n\t\t}\n\t}\n}\nextend(PrecisionModel.prototype, {\n\tequals: function (other) {\n\t\tif (!(other instanceof PrecisionModel)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherPrecisionModel = other;\n\t\treturn this.modelType === otherPrecisionModel.modelType && this.scale === otherPrecisionModel.scale;\n\t},\n\tcompareTo: function (o) {\n\t\tvar other = o;\n\t\tvar sigDigits = this.getMaximumSignificantDigits();\n\t\tvar otherSigDigits = other.getMaximumSignificantDigits();\n\t\treturn new Integer(sigDigits).compareTo(new Integer(otherSigDigits));\n\t},\n\tgetScale: function () {\n\t\treturn this.scale;\n\t},\n\tisFloating: function () {\n\t\treturn this.modelType === PrecisionModel.FLOATING || this.modelType === PrecisionModel.FLOATING_SINGLE;\n\t},\n\tgetType: function () {\n\t\treturn this.modelType;\n\t},\n\ttoString: function () {\n\t\tvar description = \"UNKNOWN\";\n\t\tif (this.modelType === PrecisionModel.FLOATING) {\n\t\t\tdescription = \"Floating\";\n\t\t} else if (this.modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tdescription = \"Floating-Single\";\n\t\t} else if (this.modelType === PrecisionModel.FIXED) {\n\t\t\tdescription = \"Fixed (Scale=\" + this.getScale() + \")\";\n\t\t}\n\t\treturn description;\n\t},\n\tmakePrecise: function () {\n\t\tif (typeof arguments[0] === \"number\") {\n\t\t\tlet val = arguments[0];\n\t\t\tif (Double.isNaN(val)) return val;\n\t\t\tif (this.modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\t\tvar floatSingleVal = val;\n\t\t\t\treturn floatSingleVal;\n\t\t\t}\n\t\t\tif (this.modelType === PrecisionModel.FIXED) {\n\t\t\t\treturn Math.round(val * this.scale) / this.scale;\n\t\t\t}\n\t\t\treturn val;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\tif (this.modelType === PrecisionModel.FLOATING) return null;\n\t\t\tcoord.x = this.makePrecise(coord.x);\n\t\t\tcoord.y = this.makePrecise(coord.y);\n\t\t}\n\t},\n\tgetMaximumSignificantDigits: function () {\n\t\tvar maxSigDigits = 16;\n\t\tif (this.modelType === PrecisionModel.FLOATING) {\n\t\t\tmaxSigDigits = 16;\n\t\t} else if (this.modelType === PrecisionModel.FLOATING_SINGLE) {\n\t\t\tmaxSigDigits = 6;\n\t\t} else if (this.modelType === PrecisionModel.FIXED) {\n\t\t\tmaxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n\t\t}\n\t\treturn maxSigDigits;\n\t},\n\tsetScale: function (scale) {\n\t\tthis.scale = Math.abs(scale);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable, Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn PrecisionModel;\n\t}\n});\nPrecisionModel.mostPrecise = function (pm1, pm2) {\n\tif (pm1.compareTo(pm2) >= 0) return pm1;\n\treturn pm2;\n};\nfunction Type() {\n\tthis.name = null;\n\tlet name = arguments[0];\n\tthis.name = name;\n\tType.nameToTypeMap.put(name, this);\n}\nextend(Type.prototype, {\n\treadResolve: function () {\n\t\treturn Type.nameToTypeMap.get(this.name);\n\t},\n\ttoString: function () {\n\t\treturn this.name;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn Type;\n\t}\n});\nType.serialVersionUID = -5528602631731589822;\nType.nameToTypeMap = new HashMap();\nPrecisionModel.Type = Type;\nPrecisionModel.serialVersionUID = 7777263578777803835;\nPrecisionModel.FIXED = new Type(\"FIXED\");\nPrecisionModel.FLOATING = new Type(\"FLOATING\");\nPrecisionModel.FLOATING_SINGLE = new Type(\"FLOATING SINGLE\");\nPrecisionModel.maximumPreciseValue = 9007199254740992.0;\n","import CoordinateSequenceFactory from './CoordinateSequenceFactory';\nimport LineString from './LineString';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from './Coordinate';\nimport Point from './Point';\nimport Polygon from './Polygon';\nimport MultiPoint from './MultiPoint';\nimport GeometryEditor from './util/GeometryEditor';\nimport LinearRing from './LinearRing';\nimport extend from '../../../../extend';\nimport CoordinateArraySequenceFactory from './impl/CoordinateArraySequenceFactory';\nimport MultiPolygon from './MultiPolygon';\nimport CoordinateSequences from './CoordinateSequences';\nimport CoordinateSequence from './CoordinateSequence';\nimport GeometryCollection from './GeometryCollection';\nimport PrecisionModel from './PrecisionModel';\nimport Serializable from '../../../../java/io/Serializable';\nimport Assert from '../util/Assert';\nimport MultiLineString from './MultiLineString';\nexport default function GeometryFactory() {\n\tthis.precisionModel = null;\n\tthis.coordinateSequenceFactory = null;\n\tthis.SRID = null;\n\tif (arguments.length === 0) {\n\t\tGeometryFactory.call(this, new PrecisionModel(), 0);\n\t} else if (arguments.length === 1) {\n\t\tif (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n\t\t\tlet coordinateSequenceFactory = arguments[0];\n\t\t\tGeometryFactory.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);\n\t\t} else if (arguments[0] instanceof PrecisionModel) {\n\t\t\tlet precisionModel = arguments[0];\n\t\t\tGeometryFactory.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet precisionModel = arguments[0], SRID = arguments[1];\n\t\tGeometryFactory.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());\n\t} else if (arguments.length === 3) {\n\t\tlet precisionModel = arguments[0], SRID = arguments[1], coordinateSequenceFactory = arguments[2];\n\t\tthis.precisionModel = precisionModel;\n\t\tthis.coordinateSequenceFactory = coordinateSequenceFactory;\n\t\tthis.SRID = SRID;\n\t}\n}\nextend(GeometryFactory.prototype, {\n\ttoGeometry: function (envelope) {\n\t\tif (envelope.isNull()) {\n\t\t\treturn this.createPoint(null);\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n\t\t}\n\t\tif (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n\t\t\treturn this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);\n\t\t}\n\t\treturn this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);\n\t},\n\tcreateLineString: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLineString(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new LineString(coordinates, this);\n\t\t\t}\n\t\t}\n\t},\n\tcreateMultiLineString: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiLineString(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet lineStrings = arguments[0];\n\t\t\treturn new MultiLineString(lineStrings, this);\n\t\t}\n\t},\n\tbuildGeometry: function (geomList) {\n\t\tvar geomClass = null;\n\t\tvar isHeterogeneous = false;\n\t\tvar hasGeometryCollection = false;\n\t\tfor (var i = geomList.iterator(); i.hasNext(); ) {\n\t\t\tvar geom = i.next();\n\t\t\tvar partClass = geom.getClass();\n\t\t\tif (geomClass === null) {\n\t\t\t\tgeomClass = partClass;\n\t\t\t}\n\t\t\tif (partClass !== geomClass) {\n\t\t\t\tisHeterogeneous = true;\n\t\t\t}\n\t\t\tif (geom.isGeometryCollectionOrDerived()) hasGeometryCollection = true;\n\t\t}\n\t\tif (geomClass === null) {\n\t\t\treturn this.createGeometryCollection();\n\t\t}\n\t\tif (isHeterogeneous || hasGeometryCollection) {\n\t\t\treturn this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n\t\t}\n\t\tvar geom0 = geomList.iterator().next();\n\t\tvar isCollection = geomList.size() > 1;\n\t\tif (isCollection) {\n\t\t\tif (geom0 instanceof Polygon) {\n\t\t\t\treturn this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));\n\t\t\t} else if (geom0 instanceof LineString) {\n\t\t\t\treturn this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));\n\t\t\t} else if (geom0 instanceof Point) {\n\t\t\t\treturn this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n\t\t\t}\n\t\t\tAssert.shouldNeverReachHere(\"Unhandled class: \" + geom0.getClass().getName());\n\t\t}\n\t\treturn geom0;\n\t},\n\tcreateMultiPointFromCoords: function (coordinates) {\n\t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t},\n\tcreatePoint: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createPoint(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet coordinate = arguments[0];\n\t\t\t\treturn this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new Point(coordinates, this);\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinateSequenceFactory: function () {\n\t\treturn this.coordinateSequenceFactory;\n\t},\n\tcreatePolygon: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new Polygon(null, null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(coordinates));\n\t\t\t} else if (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createPolygon(this.createLinearRing(coordinates));\n\t\t\t} else if (arguments[0] instanceof LinearRing) {\n\t\t\t\tlet shell = arguments[0];\n\t\t\t\treturn this.createPolygon(shell, null);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet shell = arguments[0], holes = arguments[1];\n\t\t\treturn new Polygon(shell, holes, this);\n\t\t}\n\t},\n\tgetSRID: function () {\n\t\treturn this.SRID;\n\t},\n\tcreateGeometryCollection: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new GeometryCollection(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geometries = arguments[0];\n\t\t\treturn new GeometryCollection(geometries, this);\n\t\t}\n\t},\n\tcreateGeometry: function (g) {\n\t\tvar editor = new GeometryEditor(this);\n\t\treturn editor.edit(g, {\n\t\t\tedit: function () {\n\t\t\t\tif (arguments.length === 2) {\n\t\t\t\t\tlet coordSeq = arguments[0], geometry = arguments[1];\n\t\t\t\t\treturn this.coordinateSequenceFactory.create(coordSeq);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\tgetPrecisionModel: function () {\n\t\treturn this.precisionModel;\n\t},\n\tcreateLinearRing: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.createLinearRing(this.getCoordinateSequenceFactory().create([]));\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn new LinearRing(coordinates, this);\n\t\t\t}\n\t\t}\n\t},\n\tcreateMultiPolygon: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPolygon(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet polygons = arguments[0];\n\t\t\treturn new MultiPolygon(polygons, this);\n\t\t}\n\t},\n\tcreateMultiPoint: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn new MultiPoint(null, this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Array) {\n\t\t\t\tlet point = arguments[0];\n\t\t\t\treturn new MultiPoint(point, this);\n\t\t\t} else if (arguments[0] instanceof Array) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\treturn this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n\t\t\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\t\t\tlet coordinates = arguments[0];\n\t\t\t\tif (coordinates === null) {\n\t\t\t\t\treturn this.createMultiPoint(new Array(0).fill(null));\n\t\t\t\t}\n\t\t\t\tvar points = new Array(coordinates.size()).fill(null);\n\t\t\t\tfor (var i = 0; i < coordinates.size(); i++) {\n\t\t\t\t\tvar ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());\n\t\t\t\t\tCoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);\n\t\t\t\t\tpoints[i] = this.createPoint(ptSeq);\n\t\t\t\t}\n\t\t\t\treturn this.createMultiPoint(points);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryFactory;\n\t}\n});\nGeometryFactory.toMultiPolygonArray = function (multiPolygons) {\n\tvar multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n\treturn multiPolygons.toArray(multiPolygonArray);\n};\nGeometryFactory.toGeometryArray = function (geometries) {\n\tif (geometries === null) return null;\n\tvar geometryArray = new Array(geometries.size()).fill(null);\n\treturn geometries.toArray(geometryArray);\n};\nGeometryFactory.getDefaultCoordinateSequenceFactory = function () {\n\treturn CoordinateArraySequenceFactory.instance();\n};\nGeometryFactory.toMultiLineStringArray = function (multiLineStrings) {\n\tvar multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n\treturn multiLineStrings.toArray(multiLineStringArray);\n};\nGeometryFactory.toLineStringArray = function (lineStrings) {\n\tvar lineStringArray = new Array(lineStrings.size()).fill(null);\n\treturn lineStrings.toArray(lineStringArray);\n};\nGeometryFactory.toMultiPointArray = function (multiPoints) {\n\tvar multiPointArray = new Array(multiPoints.size()).fill(null);\n\treturn multiPoints.toArray(multiPointArray);\n};\nGeometryFactory.toLinearRingArray = function (linearRings) {\n\tvar linearRingArray = new Array(linearRings.size()).fill(null);\n\treturn linearRings.toArray(linearRingArray);\n};\nGeometryFactory.toPointArray = function (points) {\n\tvar pointArray = new Array(points.size()).fill(null);\n\treturn points.toArray(pointArray);\n};\nGeometryFactory.toPolygonArray = function (polygons) {\n\tvar polygonArray = new Array(polygons.size()).fill(null);\n\treturn polygons.toArray(polygonArray);\n};\nGeometryFactory.createPointFromInternalCoord = function (coord, exemplar) {\n\texemplar.getPrecisionModel().makePrecise(coord);\n\treturn exemplar.getFactory().createPoint(coord);\n};\nGeometryFactory.serialVersionUID = -6820524753094095635;\n","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\nimport extend from '../../../../extend'\n\nconst regExes = {\n  'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n  'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n  'spaces': /\\s+/,\n  'parenComma': /\\)\\s*,\\s*\\(/,\n  'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/, // can't use {2} here\n  'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n}\n\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/** Create a new parser for WKT\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of WKTParser.\n * @constructor\n * @private\n */\nexport default function WKTParser (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory()\n}\n\nextend(WKTParser.prototype, {\n  /**\n   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n   * and GEOMETRYCOLLECTION.\n   *\n   * @param {String} wkt A WKT string.\n   * @return {Geometry} A geometry instance.\n   * @private\n   */\n  read (wkt) {\n    var geometry, type, str\n    wkt = wkt.replace(/[\\n\\r]/g, ' ')\n    var matches = regExes.typeStr.exec(wkt)\n    if (wkt.search('EMPTY') !== -1) {\n      matches = regExes.emptyTypeStr.exec(wkt)\n      matches[2] = undefined\n    }\n    if (matches) {\n      type = matches[1].toLowerCase()\n      str = matches[2]\n      if (parse[type]) {\n        geometry = parse[type].apply(this, [str])\n      }\n    }\n\n    if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt)\n\n    return geometry\n  },\n\n  /**\n   * Serialize a geometry into a WKT string.\n   *\n   * @param {Geometry} geometry A feature or array of features.\n   * @return {String} The WKT string representation of the input geometries.\n   * @private\n   */\n  write (geometry) {\n    return this.extractGeometry(geometry)\n  },\n\n  /**\n   * Entry point to construct the WKT for a single Geometry object.\n   *\n   * @param {Geometry} geometry\n   * @return {String} A WKT string of representing the geometry.\n   * @private\n   */\n  extractGeometry (geometry) {\n    var type = geometry.getGeometryType().toLowerCase()\n    if (!extract[type]) {\n      return null\n    }\n    var wktType = type.toUpperCase()\n    var data\n    if (geometry.isEmpty()) {\n      data = wktType + ' EMPTY'\n    } else {\n      data = wktType + '(' + extract[type].apply(this, [geometry]) + ')'\n    }\n    return data\n  }\n})\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual data extraction.\n * @private\n */\nconst extract = {\n  coordinate (coordinate) {\n    return coordinate.x + ' ' + coordinate.y\n  },\n\n  /**\n   * Return a space delimited string of point coordinates.\n   *\n   * @param {Point}\n   *          point\n   * @return {String} A string of coordinates representing the point.\n   */\n  point (point) {\n    return extract.coordinate.call(this, point.coordinates.coordinates[0])\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a multipoint.\n   *\n   * @param {MultiPoint}\n   *          multipoint\n   * @return {String} A string of point coordinate strings representing the\n   *         multipoint.\n   */\n  multipoint (multipoint) {\n    var array = []\n    for (let i = 0, len = multipoint.geometries.length; i < len; ++i) {\n      array.push('(' + extract.point.apply(this, [multipoint.geometries[i]]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a line.\n   *\n   * @param {LineString} linestring\n   * @return {String} A string of point coordinate strings representing the linestring.\n   */\n  linestring (linestring) {\n    var array = []\n    for (let i = 0, len = linestring.points.coordinates.length; i < len; ++i) {\n      array.push(extract.coordinate.apply(this, [linestring.points.coordinates[i]]))\n    }\n    return array.join(',')\n  },\n\n  linearring (linearring) {\n    var array = []\n    for (let i = 0, len = linearring.points.coordinates.length; i < len; ++i) {\n      array.push(extract.coordinate.apply(this, [linearring.points.coordinates[i]]))\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linestring strings from a\n   * multilinestring.\n   *\n   * @param {MultiLineString} multilinestring\n   * @return {String} A string of of linestring strings representing the multilinestring.\n   */\n  multilinestring (multilinestring) {\n    var array = []\n    for (let i = 0, len = multilinestring.geometries.length; i < len; ++i) {\n      array.push('(' +\n        extract.linestring.apply(this, [multilinestring.geometries[i]]) +\n        ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linear ring arrays from a polygon.\n   *\n   * @param {Polygon} polygon\n   * @return {String} An array of linear ring arrays representing the polygon.\n   */\n  polygon (polygon) {\n    var array = []\n    array.push('(' + extract.linestring.apply(this, [polygon.shell]) + ')')\n    for (let i = 0, len = polygon.holes.length; i < len; ++i) {\n      array.push('(' + extract.linestring.apply(this, [polygon.holes[i]]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return an array of polygon arrays from a multipolygon.\n   *\n   * @param {MultiPolygon} multipolygon\n   * @return {String} An array of polygon arrays representing the multipolygon.\n   */\n  multipolygon (multipolygon) {\n    var array = []\n    for (let i = 0, len = multipolygon.geometries.length; i < len; ++i) {\n      array.push('(' + extract.polygon.apply(this, [multipolygon.geometries[i]]) + ')')\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n   * geometrycollection.\n   *\n   * @param {GeometryCollection} collection\n   * @return {String} internal WKT representation of the collection.\n   */\n  geometrycollection (collection) {\n    var array = []\n    for (let i = 0, len = collection.geometries.length; i < len; ++i) {\n      array.push(this.extractGeometry(collection.geometries[i]))\n    }\n    return array.join(',')\n  }\n}\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual parsing.\n * @private\n */\nconst parse = {\n  /**\n   * Return point geometry given a point WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the point.\n   * @return {Point} A point geometry.\n   * @private\n   */\n  point (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPoint()\n    }\n\n    var coords = str.trim().split(regExes.spaces)\n    return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]),\n      Number.parseFloat(coords[1])))\n  },\n\n  /**\n   * Return a multipoint geometry given a multipoint WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipoint.\n   * @return {Point} A multipoint feature.\n   * @private\n   */\n  multipoint (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPoint()\n    }\n\n    var point\n    var points = str.trim().split(',')\n    var components = []\n    for (let i = 0, len = points.length; i < len; ++i) {\n      point = points[i].replace(regExes.trimParens, '$1')\n      components.push(parse.point.apply(this, [point]))\n    }\n    return this.geometryFactory.createMultiPoint(components)\n  },\n\n  /**\n   * Return a linestring geometry given a linestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linestring.\n   * @return {LineString} A linestring geometry.\n   * @private\n   */\n  linestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLineString()\n    }\n\n    var points = str.trim().split(',')\n    var components = []\n    var coords\n    for (let i = 0, len = points.length; i < len; ++i) {\n      coords = points[i].trim().split(regExes.spaces)\n      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])))\n    }\n    return this.geometryFactory.createLineString(components)\n  },\n\n  /**\n   * Return a linearring geometry given a linearring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linearring.\n   * @return {LinearRing} A linearring geometry.\n   * @private\n   */\n  linearring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLinearRing()\n    }\n\n    var points = str.trim().split(',')\n    var components = []\n    var coords\n    for (let i = 0, len = points.length; i < len; ++i) {\n      coords = points[i].trim().split(regExes.spaces)\n      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])))\n    }\n    return this.geometryFactory.createLinearRing(components)\n  },\n\n  /**\n   * Return a multilinestring geometry given a multilinestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multilinestring.\n   * @return {MultiLineString} A multilinestring geometry.\n   * @private\n   */\n  multilinestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiLineString()\n    }\n\n    var line\n    var lines = str.trim().split(regExes.parenComma)\n    var components = []\n    for (let i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i].replace(regExes.trimParens, '$1')\n      components.push(parse.linestring.apply(this, [line]))\n    }\n    return this.geometryFactory.createMultiLineString(components)\n  },\n\n  /**\n   * Return a polygon geometry given a polygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the polygon.\n   * @return {Polygon} A polygon geometry.\n   * @private\n   */\n  polygon (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPolygon()\n    }\n\n    var ring, linestring, linearring\n    var rings = str.trim().split(regExes.parenComma)\n    var shell\n    var holes = []\n    for (let i = 0, len = rings.length; i < len; ++i) {\n      ring = rings[i].replace(regExes.trimParens, '$1')\n      linestring = parse.linestring.apply(this, [ring])\n      linearring = this.geometryFactory.createLinearRing(linestring.points)\n      if (i === 0) {\n        shell = linearring\n      } else {\n        holes.push(linearring)\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Return a multipolygon geometry given a multipolygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipolygon.\n   * @return {MultiPolygon} A multipolygon geometry.\n   * @private\n   */\n  multipolygon (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPolygon()\n    }\n\n    var polygon\n    var polygons = str.trim().split(regExes.doubleParenComma)\n    var components = []\n    for (let i = 0, len = polygons.length; i < len; ++i) {\n      polygon = polygons[i].replace(regExes.trimParens, '$1')\n      components.push(parse.polygon.apply(this, [polygon]))\n    }\n    return this.geometryFactory.createMultiPolygon(components)\n  },\n\n  /**\n   * Return a geometrycollection given a geometrycollection WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the geometrycollection.\n   * @return {GeometryCollection}\n   * @private\n   */\n  geometrycollection (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createGeometryCollection()\n    }\n\n    // separate components of the collection with |\n    str = str.replace(/,\\s*([A-Za-z])/g, '|$1')\n    var wktArray = str.trim().split('|')\n    var components = []\n    for (let i = 0, len = wktArray.length; i < len; ++i) {\n      components.push(this.read(wktArray[i]))\n    }\n    return this.geometryFactory.createGeometryCollection(components)\n  }\n}\n","import WKTParser from './WKTParser'\nimport extend from '../../../../extend'\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\n\n/**\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nexport default function WKTWriter (geometryFactory) {\n  this.parser = new WKTParser(geometryFactory)\n}\n\nextend(WKTWriter.prototype, {\n  /**\n   * Converts a <code>Geometry</code> to its Well-known Text representation.\n   *\n   * @param {Geometry} geometry a <code>Geometry</code> to process.\n   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n   *         Features Specification).\n   * @memberof WKTWriter\n   */\n  write (geometry) {\n    return this.parser.write(geometry)\n  }\n})\n\nextend(WKTWriter, {\n  /**\n   * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n   * {@link Coordinate}s.\n   *\n   * @param p0 the first coordinate.\n   * @param p1 the second coordinate.\n   *\n   * @return the WKT.\n   * @private\n   */\n  toLineString (p0, p1) {\n    if (arguments.length !== 2) {\n      throw new Error('Not implemented')\n    }\n\n    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'\n  }\n})\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport WKTWriter from '../io/WKTWriter';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport Assert from '../util/Assert';\nexport default function LineIntersector() {\n\tthis.result = null;\n\tthis.inputLines = Array(2).fill().map(() => Array(2));\n\tthis.intPt = new Array(2).fill(null);\n\tthis.intLineIndex = null;\n\tthis._isProper = null;\n\tthis.pa = null;\n\tthis.pb = null;\n\tthis.precisionModel = null;\n\tthis.intPt[0] = new Coordinate();\n\tthis.intPt[1] = new Coordinate();\n\tthis.pa = this.intPt[0];\n\tthis.pb = this.intPt[1];\n\tthis.result = 0;\n}\nextend(LineIntersector.prototype, {\n\tgetIndexAlongSegment: function (segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this.intLineIndex[segmentIndex][intIndex];\n\t},\n\tgetTopologySummary: function () {\n\t\tvar catBuf = new StringBuffer();\n\t\tif (this.isEndPoint()) catBuf.append(\" endpoint\");\n\t\tif (this._isProper) catBuf.append(\" proper\");\n\t\tif (this.isCollinear()) catBuf.append(\" collinear\");\n\t\treturn catBuf.toString();\n\t},\n\tcomputeIntersection: function (p1, p2, p3, p4) {\n\t\tthis.inputLines[0][0] = p1;\n\t\tthis.inputLines[0][1] = p2;\n\t\tthis.inputLines[1][0] = p3;\n\t\tthis.inputLines[1][1] = p4;\n\t\tthis.result = this.computeIntersect(p1, p2, p3, p4);\n\t},\n\tgetIntersectionNum: function () {\n\t\treturn this.result;\n\t},\n\tcomputeIntLineIndex: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.intLineIndex === null) {\n\t\t\t\tthis.intLineIndex = Array(2).fill().map(() => Array(2));\n\t\t\t\tthis.computeIntLineIndex(0);\n\t\t\t\tthis.computeIntLineIndex(1);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet segmentIndex = arguments[0];\n\t\t\tvar dist0 = this.getEdgeDistance(segmentIndex, 0);\n\t\t\tvar dist1 = this.getEdgeDistance(segmentIndex, 1);\n\t\t\tif (dist0 > dist1) {\n\t\t\t\tthis.intLineIndex[segmentIndex][0] = 0;\n\t\t\t\tthis.intLineIndex[segmentIndex][1] = 1;\n\t\t\t} else {\n\t\t\t\tthis.intLineIndex[segmentIndex][0] = 1;\n\t\t\t\tthis.intLineIndex[segmentIndex][1] = 0;\n\t\t\t}\n\t\t}\n\t},\n\tisProper: function () {\n\t\treturn this.hasIntersection() && this._isProper;\n\t},\n\tsetPrecisionModel: function (precisionModel) {\n\t\tthis.precisionModel = precisionModel;\n\t},\n\tisInteriorIntersection: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isInteriorIntersection(0)) return true;\n\t\t\tif (this.isInteriorIntersection(1)) return true;\n\t\t\treturn false;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet inputLineIndex = arguments[0];\n\t\t\tfor (var i = 0; i < this.result; i++) {\n\t\t\t\tif (!(this.intPt[i].equals2D(this.inputLines[inputLineIndex][0]) || this.intPt[i].equals2D(this.inputLines[inputLineIndex][1]))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t},\n\tgetIntersection: function (intIndex) {\n\t\treturn this.intPt[intIndex];\n\t},\n\tisEndPoint: function () {\n\t\treturn this.hasIntersection() && !this._isProper;\n\t},\n\thasIntersection: function () {\n\t\treturn this.result !== LineIntersector.NO_INTERSECTION;\n\t},\n\tgetEdgeDistance: function (segmentIndex, intIndex) {\n\t\tvar dist = LineIntersector.computeEdgeDistance(this.intPt[intIndex], this.inputLines[segmentIndex][0], this.inputLines[segmentIndex][1]);\n\t\treturn dist;\n\t},\n\tisCollinear: function () {\n\t\treturn this.result === LineIntersector.COLLINEAR_INTERSECTION;\n\t},\n\ttoString: function () {\n\t\treturn WKTWriter.toLineString(this.inputLines[0][0], this.inputLines[0][1]) + \" - \" + WKTWriter.toLineString(this.inputLines[1][0], this.inputLines[1][1]) + this.getTopologySummary();\n\t},\n\tgetEndpoint: function (segmentIndex, ptIndex) {\n\t\treturn this.inputLines[segmentIndex][ptIndex];\n\t},\n\tisIntersection: function (pt) {\n\t\tfor (var i = 0; i < this.result; i++) {\n\t\t\tif (this.intPt[i].equals2D(pt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetIntersectionAlongSegment: function (segmentIndex, intIndex) {\n\t\tthis.computeIntLineIndex();\n\t\treturn this.intPt[this.intLineIndex[segmentIndex][intIndex]];\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineIntersector;\n\t}\n});\nLineIntersector.computeEdgeDistance = function (p, p0, p1) {\n\tvar dx = Math.abs(p1.x - p0.x);\n\tvar dy = Math.abs(p1.y - p0.y);\n\tvar dist = -1.0;\n\tif (p.equals(p0)) {\n\t\tdist = 0.0;\n\t} else if (p.equals(p1)) {\n\t\tif (dx > dy) dist = dx; else dist = dy;\n\t} else {\n\t\tvar pdx = Math.abs(p.x - p0.x);\n\t\tvar pdy = Math.abs(p.y - p0.y);\n\t\tif (dx > dy) dist = pdx; else dist = pdy;\n\t\tif (dist === 0.0 && !p.equals(p0)) {\n\t\t\tdist = Math.max(pdx, pdy);\n\t\t}\n\t}\n\tAssert.isTrue(!(dist === 0.0 && !p.equals(p0)), \"Bad distance calculation\");\n\treturn dist;\n};\nLineIntersector.nonRobustComputeEdgeDistance = function (p, p1, p2) {\n\tvar dx = p.x - p1.x;\n\tvar dy = p.y - p1.y;\n\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\tAssert.isTrue(!(dist === 0.0 && !p.equals(p1)), \"Invalid distance calculation\");\n\treturn dist;\n};\nLineIntersector.DONT_INTERSECT = 0;\nLineIntersector.DO_INTERSECT = 1;\nLineIntersector.COLLINEAR = 2;\nLineIntersector.NO_INTERSECTION = 0;\nLineIntersector.POINT_INTERSECTION = 1;\nLineIntersector.COLLINEAR_INTERSECTION = 2;\n","import NotRepresentableException from './NotRepresentableException';\nimport CGAlgorithms from './CGAlgorithms';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport CGAlgorithmsDD from './CGAlgorithmsDD';\nimport System from '../../../../java/lang/System';\nimport HCoordinate from './HCoordinate';\nimport Envelope from '../geom/Envelope';\nimport inherits from '../../../../inherits';\nimport LineIntersector from './LineIntersector';\nexport default function RobustLineIntersector() {\n\tLineIntersector.apply(this);\n}\ninherits(RobustLineIntersector, LineIntersector);\nextend(RobustLineIntersector.prototype, {\n\tisInSegmentEnvelopes: function (intPt) {\n\t\tvar env0 = new Envelope(this.inputLines[0][0], this.inputLines[0][1]);\n\t\tvar env1 = new Envelope(this.inputLines[1][0], this.inputLines[1][1]);\n\t\treturn env0.contains(intPt) && env1.contains(intPt);\n\t},\n\tcomputeIntersection: function () {\n\t\tif (arguments.length === 3) {\n\t\t\tlet p = arguments[0], p1 = arguments[1], p2 = arguments[2];\n\t\t\tthis._isProper = false;\n\t\t\tif (Envelope.intersects(p1, p2, p)) {\n\t\t\t\tif (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {\n\t\t\t\t\tthis._isProper = true;\n\t\t\t\t\tif (p.equals(p1) || p.equals(p2)) {\n\t\t\t\t\t\tthis._isProper = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis.result = LineIntersector.POINT_INTERSECTION;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.result = LineIntersector.NO_INTERSECTION;\n\t\t} else return LineIntersector.prototype.computeIntersection.apply(this, arguments);\n\t},\n\tnormalizeToMinimum: function (n1, n2, n3, n4, normPt) {\n\t\tnormPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n\t\tnormPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n\t\tn1.x -= normPt.x;\n\t\tn1.y -= normPt.y;\n\t\tn2.x -= normPt.x;\n\t\tn2.y -= normPt.y;\n\t\tn3.x -= normPt.x;\n\t\tn3.y -= normPt.y;\n\t\tn4.x -= normPt.x;\n\t\tn4.y -= normPt.y;\n\t},\n\tsafeHCoordinateIntersection: function (p1, p2, q1, q2) {\n\t\tvar intPt = null;\n\t\ttry {\n\t\t\tintPt = HCoordinate.intersection(p1, p2, q1, q2);\n\t\t} catch (e) {\n\t\t\tif (e instanceof NotRepresentableException) {\n\t\t\t\tintPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n\t\t\t} else throw e;\n\t\t} finally {}\n\t\treturn intPt;\n\t},\n\tintersection: function (p1, p2, q1, q2) {\n\t\tvar intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n\t\tif (!this.isInSegmentEnvelopes(intPt)) {\n\t\t\tintPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n\t\t}\n\t\tif (this.precisionModel !== null) {\n\t\t\tthis.precisionModel.makePrecise(intPt);\n\t\t}\n\t\treturn intPt;\n\t},\n\tsmallestInAbsValue: function (x1, x2, x3, x4) {\n\t\tvar x = x1;\n\t\tvar xabs = Math.abs(x);\n\t\tif (Math.abs(x2) < xabs) {\n\t\t\tx = x2;\n\t\t\txabs = Math.abs(x2);\n\t\t}\n\t\tif (Math.abs(x3) < xabs) {\n\t\t\tx = x3;\n\t\t\txabs = Math.abs(x3);\n\t\t}\n\t\tif (Math.abs(x4) < xabs) {\n\t\t\tx = x4;\n\t\t}\n\t\treturn x;\n\t},\n\tcheckDD: function (p1, p2, q1, q2, intPt) {\n\t\tvar intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n\t\tvar isIn = this.isInSegmentEnvelopes(intPtDD);\n\t\tSystem.out.println(\"DD in env = \" + isIn + \"  --------------------- \" + intPtDD);\n\t\tif (intPt.distance(intPtDD) > 0.0001) {\n\t\t\tSystem.out.println(\"Distance = \" + intPt.distance(intPtDD));\n\t\t}\n\t},\n\tintersectionWithNormalization: function (p1, p2, q1, q2) {\n\t\tvar n1 = new Coordinate(p1);\n\t\tvar n2 = new Coordinate(p2);\n\t\tvar n3 = new Coordinate(q1);\n\t\tvar n4 = new Coordinate(q2);\n\t\tvar normPt = new Coordinate();\n\t\tthis.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n\t\tvar intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n\t\tintPt.x += normPt.x;\n\t\tintPt.y += normPt.y;\n\t\treturn intPt;\n\t},\n\tcomputeCollinearIntersection: function (p1, p2, q1, q2) {\n\t\tvar p1q1p2 = Envelope.intersects(p1, p2, q1);\n\t\tvar p1q2p2 = Envelope.intersects(p1, p2, q2);\n\t\tvar q1p1q2 = Envelope.intersects(q1, q2, p1);\n\t\tvar q1p2q2 = Envelope.intersects(q1, q2, p2);\n\t\tif (p1q1p2 && p1q2p2) {\n\t\t\tthis.intPt[0] = q1;\n\t\t\tthis.intPt[1] = q2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (q1p1q2 && q1p2q2) {\n\t\t\tthis.intPt[0] = p1;\n\t\t\tthis.intPt[1] = p2;\n\t\t\treturn LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p1q2) {\n\t\t\tthis.intPt[0] = q1;\n\t\t\tthis.intPt[1] = p1;\n\t\t\treturn q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q1p2 && q1p2q2) {\n\t\t\tthis.intPt[0] = q1;\n\t\t\tthis.intPt[1] = p2;\n\t\t\treturn q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p1q2) {\n\t\t\tthis.intPt[0] = q2;\n\t\t\tthis.intPt[1] = p1;\n\t\t\treturn q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\tif (p1q2p2 && q1p2q2) {\n\t\t\tthis.intPt[0] = q2;\n\t\t\tthis.intPt[1] = p2;\n\t\t\treturn q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n\t\t}\n\t\treturn LineIntersector.NO_INTERSECTION;\n\t},\n\tnormalizeToEnvCentre: function (n00, n01, n10, n11, normPt) {\n\t\tvar minX0 = n00.x < n01.x ? n00.x : n01.x;\n\t\tvar minY0 = n00.y < n01.y ? n00.y : n01.y;\n\t\tvar maxX0 = n00.x > n01.x ? n00.x : n01.x;\n\t\tvar maxY0 = n00.y > n01.y ? n00.y : n01.y;\n\t\tvar minX1 = n10.x < n11.x ? n10.x : n11.x;\n\t\tvar minY1 = n10.y < n11.y ? n10.y : n11.y;\n\t\tvar maxX1 = n10.x > n11.x ? n10.x : n11.x;\n\t\tvar maxY1 = n10.y > n11.y ? n10.y : n11.y;\n\t\tvar intMinX = minX0 > minX1 ? minX0 : minX1;\n\t\tvar intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n\t\tvar intMinY = minY0 > minY1 ? minY0 : minY1;\n\t\tvar intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n\t\tvar intMidX = (intMinX + intMaxX) / 2.0;\n\t\tvar intMidY = (intMinY + intMaxY) / 2.0;\n\t\tnormPt.x = intMidX;\n\t\tnormPt.y = intMidY;\n\t\tn00.x -= normPt.x;\n\t\tn00.y -= normPt.y;\n\t\tn01.x -= normPt.x;\n\t\tn01.y -= normPt.y;\n\t\tn10.x -= normPt.x;\n\t\tn10.y -= normPt.y;\n\t\tn11.x -= normPt.x;\n\t\tn11.y -= normPt.y;\n\t},\n\tcomputeIntersect: function (p1, p2, q1, q2) {\n\t\tthis._isProper = false;\n\t\tif (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;\n\t\tvar Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);\n\t\tvar Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);\n\t\tif (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);\n\t\tvar Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);\n\t\tif (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {\n\t\t\treturn LineIntersector.NO_INTERSECTION;\n\t\t}\n\t\tvar collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n\t\tif (collinear) {\n\t\t\treturn this.computeCollinearIntersection(p1, p2, q1, q2);\n\t\t}\n\t\tif (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n\t\t\tthis._isProper = false;\n\t\t\tif (p1.equals2D(q1) || p1.equals2D(q2)) {\n\t\t\t\tthis.intPt[0] = p1;\n\t\t\t} else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n\t\t\t\tthis.intPt[0] = p2;\n\t\t\t} else if (Pq1 === 0) {\n\t\t\t\tthis.intPt[0] = new Coordinate(q1);\n\t\t\t} else if (Pq2 === 0) {\n\t\t\t\tthis.intPt[0] = new Coordinate(q2);\n\t\t\t} else if (Qp1 === 0) {\n\t\t\t\tthis.intPt[0] = new Coordinate(p1);\n\t\t\t} else if (Qp2 === 0) {\n\t\t\t\tthis.intPt[0] = new Coordinate(p2);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._isProper = true;\n\t\t\tthis.intPt[0] = this.intersection(p1, p2, q1, q2);\n\t\t}\n\t\treturn LineIntersector.POINT_INTERSECTION;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RobustLineIntersector;\n\t}\n});\nRobustLineIntersector.nearestEndpoint = function (p1, p2, q1, q2) {\n\tvar nearestPt = p1;\n\tvar minDist = CGAlgorithms.distancePointLine(p1, q1, q2);\n\tvar dist = CGAlgorithms.distancePointLine(p2, q1, q2);\n\tif (dist < minDist) {\n\t\tminDist = dist;\n\t\tnearestPt = p2;\n\t}\n\tdist = CGAlgorithms.distancePointLine(q1, p1, p2);\n\tif (dist < minDist) {\n\t\tminDist = dist;\n\t\tnearestPt = q1;\n\t}\n\tdist = CGAlgorithms.distancePointLine(q2, p1, p2);\n\tif (dist < minDist) {\n\t\tminDist = dist;\n\t\tnearestPt = q2;\n\t}\n\treturn nearestPt;\n};\n","import extend from '../../../../extend';\nexport default function RobustDeterminant() {}\nextend(RobustDeterminant.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RobustDeterminant;\n\t}\n});\nRobustDeterminant.orientationIndex = function (p1, p2, q) {\n\tvar dx1 = p2.x - p1.x;\n\tvar dy1 = p2.y - p1.y;\n\tvar dx2 = q.x - p2.x;\n\tvar dy2 = q.y - p2.y;\n\treturn RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);\n};\nRobustDeterminant.signOfDet2x2 = function (x1, y1, x2, y2) {\n\tvar sign = null;\n\tvar swap = null;\n\tvar k = null;\n\tvar count = 0;\n\tsign = 1;\n\tif (x1 === 0.0 || y2 === 0.0) {\n\t\tif (y1 === 0.0 || x2 === 0.0) {\n\t\t\treturn 0;\n\t\t} else if (y1 > 0) {\n\t\t\tif (x2 > 0) {\n\t\t\t\treturn -sign;\n\t\t\t} else {\n\t\t\t\treturn sign;\n\t\t\t}\n\t\t} else {\n\t\t\tif (x2 > 0) {\n\t\t\t\treturn sign;\n\t\t\t} else {\n\t\t\t\treturn -sign;\n\t\t\t}\n\t\t}\n\t}\n\tif (y1 === 0.0 || x2 === 0.0) {\n\t\tif (y2 > 0) {\n\t\t\tif (x1 > 0) {\n\t\t\t\treturn sign;\n\t\t\t} else {\n\t\t\t\treturn -sign;\n\t\t\t}\n\t\t} else {\n\t\t\tif (x1 > 0) {\n\t\t\t\treturn -sign;\n\t\t\t} else {\n\t\t\t\treturn sign;\n\t\t\t}\n\t\t}\n\t}\n\tif (0.0 < y1) {\n\t\tif (0.0 < y2) {\n\t\t\tif (y1 <= y2) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tsign = -sign;\n\t\t\t\tswap = x1;\n\t\t\t\tx1 = x2;\n\t\t\t\tx2 = swap;\n\t\t\t\tswap = y1;\n\t\t\t\ty1 = y2;\n\t\t\t\ty2 = swap;\n\t\t\t}\n\t\t} else {\n\t\t\tif (y1 <= -y2) {\n\t\t\t\tsign = -sign;\n\t\t\t\tx2 = -x2;\n\t\t\t\ty2 = -y2;\n\t\t\t} else {\n\t\t\t\tswap = x1;\n\t\t\t\tx1 = -x2;\n\t\t\t\tx2 = swap;\n\t\t\t\tswap = y1;\n\t\t\t\ty1 = -y2;\n\t\t\t\ty2 = swap;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (0.0 < y2) {\n\t\t\tif (-y1 <= y2) {\n\t\t\t\tsign = -sign;\n\t\t\t\tx1 = -x1;\n\t\t\t\ty1 = -y1;\n\t\t\t} else {\n\t\t\t\tswap = -x1;\n\t\t\t\tx1 = x2;\n\t\t\t\tx2 = swap;\n\t\t\t\tswap = -y1;\n\t\t\t\ty1 = y2;\n\t\t\t\ty2 = swap;\n\t\t\t}\n\t\t} else {\n\t\t\tif (y1 >= y2) {\n\t\t\t\tx1 = -x1;\n\t\t\t\ty1 = -y1;\n\t\t\t\tx2 = -x2;\n\t\t\t\ty2 = -y2;\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\tsign = -sign;\n\t\t\t\tswap = -x1;\n\t\t\t\tx1 = -x2;\n\t\t\t\tx2 = swap;\n\t\t\t\tswap = -y1;\n\t\t\t\ty1 = -y2;\n\t\t\t\ty2 = swap;\n\t\t\t}\n\t\t}\n\t}\n\tif (0.0 < x1) {\n\t\tif (0.0 < x2) {\n\t\t\tif (x1 <= x2) {\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\treturn sign;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sign;\n\t\t}\n\t} else {\n\t\tif (0.0 < x2) {\n\t\t\treturn -sign;\n\t\t} else {\n\t\t\tif (x1 >= x2) {\n\t\t\t\tsign = -sign;\n\t\t\t\tx1 = -x1;\n\t\t\t\tx2 = -x2;\n\t\t\t\t;\n\t\t\t} else {\n\t\t\t\treturn -sign;\n\t\t\t}\n\t\t}\n\t}\n\twhile (true) {\n\t\tcount = count + 1;\n\t\tk = Math.floor(x2 / x1);\n\t\tx2 = x2 - k * x1;\n\t\ty2 = y2 - k * y1;\n\t\tif (y2 < 0.0) {\n\t\t\treturn -sign;\n\t\t}\n\t\tif (y2 > y1) {\n\t\t\treturn sign;\n\t\t}\n\t\tif (x1 > x2 + x2) {\n\t\t\tif (y1 < y2 + y2) {\n\t\t\t\treturn sign;\n\t\t\t}\n\t\t} else {\n\t\t\tif (y1 > y2 + y2) {\n\t\t\t\treturn -sign;\n\t\t\t} else {\n\t\t\t\tx2 = x1 - x2;\n\t\t\t\ty2 = y1 - y2;\n\t\t\t\tsign = -sign;\n\t\t\t}\n\t\t}\n\t\tif (y2 === 0.0) {\n\t\t\tif (x2 === 0.0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn -sign;\n\t\t\t}\n\t\t}\n\t\tif (x2 === 0.0) {\n\t\t\treturn sign;\n\t\t}\n\t\tk = Math.floor(x1 / x2);\n\t\tx1 = x1 - k * x2;\n\t\ty1 = y1 - k * y2;\n\t\tif (y1 < 0.0) {\n\t\t\treturn sign;\n\t\t}\n\t\tif (y1 > y2) {\n\t\t\treturn -sign;\n\t\t}\n\t\tif (x2 > x1 + x1) {\n\t\t\tif (y2 < y1 + y1) {\n\t\t\t\treturn -sign;\n\t\t\t}\n\t\t} else {\n\t\t\tif (y2 > y1 + y1) {\n\t\t\t\treturn sign;\n\t\t\t} else {\n\t\t\t\tx1 = x2 - x1;\n\t\t\t\ty1 = y2 - y1;\n\t\t\t\tsign = -sign;\n\t\t\t}\n\t\t}\n\t\tif (y1 === 0.0) {\n\t\t\tif (x1 === 0.0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn sign;\n\t\t\t}\n\t\t}\n\t\tif (x1 === 0.0) {\n\t\t\treturn -sign;\n\t\t}\n\t}\n};\n","import Location from '../geom/Location';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nimport RobustDeterminant from './RobustDeterminant';\nexport default function RayCrossingCounter() {\n\tthis.p = null;\n\tthis.crossingCount = 0;\n\tthis.isPointOnSegment = false;\n\tlet p = arguments[0];\n\tthis.p = p;\n}\nextend(RayCrossingCounter.prototype, {\n\tcountSegment: function (p1, p2) {\n\t\tif (p1.x < this.p.x && p2.x < this.p.x) return null;\n\t\tif (this.p.x === p2.x && this.p.y === p2.y) {\n\t\t\tthis.isPointOnSegment = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y === this.p.y && p2.y === this.p.y) {\n\t\t\tvar minx = p1.x;\n\t\t\tvar maxx = p2.x;\n\t\t\tif (minx > maxx) {\n\t\t\t\tminx = p2.x;\n\t\t\t\tmaxx = p1.x;\n\t\t\t}\n\t\t\tif (this.p.x >= minx && this.p.x <= maxx) {\n\t\t\t\tthis.isPointOnSegment = true;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tif (p1.y > this.p.y && p2.y <= this.p.y || p2.y > this.p.y && p1.y <= this.p.y) {\n\t\t\tvar x1 = p1.x - this.p.x;\n\t\t\tvar y1 = p1.y - this.p.y;\n\t\t\tvar x2 = p2.x - this.p.x;\n\t\t\tvar y2 = p2.y - this.p.y;\n\t\t\tvar xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);\n\t\t\tif (xIntSign === 0.0) {\n\t\t\t\tthis.isPointOnSegment = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (y2 < y1) xIntSign = -xIntSign;\n\t\t\tif (xIntSign > 0.0) {\n\t\t\t\tthis.crossingCount++;\n\t\t\t}\n\t\t}\n\t},\n\tisPointInPolygon: function () {\n\t\treturn this.getLocation() !== Location.EXTERIOR;\n\t},\n\tgetLocation: function () {\n\t\tif (this.isPointOnSegment) return Location.BOUNDARY;\n\t\tif (this.crossingCount % 2 === 1) {\n\t\t\treturn Location.INTERIOR;\n\t\t}\n\t\treturn Location.EXTERIOR;\n\t},\n\tisOnSegment: function () {\n\t\treturn this.isPointOnSegment;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RayCrossingCounter;\n\t}\n});\nRayCrossingCounter.locatePointInRing = function () {\n\tif (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n\t\tlet p = arguments[0], ring = arguments[1];\n\t\tvar counter = new RayCrossingCounter(p);\n\t\tvar p1 = new Coordinate();\n\t\tvar p2 = new Coordinate();\n\t\tfor (var i = 1; i < ring.size(); i++) {\n\t\t\tring.getCoordinate(i, p1);\n\t\t\tring.getCoordinate(i - 1, p2);\n\t\t\tcounter.countSegment(p1, p2);\n\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t}\n\t\treturn counter.getLocation();\n\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n\t\tlet p = arguments[0], ring = arguments[1];\n\t\tvar counter = new RayCrossingCounter(p);\n\t\tfor (var i = 1; i < ring.length; i++) {\n\t\t\tvar p1 = ring[i];\n\t\t\tvar p2 = ring[i - 1];\n\t\t\tcounter.countSegment(p1, p2);\n\t\t\tif (counter.isOnSegment()) return counter.getLocation();\n\t\t}\n\t\treturn counter.getLocation();\n\t}\n};\n","import Location from '../geom/Location';\nimport hasInterface from '../../../../hasInterface';\nimport Coordinate from '../geom/Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport MathUtil from '../math/MathUtil';\nimport CGAlgorithmsDD from './CGAlgorithmsDD';\nimport CoordinateSequence from '../geom/CoordinateSequence';\nimport RobustLineIntersector from './RobustLineIntersector';\nimport Envelope from '../geom/Envelope';\nimport RayCrossingCounter from './RayCrossingCounter';\nexport default function CGAlgorithms() {}\nextend(CGAlgorithms.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CGAlgorithms;\n\t}\n});\nCGAlgorithms.orientationIndex = function (p1, p2, q) {\n\treturn CGAlgorithmsDD.orientationIndex(p1, p2, q);\n};\nCGAlgorithms.signedArea = function () {\n\tif (arguments[0] instanceof Array) {\n\t\tlet ring = arguments[0];\n\t\tif (ring.length < 3) return 0.0;\n\t\tvar sum = 0.0;\n\t\tvar x0 = ring[0].x;\n\t\tfor (var i = 1; i < ring.length - 1; i++) {\n\t\t\tvar x = ring[i].x - x0;\n\t\t\tvar y1 = ring[i + 1].y;\n\t\t\tvar y2 = ring[i - 1].y;\n\t\t\tsum += x * (y2 - y1);\n\t\t}\n\t\treturn sum / 2.0;\n\t} else if (hasInterface(arguments[0], CoordinateSequence)) {\n\t\tlet ring = arguments[0];\n\t\tvar n = ring.size();\n\t\tif (n < 3) return 0.0;\n\t\tvar p0 = new Coordinate();\n\t\tvar p1 = new Coordinate();\n\t\tvar p2 = new Coordinate();\n\t\tring.getCoordinate(0, p1);\n\t\tring.getCoordinate(1, p2);\n\t\tvar x0 = p1.x;\n\t\tp2.x -= x0;\n\t\tvar sum = 0.0;\n\t\tfor (var i = 1; i < n - 1; i++) {\n\t\t\tp0.y = p1.y;\n\t\t\tp1.x = p2.x;\n\t\t\tp1.y = p2.y;\n\t\t\tring.getCoordinate(i + 1, p2);\n\t\t\tp2.x -= x0;\n\t\t\tsum += p1.x * (p0.y - p2.y);\n\t\t}\n\t\treturn sum / 2.0;\n\t}\n};\nCGAlgorithms.distanceLineLine = function (A, B, C, D) {\n\tif (A.equals(B)) return CGAlgorithms.distancePointLine(A, C, D);\n\tif (C.equals(D)) return CGAlgorithms.distancePointLine(D, A, B);\n\tvar noIntersection = false;\n\tif (!Envelope.intersects(A, B, C, D)) {\n\t\tnoIntersection = true;\n\t} else {\n\t\tvar denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n\t\tif (denom === 0) {\n\t\t\tnoIntersection = true;\n\t\t} else {\n\t\t\tvar r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n\t\t\tvar s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n\t\t\tvar s = s_num / denom;\n\t\t\tvar r = r_num / denom;\n\t\t\tif (r < 0 || r > 1 || s < 0 || s > 1) {\n\t\t\t\tnoIntersection = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (noIntersection) {\n\t\treturn MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B));\n\t}\n\treturn 0.0;\n};\nCGAlgorithms.isPointInRing = function (p, ring) {\n\treturn CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;\n};\nCGAlgorithms.computeLength = function (pts) {\n\tvar n = pts.size();\n\tif (n <= 1) return 0.0;\n\tvar len = 0.0;\n\tvar p = new Coordinate();\n\tpts.getCoordinate(0, p);\n\tvar x0 = p.x;\n\tvar y0 = p.y;\n\tfor (var i = 1; i < n; i++) {\n\t\tpts.getCoordinate(i, p);\n\t\tvar x1 = p.x;\n\t\tvar y1 = p.y;\n\t\tvar dx = x1 - x0;\n\t\tvar dy = y1 - y0;\n\t\tlen += Math.sqrt(dx * dx + dy * dy);\n\t\tx0 = x1;\n\t\ty0 = y1;\n\t}\n\treturn len;\n};\nCGAlgorithms.isCCW = function (ring) {\n\tvar nPts = ring.length - 1;\n\tif (nPts < 3) throw new IllegalArgumentException(\"Ring has fewer than 4 points, so orientation cannot be determined\");\n\tvar hiPt = ring[0];\n\tvar hiIndex = 0;\n\tfor (var i = 1; i <= nPts; i++) {\n\t\tvar p = ring[i];\n\t\tif (p.y > hiPt.y) {\n\t\t\thiPt = p;\n\t\t\thiIndex = i;\n\t\t}\n\t}\n\tvar iPrev = hiIndex;\n\tdo {\n\t\tiPrev = iPrev - 1;\n\t\tif (iPrev < 0) iPrev = nPts;\n\t} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n\tvar iNext = hiIndex;\n\tdo {\n\t\tiNext = (iNext + 1) % nPts;\n\t} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n\tvar prev = ring[iPrev];\n\tvar next = ring[iNext];\n\tif (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n\tvar disc = CGAlgorithms.computeOrientation(prev, hiPt, next);\n\tvar isCCW = false;\n\tif (disc === 0) {\n\t\tisCCW = prev.x > next.x;\n\t} else {\n\t\tisCCW = disc > 0;\n\t}\n\treturn isCCW;\n};\nCGAlgorithms.locatePointInRing = function (p, ring) {\n\treturn RayCrossingCounter.locatePointInRing(p, ring);\n};\nCGAlgorithms.distancePointLinePerpendicular = function (p, A, B) {\n\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\treturn Math.abs(s) * Math.sqrt(len2);\n};\nCGAlgorithms.computeOrientation = function (p1, p2, q) {\n\treturn CGAlgorithms.orientationIndex(p1, p2, q);\n};\nCGAlgorithms.distancePointLine = function () {\n\tif (arguments.length === 2) {\n\t\tlet p = arguments[0], line = arguments[1];\n\t\tif (line.length === 0) throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\n\t\tvar minDistance = p.distance(line[0]);\n\t\tfor (var i = 0; i < line.length - 1; i++) {\n\t\t\tvar dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);\n\t\t\tif (dist < minDistance) {\n\t\t\t\tminDistance = dist;\n\t\t\t}\n\t\t}\n\t\treturn minDistance;\n\t} else if (arguments.length === 3) {\n\t\tlet p = arguments[0], A = arguments[1], B = arguments[2];\n\t\tif (A.x === B.x && A.y === B.y) return p.distance(A);\n\t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\t\tvar r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;\n\t\tif (r <= 0.0) return p.distance(A);\n\t\tif (r >= 1.0) return p.distance(B);\n\t\tvar s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n\t\treturn Math.abs(s) * Math.sqrt(len2);\n\t}\n};\nCGAlgorithms.isOnLine = function (p, pt) {\n\tvar lineIntersector = new RobustLineIntersector();\n\tfor (var i = 1; i < pt.length; i++) {\n\t\tvar p0 = pt[i - 1];\n\t\tvar p1 = pt[i];\n\t\tlineIntersector.computeIntersection(p, p0, p1);\n\t\tif (lineIntersector.hasIntersection()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\nCGAlgorithms.CLOCKWISE = -1;\nCGAlgorithms.RIGHT = CGAlgorithms.CLOCKWISE;\nCGAlgorithms.COUNTERCLOCKWISE = 1;\nCGAlgorithms.LEFT = CGAlgorithms.COUNTERCLOCKWISE;\nCGAlgorithms.COLLINEAR = 0;\nCGAlgorithms.STRAIGHT = CGAlgorithms.COLLINEAR;\n","import NotRepresentableException from '../algorithm/NotRepresentableException';\nimport CGAlgorithms from '../algorithm/CGAlgorithms';\nimport Coordinate from './Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nimport HCoordinate from '../algorithm/HCoordinate';\nimport Serializable from '../../../../java/io/Serializable';\nexport default function LineSegment() {\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tif (arguments.length === 0) {\n\t\tLineSegment.call(this, new Coordinate(), new Coordinate());\n\t} else if (arguments.length === 1) {\n\t\tlet ls = arguments[0];\n\t\tLineSegment.call(this, ls.p0, ls.p1);\n\t} else if (arguments.length === 2) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tthis.p0 = p0;\n\t\tthis.p1 = p1;\n\t} else if (arguments.length === 4) {\n\t\tlet x0 = arguments[0], y0 = arguments[1], x1 = arguments[2], y1 = arguments[3];\n\t\tLineSegment.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));\n\t}\n}\nextend(LineSegment.prototype, {\n\tminX: function () {\n\t\treturn Math.min(this.p0.x, this.p1.x);\n\t},\n\torientationIndex: function () {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tvar orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);\n\t\t\tvar orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);\n\t\t\tif (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);\n\t\t\tif (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);\n\t\t\treturn 0;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn CGAlgorithms.orientationIndex(this.p0, this.p1, p);\n\t\t}\n\t},\n\ttoGeometry: function (geomFactory) {\n\t\treturn geomFactory.createLineString([this.p0, this.p1]);\n\t},\n\tisVertical: function () {\n\t\treturn this.p0.x === this.p1.x;\n\t},\n\tequals: function (o) {\n\t\tif (!(o instanceof LineSegment)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar other = o;\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1);\n\t},\n\tintersection: function (line) {\n\t\tvar li = new RobustLineIntersector();\n\t\tli.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n\t\tif (li.hasIntersection()) return li.getIntersection(0);\n\t\treturn null;\n\t},\n\tproject: function () {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tif (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);\n\t\t\tvar r = this.projectionFactor(p);\n\t\t\tvar coord = new Coordinate();\n\t\t\tcoord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n\t\t\tcoord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n\t\t\treturn coord;\n\t\t} else if (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tvar pf0 = this.projectionFactor(seg.p0);\n\t\t\tvar pf1 = this.projectionFactor(seg.p1);\n\t\t\tif (pf0 >= 1.0 && pf1 >= 1.0) return null;\n\t\t\tif (pf0 <= 0.0 && pf1 <= 0.0) return null;\n\t\t\tvar newp0 = this.project(seg.p0);\n\t\t\tif (pf0 < 0.0) newp0 = this.p0;\n\t\t\tif (pf0 > 1.0) newp0 = this.p1;\n\t\t\tvar newp1 = this.project(seg.p1);\n\t\t\tif (pf1 < 0.0) newp1 = this.p0;\n\t\t\tif (pf1 > 1.0) newp1 = this.p1;\n\t\t\treturn new LineSegment(newp0, newp1);\n\t\t}\n\t},\n\tnormalize: function () {\n\t\tif (this.p1.compareTo(this.p0) < 0) this.reverse();\n\t},\n\tangle: function () {\n\t\treturn Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n\t},\n\tgetCoordinate: function (i) {\n\t\tif (i === 0) return this.p0;\n\t\treturn this.p1;\n\t},\n\tdistancePerpendicular: function (p) {\n\t\treturn CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1);\n\t},\n\tminY: function () {\n\t\treturn Math.min(this.p0.y, this.p1.y);\n\t},\n\tmidPoint: function () {\n\t\treturn LineSegment.midPoint(this.p0, this.p1);\n\t},\n\tprojectionFactor: function (p) {\n\t\tif (p.equals(this.p0)) return 0.0;\n\t\tif (p.equals(this.p1)) return 1.0;\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = dx * dx + dy * dy;\n\t\tif (len <= 0.0) return Double.NaN;\n\t\tvar r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n\t\treturn r;\n\t},\n\tclosestPoints: function (line) {\n\t\tvar intPt = this.intersection(line);\n\t\tif (intPt !== null) {\n\t\t\treturn [intPt, intPt];\n\t\t}\n\t\tvar closestPt = new Array(2).fill(null);\n\t\tvar minDistance = Double.MAX_VALUE;\n\t\tvar dist = null;\n\t\tvar close00 = this.closestPoint(line.p0);\n\t\tminDistance = close00.distance(line.p0);\n\t\tclosestPt[0] = close00;\n\t\tclosestPt[1] = line.p0;\n\t\tvar close01 = this.closestPoint(line.p1);\n\t\tdist = close01.distance(line.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = close01;\n\t\t\tclosestPt[1] = line.p1;\n\t\t}\n\t\tvar close10 = line.closestPoint(this.p0);\n\t\tdist = close10.distance(this.p0);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p0;\n\t\t\tclosestPt[1] = close10;\n\t\t}\n\t\tvar close11 = line.closestPoint(this.p1);\n\t\tdist = close11.distance(this.p1);\n\t\tif (dist < minDistance) {\n\t\t\tminDistance = dist;\n\t\t\tclosestPt[0] = this.p1;\n\t\t\tclosestPt[1] = close11;\n\t\t}\n\t\treturn closestPt;\n\t},\n\tclosestPoint: function (p) {\n\t\tvar factor = this.projectionFactor(p);\n\t\tif (factor > 0 && factor < 1) {\n\t\t\treturn this.project(p);\n\t\t}\n\t\tvar dist0 = this.p0.distance(p);\n\t\tvar dist1 = this.p1.distance(p);\n\t\tif (dist0 < dist1) return this.p0;\n\t\treturn this.p1;\n\t},\n\tmaxX: function () {\n\t\treturn Math.max(this.p0.x, this.p1.x);\n\t},\n\tgetLength: function () {\n\t\treturn this.p0.distance(this.p1);\n\t},\n\tcompareTo: function (o) {\n\t\tvar other = o;\n\t\tvar comp0 = this.p0.compareTo(other.p0);\n\t\tif (comp0 !== 0) return comp0;\n\t\treturn this.p1.compareTo(other.p1);\n\t},\n\treverse: function () {\n\t\tvar temp = this.p0;\n\t\tthis.p0 = this.p1;\n\t\tthis.p1 = temp;\n\t},\n\tequalsTopo: function (other) {\n\t\treturn this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);\n\t},\n\tlineIntersection: function (line) {\n\t\ttry {\n\t\t\tvar intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n\t\t\treturn intPt;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof NotRepresentableException) {} else throw ex;\n\t\t} finally {}\n\t\treturn null;\n\t},\n\tmaxY: function () {\n\t\treturn Math.max(this.p0.y, this.p1.y);\n\t},\n\tpointAlongOffset: function (segmentLengthFraction, offsetDistance) {\n\t\tvar segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tvar segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\tvar dx = this.p1.x - this.p0.x;\n\t\tvar dy = this.p1.y - this.p0.y;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar ux = 0.0;\n\t\tvar uy = 0.0;\n\t\tif (offsetDistance !== 0.0) {\n\t\t\tif (len <= 0.0) throw new IllegalStateException(\"Cannot compute offset from zero-length line segment\");\n\t\t\tux = offsetDistance * dx / len;\n\t\t\tuy = offsetDistance * dy / len;\n\t\t}\n\t\tvar offsetx = segx - uy;\n\t\tvar offsety = segy + ux;\n\t\tvar coord = new Coordinate(offsetx, offsety);\n\t\treturn coord;\n\t},\n\tsetCoordinates: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet ls = arguments[0];\n\t\t\tthis.setCoordinates(ls.p0, ls.p1);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\t\tthis.p0.x = p0.x;\n\t\t\tthis.p0.y = p0.y;\n\t\t\tthis.p1.x = p1.x;\n\t\t\tthis.p1.y = p1.y;\n\t\t}\n\t},\n\tsegmentFraction: function (inputPt) {\n\t\tvar segFrac = this.projectionFactor(inputPt);\n\t\tif (segFrac < 0.0) segFrac = 0.0; else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;\n\t\treturn segFrac;\n\t},\n\ttoString: function () {\n\t\treturn \"LINESTRING( \" + this.p0.x + \" \" + this.p0.y + \", \" + this.p1.x + \" \" + this.p1.y + \")\";\n\t},\n\tisHorizontal: function () {\n\t\treturn this.p0.y === this.p1.y;\n\t},\n\tdistance: function () {\n\t\tif (arguments[0] instanceof LineSegment) {\n\t\t\tlet ls = arguments[0];\n\t\t\treturn CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn CGAlgorithms.distancePointLine(p, this.p0, this.p1);\n\t\t}\n\t},\n\tpointAlong: function (segmentLengthFraction) {\n\t\tvar coord = new Coordinate();\n\t\tcoord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n\t\tcoord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n\t\treturn coord;\n\t},\n\thashCode: function () {\n\t\tvar bits0 = java.lang.Double.doubleToLongBits(this.p0.x);\n\t\tbits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;\n\t\tvar hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n\t\tvar bits1 = java.lang.Double.doubleToLongBits(this.p1.x);\n\t\tbits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;\n\t\tvar hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n\t\treturn hash0 ^ hash1;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn LineSegment;\n\t}\n});\nLineSegment.midPoint = function (p0, p1) {\n\treturn new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n};\nLineSegment.serialVersionUID = 3252005833466256227;\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from './Location';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport Dimension from './Dimension';\nimport Cloneable from '../../../../java/lang/Cloneable';\nexport default function IntersectionMatrix() {\n\tthis.matrix = null;\n\tif (arguments.length === 0) {\n\t\tthis.matrix = Array(3).fill().map(() => Array(3));\n\t\tthis.setAll(Dimension.FALSE);\n\t} else if (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tlet elements = arguments[0];\n\t\t\tIntersectionMatrix.call(this);\n\t\t\tthis.set(elements);\n\t\t} else if (arguments[0] instanceof IntersectionMatrix) {\n\t\t\tlet other = arguments[0];\n\t\t\tIntersectionMatrix.call(this);\n\t\t\tthis.matrix[Location.INTERIOR][Location.INTERIOR] = other.matrix[Location.INTERIOR][Location.INTERIOR];\n\t\t\tthis.matrix[Location.INTERIOR][Location.BOUNDARY] = other.matrix[Location.INTERIOR][Location.BOUNDARY];\n\t\t\tthis.matrix[Location.INTERIOR][Location.EXTERIOR] = other.matrix[Location.INTERIOR][Location.EXTERIOR];\n\t\t\tthis.matrix[Location.BOUNDARY][Location.INTERIOR] = other.matrix[Location.BOUNDARY][Location.INTERIOR];\n\t\t\tthis.matrix[Location.BOUNDARY][Location.BOUNDARY] = other.matrix[Location.BOUNDARY][Location.BOUNDARY];\n\t\t\tthis.matrix[Location.BOUNDARY][Location.EXTERIOR] = other.matrix[Location.BOUNDARY][Location.EXTERIOR];\n\t\t\tthis.matrix[Location.EXTERIOR][Location.INTERIOR] = other.matrix[Location.EXTERIOR][Location.INTERIOR];\n\t\t\tthis.matrix[Location.EXTERIOR][Location.BOUNDARY] = other.matrix[Location.EXTERIOR][Location.BOUNDARY];\n\t\t\tthis.matrix[Location.EXTERIOR][Location.EXTERIOR] = other.matrix[Location.EXTERIOR][Location.EXTERIOR];\n\t\t}\n\t}\n}\nextend(IntersectionMatrix.prototype, {\n\tisIntersects: function () {\n\t\treturn !this.isDisjoint();\n\t},\n\tisCovers: function () {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this.matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this.matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this.matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this.matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\tisCoveredBy: function () {\n\t\tvar hasPointInCommon = IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this.matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this.matrix[Location.BOUNDARY][Location.BOUNDARY]);\n\t\treturn hasPointInCommon && this.matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this.matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t},\n\tset: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet dimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < dimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis.matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet row = arguments[0], column = arguments[1], dimensionValue = arguments[2];\n\t\t\tthis.matrix[row][column] = dimensionValue;\n\t\t}\n\t},\n\tisContains: function () {\n\t\treturn IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.INTERIOR]) && this.matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this.matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\tsetAtLeast: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet minimumDimensionSymbols = arguments[0];\n\t\t\tfor (var i = 0; i < minimumDimensionSymbols.length; i++) {\n\t\t\t\tvar row = Math.trunc(i / 3);\n\t\t\t\tvar col = i % 3;\n\t\t\t\tthis.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet row = arguments[0], column = arguments[1], minimumDimensionValue = arguments[2];\n\t\t\tif (this.matrix[row][column] < minimumDimensionValue) {\n\t\t\t\tthis.matrix[row][column] = minimumDimensionValue;\n\t\t\t}\n\t\t}\n\t},\n\tsetAtLeastIfValid: function (row, column, minimumDimensionValue) {\n\t\tif (row >= 0 && column >= 0) {\n\t\t\tthis.setAtLeast(row, column, minimumDimensionValue);\n\t\t}\n\t},\n\tisWithin: function () {\n\t\treturn IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.INTERIOR]) && this.matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this.matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n\t},\n\tisTouches: function (dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA > dimensionOfGeometryB) {\n\t\t\treturn this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this.matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this.matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this.matrix[Location.BOUNDARY][Location.BOUNDARY]));\n\t\t}\n\t\treturn false;\n\t},\n\tisOverlaps: function (dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this.matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this.matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this.matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\treturn false;\n\t},\n\tisEquals: function (dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA !== dimensionOfGeometryB) {\n\t\t\treturn false;\n\t\t}\n\t\treturn IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.INTERIOR]) && this.matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this.matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this.matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this.matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\ttoString: function () {\n\t\tvar buf = new StringBuffer(\"123456789\");\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tbuf.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this.matrix[ai][bi]));\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t},\n\tsetAll: function (dimensionValue) {\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tthis.matrix[ai][bi] = dimensionValue;\n\t\t\t}\n\t\t}\n\t},\n\tget: function (row, column) {\n\t\treturn this.matrix[row][column];\n\t},\n\ttranspose: function () {\n\t\tvar temp = this.matrix[1][0];\n\t\tthis.matrix[1][0] = this.matrix[0][1];\n\t\tthis.matrix[0][1] = temp;\n\t\ttemp = this.matrix[2][0];\n\t\tthis.matrix[2][0] = this.matrix[0][2];\n\t\tthis.matrix[0][2] = temp;\n\t\ttemp = this.matrix[2][1];\n\t\tthis.matrix[2][1] = this.matrix[1][2];\n\t\tthis.matrix[1][2] = temp;\n\t\treturn this;\n\t},\n\tmatches: function (requiredDimensionSymbols) {\n\t\tif (requiredDimensionSymbols.length !== 9) {\n\t\t\tthrow new IllegalArgumentException(\"Should be length 9: \" + requiredDimensionSymbols);\n\t\t}\n\t\tfor (var ai = 0; ai < 3; ai++) {\n\t\t\tfor (var bi = 0; bi < 3; bi++) {\n\t\t\t\tif (!IntersectionMatrix.matches(this.matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tadd: function (im) {\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\tthis.setAtLeast(i, j, im.get(i, j));\n\t\t\t}\n\t\t}\n\t},\n\tisDisjoint: function () {\n\t\treturn this.matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this.matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this.matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this.matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;\n\t},\n\tisCrosses: function (dimensionOfGeometryA, dimensionOfGeometryB) {\n\t\tif (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {\n\t\t\treturn IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.EXTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn IntersectionMatrix.isTrue(this.matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this.matrix[Location.EXTERIOR][Location.INTERIOR]);\n\t\t}\n\t\tif (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {\n\t\t\treturn this.matrix[Location.INTERIOR][Location.INTERIOR] === 0;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Cloneable];\n\t},\n\tgetClass: function () {\n\t\treturn IntersectionMatrix;\n\t}\n});\nIntersectionMatrix.matches = function () {\n\tif (Number.isInteger(arguments[0]) && typeof arguments[1] === \"string\") {\n\t\tlet actualDimensionValue = arguments[0], requiredDimensionSymbol = arguments[1];\n\t\tif (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {\n\t\t\treturn true;\n\t\t}\n\t\tif (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t} else if (typeof arguments[0] === \"string\" && typeof arguments[1] === \"string\") {\n\t\tlet actualDimensionSymbols = arguments[0], requiredDimensionSymbols = arguments[1];\n\t\tvar m = new IntersectionMatrix(actualDimensionSymbols);\n\t\treturn m.matches(requiredDimensionSymbols);\n\t}\n};\nIntersectionMatrix.isTrue = function (actualDimensionValue) {\n\tif (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n","import LineString from '../geom/LineString';\nimport CGAlgorithms from './CGAlgorithms';\nimport Geometry from '../geom/Geometry';\nimport Coordinate from '../geom/Coordinate';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport extend from '../../../../extend';\nimport GeometryCollection from '../geom/GeometryCollection';\nexport default function Centroid() {\n\tthis.areaBasePt = null;\n\tthis.triangleCent3 = new Coordinate();\n\tthis.areasum2 = 0;\n\tthis.cg3 = new Coordinate();\n\tthis.lineCentSum = new Coordinate();\n\tthis.totalLength = 0.0;\n\tthis.ptCount = 0;\n\tthis.ptCentSum = new Coordinate();\n\tlet geom = arguments[0];\n\tthis.areaBasePt = null;\n\tthis.add(geom);\n}\nextend(Centroid.prototype, {\n\taddPoint: function (pt) {\n\t\tthis.ptCount += 1;\n\t\tthis.ptCentSum.x += pt.x;\n\t\tthis.ptCentSum.y += pt.y;\n\t},\n\tsetBasePoint: function (basePt) {\n\t\tif (this.areaBasePt === null) this.areaBasePt = basePt;\n\t},\n\taddLineSegments: function (pts) {\n\t\tvar lineLen = 0.0;\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tvar segmentLen = pts[i].distance(pts[i + 1]);\n\t\t\tif (segmentLen === 0.0) continue;\n\t\t\tlineLen += segmentLen;\n\t\t\tvar midx = (pts[i].x + pts[i + 1].x) / 2;\n\t\t\tthis.lineCentSum.x += segmentLen * midx;\n\t\t\tvar midy = (pts[i].y + pts[i + 1].y) / 2;\n\t\t\tthis.lineCentSum.y += segmentLen * midy;\n\t\t}\n\t\tthis.totalLength += lineLen;\n\t\tif (lineLen === 0.0 && pts.length > 0) this.addPoint(pts[0]);\n\t},\n\taddHole: function (pts) {\n\t\tvar isPositiveArea = CGAlgorithms.isCCW(pts);\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tthis.addTriangle(this.areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n\t\t}\n\t\tthis.addLineSegments(pts);\n\t},\n\tgetCentroid: function () {\n\t\tvar cent = new Coordinate();\n\t\tif (Math.abs(this.areasum2) > 0.0) {\n\t\t\tcent.x = this.cg3.x / 3 / this.areasum2;\n\t\t\tcent.y = this.cg3.y / 3 / this.areasum2;\n\t\t} else if (this.totalLength > 0.0) {\n\t\t\tcent.x = this.lineCentSum.x / this.totalLength;\n\t\t\tcent.y = this.lineCentSum.y / this.totalLength;\n\t\t} else if (this.ptCount > 0) {\n\t\t\tcent.x = this.ptCentSum.x / this.ptCount;\n\t\t\tcent.y = this.ptCentSum.y / this.ptCount;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\treturn cent;\n\t},\n\taddShell: function (pts) {\n\t\tif (pts.length > 0) this.setBasePoint(pts[0]);\n\t\tvar isPositiveArea = !CGAlgorithms.isCCW(pts);\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tthis.addTriangle(this.areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n\t\t}\n\t\tthis.addLineSegments(pts);\n\t},\n\taddTriangle: function (p0, p1, p2, isPositiveArea) {\n\t\tvar sign = isPositiveArea ? 1.0 : -1.0;\n\t\tCentroid.centroid3(p0, p1, p2, this.triangleCent3);\n\t\tvar area2 = Centroid.area2(p0, p1, p2);\n\t\tthis.cg3.x += sign * area2 * this.triangleCent3.x;\n\t\tthis.cg3.y += sign * area2 * this.triangleCent3.y;\n\t\tthis.areasum2 += sign * area2;\n\t},\n\tadd: function () {\n\t\tif (arguments[0] instanceof Polygon) {\n\t\t\tlet poly = arguments[0];\n\t\t\tthis.addShell(poly.getExteriorRing().getCoordinates());\n\t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\t\tthis.addHole(poly.getInteriorRingN(i).getCoordinates());\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tlet geom = arguments[0];\n\t\t\tif (geom.isEmpty()) return null;\n\t\t\tif (geom instanceof Point) {\n\t\t\t\tthis.addPoint(geom.getCoordinate());\n\t\t\t} else if (geom instanceof LineString) {\n\t\t\t\tthis.addLineSegments(geom.getCoordinates());\n\t\t\t} else if (geom instanceof Polygon) {\n\t\t\t\tvar poly = geom;\n\t\t\t\tthis.add(poly);\n\t\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\t\tvar gc = geom;\n\t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\t\tthis.add(gc.getGeometryN(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Centroid;\n\t}\n});\nCentroid.area2 = function (p1, p2, p3) {\n\treturn (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);\n};\nCentroid.centroid3 = function (p1, p2, p3, c) {\n\tc.x = p1.x + p2.x + p3.x;\n\tc.y = p1.y + p2.y + p3.y;\n\treturn null;\n};\nCentroid.getCentroid = function (geom) {\n\tvar cent = new Centroid(geom);\n\treturn cent.getCentroid();\n};\n","/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nexport default function EmptyStackException(message) {\n  this.message = message || '';\n};\nEmptyStackException.prototype = new Error();\n\n\n/**\n * @type {string}\n */\nEmptyStackException.prototype.name = 'EmptyStackException';\n","import EmptyStackException from './EmptyStackException'\nimport List from './List'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n *\n * @extends {List}\n * @constructor\n * @private\n */\nexport default function Stack() {\n  /**\n   * @type {Array}\n   * @private\n   */\n  this.array_ = [];\n};\nStack.prototype = new List();\n\n\n/**\n * @override\n */\nStack.prototype.add = function(e) {\n  this.array_.push(e);\n  return true;\n};\n\n\n/**\n * @override\n */\nStack.prototype.get = function(index) {\n  if (index < 0 || index >= this.size()) {\n    throw new IndexOutOfBoundsException();\n  }\n\n  return this.array_[index];\n};\n\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack.prototype.push = function(e) {\n  this.array_.push(e);\n  return e;\n};\n\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack.prototype.pop = function(e) {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException();\n  }\n\n  return this.array_.pop();\n};\n\n\n/**\n * Looks at the object at the top of this stack without removing it from the\n * stack.\n * @return {Object}\n */\nStack.prototype.peek = function() {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException();\n  }\n\n  return this.array_[this.array_.length - 1];\n};\n\n\n/**\n * Tests if this stack is empty.\n * @return {boolean} true if and only if this stack contains no items; false\n *         otherwise.\n */\nStack.prototype.empty = function() {\n  if (this.array_.length === 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\n\n/**\n * @return {boolean}\n */\nStack.prototype.isEmpty = function() {\n  return this.empty();\n};\n\n\n/**\n * Returns the 1-based position where an object is on this stack. If the object\n * o occurs as an item in this stack, this method returns the distance from the\n * top of the stack of the occurrence nearest the top of the stack; the topmost\n * item on the stack is considered to be at distance 1. The equals method is\n * used to compare o to the items in this stack.\n *\n * NOTE: does not currently actually use equals. (=== is used)\n *\n * @param {Object} o\n * @return {number} the 1-based position from the top of the stack where the\n *         object is located; the return value -1 indicates that the object is\n *         not on the stack.\n */\nStack.prototype.search = function(o) {\n  return this.array_.indexOf(o);\n};\n\n\n/**\n * @return {number}\n * @export\n */\nStack.prototype.size = function() {\n  return this.array_.length;\n};\n\n\n/**\n * @return {Array}\n */\nStack.prototype.toArray = function() {\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this.array_[i]);\n  }\n\n  return array;\n};\n","import TreeSet from '../../../../java/util/TreeSet';\nimport CoordinateFilter from '../geom/CoordinateFilter';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function UniqueCoordinateArrayFilter() {\n\tthis.treeSet = new TreeSet();\n\tthis.list = new ArrayList();\n}\nextend(UniqueCoordinateArrayFilter.prototype, {\n\tfilter: function (coord) {\n\t\tif (!this.treeSet.contains(coord)) {\n\t\t\tthis.list.add(coord);\n\t\t\tthis.treeSet.add(coord);\n\t\t}\n\t},\n\tgetCoordinates: function () {\n\t\tvar coordinates = new Array(this.list.size()).fill(null);\n\t\treturn this.list.toArray(coordinates);\n\t},\n\tinterfaces_: function () {\n\t\treturn [CoordinateFilter];\n\t},\n\tgetClass: function () {\n\t\treturn UniqueCoordinateArrayFilter;\n\t}\n});\nUniqueCoordinateArrayFilter.filterCoordinates = function (coords) {\n\tvar filter = new UniqueCoordinateArrayFilter();\n\tfor (var i = 0; i < coords.length; i++) {\n\t\tfilter.filter(coords[i]);\n\t}\n\treturn filter.getCoordinates();\n};\n","import TreeSet from '../../../../java/util/TreeSet';\nimport CGAlgorithms from './CGAlgorithms';\nimport CoordinateList from '../geom/CoordinateList';\nimport Arrays from '../../../../java/util/Arrays';\nimport Stack from '../../../../java/util/Stack';\nimport extend from '../../../../extend';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Comparator from '../../../../java/util/Comparator';\nimport UniqueCoordinateArrayFilter from '../util/UniqueCoordinateArrayFilter';\nimport Assert from '../util/Assert';\nexport default function ConvexHull() {\n\tthis.geomFactory = null;\n\tthis.inputPts = null;\n\tif (arguments.length === 1) {\n\t\tlet geometry = arguments[0];\n\t\tConvexHull.call(this, ConvexHull.extractCoordinates(geometry), geometry.getFactory());\n\t} else if (arguments.length === 2) {\n\t\tlet pts = arguments[0], geomFactory = arguments[1];\n\t\tthis.inputPts = UniqueCoordinateArrayFilter.filterCoordinates(pts);\n\t\tthis.geomFactory = geomFactory;\n\t}\n}\nextend(ConvexHull.prototype, {\n\tpreSort: function (pts) {\n\t\tvar t = null;\n\t\tfor (var i = 1; i < pts.length; i++) {\n\t\t\tif (pts[i].y < pts[0].y || pts[i].y === pts[0].y && pts[i].x < pts[0].x) {\n\t\t\t\tt = pts[0];\n\t\t\t\tpts[0] = pts[i];\n\t\t\t\tpts[i] = t;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(pts, 1, pts.length, new RadialComparator(pts[0]));\n\t\treturn pts;\n\t},\n\tcomputeOctRing: function (inputPts) {\n\t\tvar octPts = this.computeOctPts(inputPts);\n\t\tvar coordList = new CoordinateList();\n\t\tcoordList.add(octPts, false);\n\t\tif (coordList.size() < 3) {\n\t\t\treturn null;\n\t\t}\n\t\tcoordList.closeRing();\n\t\treturn coordList.toCoordinateArray();\n\t},\n\tlineOrPolygon: function (coordinates) {\n\t\tcoordinates = this.cleanRing(coordinates);\n\t\tif (coordinates.length === 3) {\n\t\t\treturn this.geomFactory.createLineString([coordinates[0], coordinates[1]]);\n\t\t}\n\t\tvar linearRing = this.geomFactory.createLinearRing(coordinates);\n\t\treturn this.geomFactory.createPolygon(linearRing, null);\n\t},\n\tcleanRing: function (original) {\n\t\tAssert.equals(original[0], original[original.length - 1]);\n\t\tvar cleanedRing = new ArrayList();\n\t\tvar previousDistinctCoordinate = null;\n\t\tfor (var i = 0; i <= original.length - 2; i++) {\n\t\t\tvar currentCoordinate = original[i];\n\t\t\tvar nextCoordinate = original[i + 1];\n\t\t\tif (currentCoordinate.equals(nextCoordinate)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (previousDistinctCoordinate !== null && this.isBetween(previousDistinctCoordinate, currentCoordinate, nextCoordinate)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcleanedRing.add(currentCoordinate);\n\t\t\tpreviousDistinctCoordinate = currentCoordinate;\n\t\t}\n\t\tcleanedRing.add(original[original.length - 1]);\n\t\tvar cleanedRingCoordinates = new Array(cleanedRing.size()).fill(null);\n\t\treturn cleanedRing.toArray(cleanedRingCoordinates);\n\t},\n\tisBetween: function (c1, c2, c3) {\n\t\tif (CGAlgorithms.computeOrientation(c1, c2, c3) !== 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (c1.x !== c3.x) {\n\t\t\tif (c1.x <= c2.x && c2.x <= c3.x) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (c3.x <= c2.x && c2.x <= c1.x) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (c1.y !== c3.y) {\n\t\t\tif (c1.y <= c2.y && c2.y <= c3.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (c3.y <= c2.y && c2.y <= c1.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\treduce: function (inputPts) {\n\t\tvar polyPts = this.computeOctRing(inputPts);\n\t\tif (polyPts === null) return inputPts;\n\t\tvar reducedSet = new TreeSet();\n\t\tfor (var i = 0; i < polyPts.length; i++) {\n\t\t\treducedSet.add(polyPts[i]);\n\t\t}\n\t\tfor (var i = 0; i < inputPts.length; i++) {\n\t\t\tif (!CGAlgorithms.isPointInRing(inputPts[i], polyPts)) {\n\t\t\t\treducedSet.add(inputPts[i]);\n\t\t\t}\n\t\t}\n\t\tvar reducedPts = CoordinateArrays.toCoordinateArray(reducedSet);\n\t\tif (reducedPts.length < 3) return this.padArray3(reducedPts);\n\t\treturn reducedPts;\n\t},\n\tgetConvexHull: function () {\n\t\tif (this.inputPts.length === 0) {\n\t\t\treturn this.geomFactory.createGeometryCollection(null);\n\t\t}\n\t\tif (this.inputPts.length === 1) {\n\t\t\treturn this.geomFactory.createPoint(this.inputPts[0]);\n\t\t}\n\t\tif (this.inputPts.length === 2) {\n\t\t\treturn this.geomFactory.createLineString(this.inputPts);\n\t\t}\n\t\tvar reducedPts = this.inputPts;\n\t\tif (this.inputPts.length > 50) {\n\t\t\treducedPts = this.reduce(this.inputPts);\n\t\t}\n\t\tvar sortedPts = this.preSort(reducedPts);\n\t\tvar cHS = this.grahamScan(sortedPts);\n\t\tvar cH = this.toCoordinateArray(cHS);\n\t\treturn this.lineOrPolygon(cH);\n\t},\n\tpadArray3: function (pts) {\n\t\tvar pad = new Array(3).fill(null);\n\t\tfor (var i = 0; i < pad.length; i++) {\n\t\t\tif (i < pts.length) {\n\t\t\t\tpad[i] = pts[i];\n\t\t\t} else pad[i] = pts[0];\n\t\t}\n\t\treturn pad;\n\t},\n\tcomputeOctPts: function (inputPts) {\n\t\tvar pts = new Array(8).fill(null);\n\t\tfor (var j = 0; j < pts.length; j++) {\n\t\t\tpts[j] = inputPts[0];\n\t\t}\n\t\tfor (var i = 1; i < inputPts.length; i++) {\n\t\t\tif (inputPts[i].x < pts[0].x) {\n\t\t\t\tpts[0] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].x - inputPts[i].y < pts[1].x - pts[1].y) {\n\t\t\t\tpts[1] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].y > pts[2].y) {\n\t\t\t\tpts[2] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].x + inputPts[i].y > pts[3].x + pts[3].y) {\n\t\t\t\tpts[3] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].x > pts[4].x) {\n\t\t\t\tpts[4] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].x - inputPts[i].y > pts[5].x - pts[5].y) {\n\t\t\t\tpts[5] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].y < pts[6].y) {\n\t\t\t\tpts[6] = inputPts[i];\n\t\t\t}\n\t\t\tif (inputPts[i].x + inputPts[i].y < pts[7].x + pts[7].y) {\n\t\t\t\tpts[7] = inputPts[i];\n\t\t\t}\n\t\t}\n\t\treturn pts;\n\t},\n\ttoCoordinateArray: function (stack) {\n\t\tvar coordinates = new Array(stack.size()).fill(null);\n\t\tfor (var i = 0; i < stack.size(); i++) {\n\t\t\tvar coordinate = stack.get(i);\n\t\t\tcoordinates[i] = coordinate;\n\t\t}\n\t\treturn coordinates;\n\t},\n\tgrahamScan: function (c) {\n\t\tvar p = null;\n\t\tvar ps = new Stack();\n\t\tp = ps.push(c[0]);\n\t\tp = ps.push(c[1]);\n\t\tp = ps.push(c[2]);\n\t\tfor (var i = 3; i < c.length; i++) {\n\t\t\tp = ps.pop();\n\t\t\twhile (!ps.empty() && CGAlgorithms.computeOrientation(ps.peek(), p, c[i]) > 0) {\n\t\t\t\tp = ps.pop();\n\t\t\t}\n\t\t\tp = ps.push(p);\n\t\t\tp = ps.push(c[i]);\n\t\t}\n\t\tp = ps.push(c[0]);\n\t\treturn ps;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ConvexHull;\n\t}\n});\nConvexHull.extractCoordinates = function (geom) {\n\tvar filter = new UniqueCoordinateArrayFilter();\n\tgeom.apply(filter);\n\treturn filter.getCoordinates();\n};\nfunction RadialComparator() {\n\tthis.origin = null;\n\tlet origin = arguments[0];\n\tthis.origin = origin;\n}\nextend(RadialComparator.prototype, {\n\tcompare: function (o1, o2) {\n\t\tvar p1 = o1;\n\t\tvar p2 = o2;\n\t\treturn RadialComparator.polarCompare(this.origin, p1, p2);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function () {\n\t\treturn RadialComparator;\n\t}\n});\nRadialComparator.polarCompare = function (o, p, q) {\n\tvar dxp = p.x - o.x;\n\tvar dyp = p.y - o.y;\n\tvar dxq = q.x - o.x;\n\tvar dyq = q.y - o.y;\n\tvar orient = CGAlgorithms.computeOrientation(o, p, q);\n\tif (orient === CGAlgorithms.COUNTERCLOCKWISE) return 1;\n\tif (orient === CGAlgorithms.CLOCKWISE) return -1;\n\tvar op = dxp * dxp + dyp * dyp;\n\tvar oq = dxq * dxq + dyq * dyq;\n\tif (op < oq) {\n\t\treturn -1;\n\t}\n\tif (op > oq) {\n\t\treturn 1;\n\t}\n\treturn 0;\n};\nConvexHull.RadialComparator = RadialComparator;\n","import LineString from '../LineString';\nimport GeometryFactory from '../GeometryFactory';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport Point from '../Point';\nimport Polygon from '../Polygon';\nimport MultiPoint from '../MultiPoint';\nimport LinearRing from '../LinearRing';\nimport extend from '../../../../../extend';\nimport MultiPolygon from '../MultiPolygon';\nimport GeometryCollection from '../GeometryCollection';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport MultiLineString from '../MultiLineString';\nexport default function GeometryTransformer() {\n\tthis.inputGeom = null;\n\tthis.factory = null;\n\tthis.pruneEmptyGeometry = true;\n\tthis.preserveGeometryCollectionType = true;\n\tthis.preserveCollections = false;\n\tthis.preserveType = false;\n}\nextend(GeometryTransformer.prototype, {\n\ttransformPoint: function (geom, parent) {\n\t\treturn this.factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n\t},\n\ttransformPolygon: function (geom, parent) {\n\t\tvar isAllValidLinearRings = true;\n\t\tvar shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n\t\tif (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) isAllValidLinearRings = false;\n\t\tvar holes = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumInteriorRing(); i++) {\n\t\t\tvar hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);\n\t\t\tif (hole === null || hole.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(hole instanceof LinearRing)) isAllValidLinearRings = false;\n\t\t\tholes.add(hole);\n\t\t}\n\t\tif (isAllValidLinearRings) return this.factory.createPolygon(shell, holes.toArray([])); else {\n\t\t\tvar components = new ArrayList();\n\t\t\tif (shell !== null) components.add(shell);\n\t\t\tcomponents.addAll(holes);\n\t\t\treturn this.factory.buildGeometry(components);\n\t\t}\n\t},\n\tcreateCoordinateSequence: function (coords) {\n\t\treturn this.factory.getCoordinateSequenceFactory().create(coords);\n\t},\n\tgetInputGeometry: function () {\n\t\treturn this.inputGeom;\n\t},\n\ttransformMultiLineString: function (geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transformLineString(geom.getGeometryN(i), geom);\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\treturn this.factory.buildGeometry(transGeomList);\n\t},\n\ttransformCoordinates: function (coords, parent) {\n\t\treturn this.copy(coords);\n\t},\n\ttransformLineString: function (geom, parent) {\n\t\treturn this.factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n\t},\n\ttransformMultiPoint: function (geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transformPoint(geom.getGeometryN(i), geom);\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\treturn this.factory.buildGeometry(transGeomList);\n\t},\n\ttransformMultiPolygon: function (geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\treturn this.factory.buildGeometry(transGeomList);\n\t},\n\tcopy: function (seq) {\n\t\treturn seq.copy();\n\t},\n\ttransformGeometryCollection: function (geom, parent) {\n\t\tvar transGeomList = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar transformGeom = this.transform(geom.getGeometryN(i));\n\t\t\tif (transformGeom === null) continue;\n\t\t\tif (this.pruneEmptyGeometry && transformGeom.isEmpty()) continue;\n\t\t\ttransGeomList.add(transformGeom);\n\t\t}\n\t\tif (this.preserveGeometryCollectionType) return this.factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));\n\t\treturn this.factory.buildGeometry(transGeomList);\n\t},\n\ttransform: function (inputGeom) {\n\t\tthis.inputGeom = inputGeom;\n\t\tthis.factory = inputGeom.getFactory();\n\t\tif (inputGeom instanceof Point) return this.transformPoint(inputGeom, null);\n\t\tif (inputGeom instanceof MultiPoint) return this.transformMultiPoint(inputGeom, null);\n\t\tif (inputGeom instanceof LinearRing) return this.transformLinearRing(inputGeom, null);\n\t\tif (inputGeom instanceof LineString) return this.transformLineString(inputGeom, null);\n\t\tif (inputGeom instanceof MultiLineString) return this.transformMultiLineString(inputGeom, null);\n\t\tif (inputGeom instanceof Polygon) return this.transformPolygon(inputGeom, null);\n\t\tif (inputGeom instanceof MultiPolygon) return this.transformMultiPolygon(inputGeom, null);\n\t\tif (inputGeom instanceof GeometryCollection) return this.transformGeometryCollection(inputGeom, null);\n\t\tthrow new IllegalArgumentException(\"Unknown Geometry subtype: \" + inputGeom.getClass().getName());\n\t},\n\ttransformLinearRing: function (geom, parent) {\n\t\tvar seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n\t\tif (seq === null) return this.factory.createLinearRing(null);\n\t\tvar seqSize = seq.size();\n\t\tif (seqSize > 0 && seqSize < 4 && !this.preserveType) return this.factory.createLineString(seq);\n\t\treturn this.factory.createLinearRing(seq);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryTransformer;\n\t}\n});\n","import LineString from '../../../geom/LineString';\nimport CoordinateList from '../../../geom/CoordinateList';\nimport Coordinate from '../../../geom/Coordinate';\nimport Double from '../../../../../../java/lang/Double';\nimport extend from '../../../../../../extend';\nimport LineSegment from '../../../geom/LineSegment';\nexport default function LineStringSnapper() {\n\tthis.snapTolerance = 0.0;\n\tthis.srcPts = null;\n\tthis.seg = new LineSegment();\n\tthis.allowSnappingToSourceVertices = false;\n\tthis._isClosed = false;\n\tif (arguments[0] instanceof LineString && typeof arguments[1] === \"number\") {\n\t\tlet srcLine = arguments[0], snapTolerance = arguments[1];\n\t\tLineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);\n\t} else if (arguments[0] instanceof Array && typeof arguments[1] === \"number\") {\n\t\tlet srcPts = arguments[0], snapTolerance = arguments[1];\n\t\tthis.srcPts = srcPts;\n\t\tthis._isClosed = LineStringSnapper.isClosed(srcPts);\n\t\tthis.snapTolerance = snapTolerance;\n\t}\n}\nextend(LineStringSnapper.prototype, {\n\tsnapVertices: function (srcCoords, snapPts) {\n\t\tvar end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar srcPt = srcCoords.get(i);\n\t\t\tvar snapVert = this.findSnapForVertex(srcPt, snapPts);\n\t\t\tif (snapVert !== null) {\n\t\t\t\tsrcCoords.set(i, new Coordinate(snapVert));\n\t\t\t\tif (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));\n\t\t\t}\n\t\t}\n\t},\n\tfindSnapForVertex: function (pt, snapPts) {\n\t\tfor (var i = 0; i < snapPts.length; i++) {\n\t\t\tif (pt.equals2D(snapPts[i])) return null;\n\t\t\tif (pt.distance(snapPts[i]) < this.snapTolerance) return snapPts[i];\n\t\t}\n\t\treturn null;\n\t},\n\tsnapTo: function (snapPts) {\n\t\tvar coordList = new CoordinateList(this.srcPts);\n\t\tthis.snapVertices(coordList, snapPts);\n\t\tthis.snapSegments(coordList, snapPts);\n\t\tvar newPts = coordList.toCoordinateArray();\n\t\treturn newPts;\n\t},\n\tsnapSegments: function (srcCoords, snapPts) {\n\t\tif (snapPts.length === 0) return null;\n\t\tvar distinctPtCount = snapPts.length;\n\t\tif (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;\n\t\tfor (var i = 0; i < distinctPtCount; i++) {\n\t\t\tvar snapPt = snapPts[i];\n\t\t\tvar index = this.findSegmentIndexToSnap(snapPt, srcCoords);\n\t\t\tif (index >= 0) {\n\t\t\t\tsrcCoords.add(index + 1, new Coordinate(snapPt), false);\n\t\t\t}\n\t\t}\n\t},\n\tfindSegmentIndexToSnap: function (snapPt, srcCoords) {\n\t\tvar minDist = Double.MAX_VALUE;\n\t\tvar snapIndex = -1;\n\t\tfor (var i = 0; i < srcCoords.size() - 1; i++) {\n\t\t\tthis.seg.p0 = srcCoords.get(i);\n\t\t\tthis.seg.p1 = srcCoords.get(i + 1);\n\t\t\tif (this.seg.p0.equals2D(snapPt) || this.seg.p1.equals2D(snapPt)) {\n\t\t\t\tif (this.allowSnappingToSourceVertices) continue; else return -1;\n\t\t\t}\n\t\t\tvar dist = this.seg.distance(snapPt);\n\t\t\tif (dist < this.snapTolerance && dist < minDist) {\n\t\t\t\tminDist = dist;\n\t\t\t\tsnapIndex = i;\n\t\t\t}\n\t\t}\n\t\treturn snapIndex;\n\t},\n\tsetAllowSnappingToSourceVertices: function (allowSnappingToSourceVertices) {\n\t\tthis.allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineStringSnapper;\n\t}\n});\nLineStringSnapper.isClosed = function (pts) {\n\tif (pts.length <= 1) return false;\n\treturn pts[0].equals2D(pts[pts.length - 1]);\n};\n","import TreeSet from '../../../../../../java/util/TreeSet';\nimport GeometryTransformer from '../../../geom/util/GeometryTransformer';\nimport hasInterface from '../../../../../../hasInterface';\nimport Double from '../../../../../../java/lang/Double';\nimport extend from '../../../../../../extend';\nimport LineStringSnapper from './LineStringSnapper';\nimport PrecisionModel from '../../../geom/PrecisionModel';\nimport Polygonal from '../../../geom/Polygonal';\nimport inherits from '../../../../../../inherits';\nexport default function GeometrySnapper() {\n\tthis.srcGeom = null;\n\tlet srcGeom = arguments[0];\n\tthis.srcGeom = srcGeom;\n}\nextend(GeometrySnapper.prototype, {\n\tsnapTo: function (snapGeom, snapTolerance) {\n\t\tvar snapPts = this.extractTargetCoordinates(snapGeom);\n\t\tvar snapTrans = new SnapTransformer(snapTolerance, snapPts);\n\t\treturn snapTrans.transform(this.srcGeom);\n\t},\n\tsnapToSelf: function (snapTolerance, cleanResult) {\n\t\tvar snapPts = this.extractTargetCoordinates(this.srcGeom);\n\t\tvar snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n\t\tvar snappedGeom = snapTrans.transform(this.srcGeom);\n\t\tvar result = snappedGeom;\n\t\tif (cleanResult && hasInterface(result, Polygonal)) {\n\t\t\tresult = snappedGeom.buffer(0);\n\t\t}\n\t\treturn result;\n\t},\n\tcomputeSnapTolerance: function (ringPts) {\n\t\tvar minSegLen = this.computeMinimumSegmentLength(ringPts);\n\t\tvar snapTol = minSegLen / 10;\n\t\treturn snapTol;\n\t},\n\textractTargetCoordinates: function (g) {\n\t\tvar ptSet = new TreeSet();\n\t\tvar pts = g.getCoordinates();\n\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\tptSet.add(pts[i]);\n\t\t}\n\t\treturn ptSet.toArray(new Array(0).fill(null));\n\t},\n\tcomputeMinimumSegmentLength: function (pts) {\n\t\tvar minSegLen = Double.MAX_VALUE;\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tvar segLen = pts[i].distance(pts[i + 1]);\n\t\t\tif (segLen < minSegLen) minSegLen = segLen;\n\t\t}\n\t\treturn minSegLen;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometrySnapper;\n\t}\n});\nGeometrySnapper.snap = function (g0, g1, snapTolerance) {\n\tvar snapGeom = new Array(2).fill(null);\n\tvar snapper0 = new GeometrySnapper(g0);\n\tsnapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n\tvar snapper1 = new GeometrySnapper(g1);\n\tsnapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n\treturn snapGeom;\n};\nGeometrySnapper.computeOverlaySnapTolerance = function () {\n\tif (arguments.length === 1) {\n\t\tlet g = arguments[0];\n\t\tvar snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n\t\tvar pm = g.getPrecisionModel();\n\t\tif (pm.getType() === PrecisionModel.FIXED) {\n\t\t\tvar fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n\t\t\tif (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;\n\t\t}\n\t\treturn snapTolerance;\n\t} else if (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\treturn Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));\n\t}\n};\nGeometrySnapper.computeSizeBasedSnapTolerance = function (g) {\n\tvar env = g.getEnvelopeInternal();\n\tvar minDimension = Math.min(env.getHeight(), env.getWidth());\n\tvar snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n\treturn snapTol;\n};\nGeometrySnapper.snapToSelf = function (geom, snapTolerance, cleanResult) {\n\tvar snapper0 = new GeometrySnapper(geom);\n\treturn snapper0.snapToSelf(snapTolerance, cleanResult);\n};\nGeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;\nfunction SnapTransformer() {\n\tGeometryTransformer.apply(this);\n\tthis.snapTolerance = null;\n\tthis.snapPts = null;\n\tthis.isSelfSnap = false;\n\tif (arguments.length === 2) {\n\t\tlet snapTolerance = arguments[0], snapPts = arguments[1];\n\t\tthis.snapTolerance = snapTolerance;\n\t\tthis.snapPts = snapPts;\n\t} else if (arguments.length === 3) {\n\t\tlet snapTolerance = arguments[0], snapPts = arguments[1], isSelfSnap = arguments[2];\n\t\tthis.snapTolerance = snapTolerance;\n\t\tthis.snapPts = snapPts;\n\t\tthis.isSelfSnap = isSelfSnap;\n\t}\n}\ninherits(SnapTransformer, GeometryTransformer);\nextend(SnapTransformer.prototype, {\n\tsnapLine: function (srcPts, snapPts) {\n\t\tvar snapper = new LineStringSnapper(srcPts, this.snapTolerance);\n\t\tsnapper.setAllowSnappingToSourceVertices(this.isSelfSnap);\n\t\treturn snapper.snapTo(snapPts);\n\t},\n\ttransformCoordinates: function (coords, parent) {\n\t\tvar srcPts = coords.toCoordinateArray();\n\t\tvar newPts = this.snapLine(srcPts, this.snapPts);\n\t\treturn this.factory.getCoordinateSequenceFactory().create(newPts);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SnapTransformer;\n\t}\n});\n","import Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nexport default function CommonBits() {\n\tthis.isFirst = true;\n\tthis.commonMantissaBitsCount = 53;\n\tthis.commonBits = 0;\n\tthis.commonSignExp = null;\n}\nextend(CommonBits.prototype, {\n\tgetCommon: function () {\n\t\treturn Double.longBitsToDouble(this.commonBits);\n\t},\n\tadd: function (num) {\n\t\tvar numBits = Double.doubleToLongBits(num);\n\t\tif (this.isFirst) {\n\t\t\tthis.commonBits = numBits;\n\t\t\tthis.commonSignExp = CommonBits.signExpBits(this.commonBits);\n\t\t\tthis.isFirst = false;\n\t\t\treturn null;\n\t\t}\n\t\tvar numSignExp = CommonBits.signExpBits(numBits);\n\t\tif (numSignExp !== this.commonSignExp) {\n\t\t\tthis.commonBits = 0;\n\t\t\treturn null;\n\t\t}\n\t\tthis.commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this.commonBits, numBits);\n\t\tthis.commonBits = CommonBits.zeroLowerBits(this.commonBits, 64 - (12 + this.commonMantissaBitsCount));\n\t},\n\ttoString: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet bits = arguments[0];\n\t\t\tvar x = Double.longBitsToDouble(bits);\n\t\t\tvar numStr = Long.toBinaryString(bits);\n\t\t\tvar padStr = \"0000000000000000000000000000000000000000000000000000000000000000\" + numStr;\n\t\t\tvar bitStr = padStr.substring(padStr.length - 64);\n\t\t\tvar str = bitStr.substring(0, 1) + \"  \" + bitStr.substring(1, 12) + \"(exp) \" + bitStr.substring(12) + \" [ \" + x + \" ]\";\n\t\t\treturn str;\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CommonBits;\n\t}\n});\nCommonBits.getBit = function (bits, i) {\n\tvar mask = 1 << i;\n\treturn (bits & mask) !== 0 ? 1 : 0;\n};\nCommonBits.signExpBits = function (num) {\n\treturn num >> 52;\n};\nCommonBits.zeroLowerBits = function (bits, nBits) {\n\tvar invMask = (1 << nBits) - 1;\n\tvar mask = ~invMask;\n\tvar zeroed = bits & mask;\n\treturn zeroed;\n};\nCommonBits.numCommonMostSigMantissaBits = function (num1, num2) {\n\tvar count = 0;\n\tfor (var i = 52; i >= 0; i--) {\n\t\tif (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;\n\t\tcount++;\n\t}\n\treturn 52;\n};\n","import CommonBits from './CommonBits';\nimport CoordinateFilter from '../geom/CoordinateFilter';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport CoordinateSequenceFilter from '../geom/CoordinateSequenceFilter';\nexport default function CommonBitsRemover() {\n\tthis.commonCoord = null;\n\tthis.ccFilter = new CommonCoordinateFilter();\n}\nextend(CommonBitsRemover.prototype, {\n\taddCommonBits: function (geom) {\n\t\tvar trans = new Translater(this.commonCoord);\n\t\tgeom.apply(trans);\n\t\tgeom.geometryChanged();\n\t},\n\tremoveCommonBits: function (geom) {\n\t\tif (this.commonCoord.x === 0.0 && this.commonCoord.y === 0.0) return geom;\n\t\tvar invCoord = new Coordinate(this.commonCoord);\n\t\tinvCoord.x = -invCoord.x;\n\t\tinvCoord.y = -invCoord.y;\n\t\tvar trans = new Translater(invCoord);\n\t\tgeom.apply(trans);\n\t\tgeom.geometryChanged();\n\t\treturn geom;\n\t},\n\tgetCommonCoordinate: function () {\n\t\treturn this.commonCoord;\n\t},\n\tadd: function (geom) {\n\t\tgeom.apply(this.ccFilter);\n\t\tthis.commonCoord = this.ccFilter.getCommonCoordinate();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CommonBitsRemover;\n\t}\n});\nfunction CommonCoordinateFilter() {\n\tthis.commonBitsX = new CommonBits();\n\tthis.commonBitsY = new CommonBits();\n}\nextend(CommonCoordinateFilter.prototype, {\n\tfilter: function (coord) {\n\t\tthis.commonBitsX.add(coord.x);\n\t\tthis.commonBitsY.add(coord.y);\n\t},\n\tgetCommonCoordinate: function () {\n\t\treturn new Coordinate(this.commonBitsX.getCommon(), this.commonBitsY.getCommon());\n\t},\n\tinterfaces_: function () {\n\t\treturn [CoordinateFilter];\n\t},\n\tgetClass: function () {\n\t\treturn CommonCoordinateFilter;\n\t}\n});\nfunction Translater() {\n\tthis.trans = null;\n\tlet trans = arguments[0];\n\tthis.trans = trans;\n}\nextend(Translater.prototype, {\n\tfilter: function (seq, i) {\n\t\tvar xp = seq.getOrdinate(i, 0) + this.trans.x;\n\t\tvar yp = seq.getOrdinate(i, 1) + this.trans.y;\n\t\tseq.setOrdinate(i, 0, xp);\n\t\tseq.setOrdinate(i, 1, yp);\n\t},\n\tisDone: function () {\n\t\treturn false;\n\t},\n\tisGeometryChanged: function () {\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [CoordinateSequenceFilter];\n\t},\n\tgetClass: function () {\n\t\treturn Translater;\n\t}\n});\nCommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;\nCommonBitsRemover.Translater = Translater;\n","import Iterator from '../../../../java/util/Iterator';\nimport NoSuchElementException from '../../../../java/util/NoSuchElementException';\nimport extend from '../../../../extend';\nimport GeometryCollection from './GeometryCollection';\nexport default function GeometryCollectionIterator() {\n\tthis.parent = null;\n\tthis.atStart = null;\n\tthis.max = null;\n\tthis.index = null;\n\tthis.subcollectionIterator = null;\n\tlet parent = arguments[0];\n\tthis.parent = parent;\n\tthis.atStart = true;\n\tthis.index = 0;\n\tthis.max = parent.getNumGeometries();\n}\nextend(GeometryCollectionIterator.prototype, {\n\tnext: function () {\n\t\tif (this.atStart) {\n\t\t\tthis.atStart = false;\n\t\t\tif (GeometryCollectionIterator.isAtomic(this.parent)) this.index++;\n\t\t\treturn this.parent;\n\t\t}\n\t\tif (this.subcollectionIterator !== null) {\n\t\t\tif (this.subcollectionIterator.hasNext()) {\n\t\t\t\treturn this.subcollectionIterator.next();\n\t\t\t} else {\n\t\t\t\tthis.subcollectionIterator = null;\n\t\t\t}\n\t\t}\n\t\tif (this.index >= this.max) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tvar obj = this.parent.getGeometryN(this.index++);\n\t\tif (obj instanceof GeometryCollection) {\n\t\t\tthis.subcollectionIterator = new GeometryCollectionIterator(obj);\n\t\t\treturn this.subcollectionIterator.next();\n\t\t}\n\t\treturn obj;\n\t},\n\tremove: function () {\n\t\tthrow new UnsupportedOperationException(this.getClass().getName());\n\t},\n\thasNext: function () {\n\t\tif (this.atStart) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.subcollectionIterator !== null) {\n\t\t\tif (this.subcollectionIterator.hasNext()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tthis.subcollectionIterator = null;\n\t\t}\n\t\tif (this.index >= this.max) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Iterator];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryCollectionIterator;\n\t}\n});\nGeometryCollectionIterator.isAtomic = function (geom) {\n\treturn !(geom instanceof GeometryCollection);\n};\n","import Location from '../geom/Location';\nimport LineString from '../geom/LineString';\nimport CGAlgorithms from './CGAlgorithms';\nimport Coordinate from '../geom/Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport BoundaryNodeRule from './BoundaryNodeRule';\nimport extend from '../../../../extend';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport GeometryCollectionIterator from '../geom/GeometryCollectionIterator';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport MultiLineString from '../geom/MultiLineString';\nexport default function PointLocator() {\n\tthis.boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n\tthis.isIn = null;\n\tthis.numBoundaries = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet boundaryRule = arguments[0];\n\t\tif (boundaryRule === null) throw new IllegalArgumentException(\"Rule must be non-null\");\n\t\tthis.boundaryRule = boundaryRule;\n\t}\n}\nextend(PointLocator.prototype, {\n\tlocateInternal: function () {\n\t\tif (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {\n\t\t\tlet p = arguments[0], poly = arguments[1];\n\t\t\tif (poly.isEmpty()) return Location.EXTERIOR;\n\t\t\tvar shell = poly.getExteriorRing();\n\t\t\tvar shellLoc = this.locateInPolygonRing(p, shell);\n\t\t\tif (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;\n\t\t\tif (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\t\tvar hole = poly.getInteriorRingN(i);\n\t\t\t\tvar holeLoc = this.locateInPolygonRing(p, hole);\n\t\t\t\tif (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n\t\t\t\tif (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\t\t\t}\n\t\t\treturn Location.INTERIOR;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {\n\t\t\tlet p = arguments[0], l = arguments[1];\n\t\t\tif (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\t\tvar pt = l.getCoordinates();\n\t\t\tif (!l.isClosed()) {\n\t\t\t\tif (p.equals(pt[0]) || p.equals(pt[pt.length - 1])) {\n\t\t\t\t\treturn Location.BOUNDARY;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (CGAlgorithms.isOnLine(p, pt)) return Location.INTERIOR;\n\t\t\treturn Location.EXTERIOR;\n\t\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {\n\t\t\tlet p = arguments[0], pt = arguments[1];\n\t\t\tvar ptCoord = pt.getCoordinate();\n\t\t\tif (ptCoord.equals2D(p)) return Location.INTERIOR;\n\t\t\treturn Location.EXTERIOR;\n\t\t}\n\t},\n\tlocateInPolygonRing: function (p, ring) {\n\t\tif (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n\t\treturn CGAlgorithms.locatePointInRing(p, ring.getCoordinates());\n\t},\n\tintersects: function (p, geom) {\n\t\treturn this.locate(p, geom) !== Location.EXTERIOR;\n\t},\n\tupdateLocationInfo: function (loc) {\n\t\tif (loc === Location.INTERIOR) this.isIn = true;\n\t\tif (loc === Location.BOUNDARY) this.numBoundaries++;\n\t},\n\tcomputeLocation: function (p, geom) {\n\t\tif (geom instanceof Point) {\n\t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n\t\t}\n\t\tif (geom instanceof LineString) {\n\t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n\t\t} else if (geom instanceof Polygon) {\n\t\t\tthis.updateLocationInfo(this.locateInternal(p, geom));\n\t\t} else if (geom instanceof MultiLineString) {\n\t\t\tvar ml = geom;\n\t\t\tfor (var i = 0; i < ml.getNumGeometries(); i++) {\n\t\t\t\tvar l = ml.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateInternal(p, l));\n\t\t\t}\n\t\t} else if (geom instanceof MultiPolygon) {\n\t\t\tvar mpoly = geom;\n\t\t\tfor (var i = 0; i < mpoly.getNumGeometries(); i++) {\n\t\t\t\tvar poly = mpoly.getGeometryN(i);\n\t\t\t\tthis.updateLocationInfo(this.locateInternal(p, poly));\n\t\t\t}\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\t\twhile (geomi.hasNext()) {\n\t\t\t\tvar g2 = geomi.next();\n\t\t\t\tif (g2 !== geom) this.computeLocation(p, g2);\n\t\t\t}\n\t\t}\n\t},\n\tlocate: function (p, geom) {\n\t\tif (geom.isEmpty()) return Location.EXTERIOR;\n\t\tif (geom instanceof LineString) {\n\t\t\treturn this.locateInternal(p, geom);\n\t\t} else if (geom instanceof Polygon) {\n\t\t\treturn this.locateInternal(p, geom);\n\t\t}\n\t\tthis.isIn = false;\n\t\tthis.numBoundaries = 0;\n\t\tthis.computeLocation(p, geom);\n\t\tif (this.boundaryRule.isInBoundary(this.numBoundaries)) return Location.BOUNDARY;\n\t\tif (this.numBoundaries > 0 || this.isIn) return Location.INTERIOR;\n\t\treturn Location.EXTERIOR;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PointLocator;\n\t}\n});\n","import Coordinate from '../geom/Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nexport default function Octant() {}\nextend(Octant.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Octant;\n\t}\n});\nOctant.octant = function () {\n\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\tlet dx = arguments[0], dy = arguments[1];\n\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for point ( \" + dx + \", \" + dy + \" )\");\n\t\tvar adx = Math.abs(dx);\n\t\tvar ady = Math.abs(dy);\n\t\tif (dx >= 0) {\n\t\t\tif (dy >= 0) {\n\t\t\t\tif (adx >= ady) return 0; else return 1;\n\t\t\t} else {\n\t\t\t\tif (adx >= ady) return 7; else return 6;\n\t\t\t}\n\t\t} else {\n\t\t\tif (dy >= 0) {\n\t\t\t\tif (adx >= ady) return 3; else return 2;\n\t\t\t} else {\n\t\t\t\tif (adx >= ady) return 4; else return 5;\n\t\t\t}\n\t\t}\n\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tvar dx = p1.x - p0.x;\n\t\tvar dy = p1.y - p0.y;\n\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the octant for two identical points \" + p0);\n\t\treturn Octant.octant(dx, dy);\n\t}\n};\n","import extend from '../../../../extend';\nexport default function SegmentString() {}\nextend(SegmentString.prototype, {\n\tgetCoordinates: function () {},\n\tsize: function () {},\n\tgetCoordinate: function (i) {},\n\tisClosed: function () {},\n\tsetData: function (data) {},\n\tgetData: function () {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentString;\n\t}\n});\n","import WKTWriter from '../io/WKTWriter';\nimport CoordinateArraySequence from '../geom/impl/CoordinateArraySequence';\nimport Octant from './Octant';\nimport extend from '../../../../extend';\nimport SegmentString from './SegmentString';\nexport default function BasicSegmentString() {\n\tthis.pts = null;\n\tthis.data = null;\n\tlet pts = arguments[0], data = arguments[1];\n\tthis.pts = pts;\n\tthis.data = data;\n}\nextend(BasicSegmentString.prototype, {\n\tgetCoordinates: function () {\n\t\treturn this.pts;\n\t},\n\tsize: function () {\n\t\treturn this.pts.length;\n\t},\n\tgetCoordinate: function (i) {\n\t\treturn this.pts[i];\n\t},\n\tisClosed: function () {\n\t\treturn this.pts[0].equals(this.pts[this.pts.length - 1]);\n\t},\n\tgetSegmentOctant: function (index) {\n\t\tif (index === this.pts.length - 1) return -1;\n\t\treturn Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));\n\t},\n\tsetData: function (data) {\n\t\tthis.data = data;\n\t},\n\tgetData: function () {\n\t\treturn this.data;\n\t},\n\ttoString: function () {\n\t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this.pts));\n\t},\n\tinterfaces_: function () {\n\t\treturn [SegmentString];\n\t},\n\tgetClass: function () {\n\t\treturn BasicSegmentString;\n\t}\n});\n","import extend from '../../../../../extend';\nexport default function Boundable() {}\nextend(Boundable.prototype, {\n\tgetBounds: function () {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Boundable;\n\t}\n});\n","import Boundable from './Boundable';\nimport extend from '../../../../../extend';\nimport Serializable from '../../../../../java/io/Serializable';\nexport default function ItemBoundable() {\n\tthis.bounds = null;\n\tthis.item = null;\n\tlet bounds = arguments[0], item = arguments[1];\n\tthis.bounds = bounds;\n\tthis.item = item;\n}\nextend(ItemBoundable.prototype, {\n\tgetItem: function () {\n\t\treturn this.item;\n\t},\n\tgetBounds: function () {\n\t\treturn this.bounds;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Boundable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn ItemBoundable;\n\t}\n});\n","import extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function PriorityQueue() {\n\tthis._size = null;\n\tthis.items = null;\n\tthis._size = 0;\n\tthis.items = new ArrayList();\n\tthis.items.add(null);\n}\nextend(PriorityQueue.prototype, {\n\tpoll: function () {\n\t\tif (this.isEmpty()) return null;\n\t\tvar minItem = this.items.get(1);\n\t\tthis.items.set(1, this.items.get(this._size));\n\t\tthis._size -= 1;\n\t\tthis.reorder(1);\n\t\treturn minItem;\n\t},\n\tsize: function () {\n\t\treturn this._size;\n\t},\n\treorder: function (hole) {\n\t\tvar child = null;\n\t\tvar tmp = this.items.get(hole);\n\t\tfor (; hole * 2 <= this._size; hole = child) {\n\t\t\tchild = hole * 2;\n\t\t\tif (child !== this._size && this.items.get(child + 1).compareTo(this.items.get(child)) < 0) child++;\n\t\t\tif (this.items.get(child).compareTo(tmp) < 0) this.items.set(hole, this.items.get(child)); else break;\n\t\t}\n\t\tthis.items.set(hole, tmp);\n\t},\n\tclear: function () {\n\t\tthis._size = 0;\n\t\tthis.items.clear();\n\t},\n\tisEmpty: function () {\n\t\treturn this._size === 0;\n\t},\n\tadd: function (x) {\n\t\tthis.items.add(null);\n\t\tthis._size += 1;\n\t\tvar hole = this._size;\n\t\tthis.items.set(0, x);\n\t\tfor (; x.compareTo(this.items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {\n\t\t\tthis.items.set(hole, this.items.get(Math.trunc(hole / 2)));\n\t\t}\n\t\tthis.items.set(hole, x);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PriorityQueue;\n\t}\n});\n","import extend from '../../../../extend';\nexport default function ItemVisitor() {}\nextend(ItemVisitor.prototype, {\n\tvisitItem: function (item) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ItemVisitor;\n\t}\n});\n","import extend from '../../../../extend';\nexport default function SpatialIndex() {}\nextend(SpatialIndex.prototype, {\n\tinsert: function (itemEnv, item) {},\n\tremove: function (itemEnv, item) {},\n\tquery: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet searchEnv = arguments[0];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet searchEnv = arguments[0], visitor = arguments[1];\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SpatialIndex;\n\t}\n});\n","import Boundable from './Boundable';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Serializable from '../../../../../java/io/Serializable';\nimport Assert from '../../util/Assert';\nexport default function AbstractNode() {\n\tthis.childBoundables = new ArrayList();\n\tthis.bounds = null;\n\tthis.level = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet level = arguments[0];\n\t\tthis.level = level;\n\t}\n}\nextend(AbstractNode.prototype, {\n\tgetLevel: function () {\n\t\treturn this.level;\n\t},\n\tsize: function () {\n\t\treturn this.childBoundables.size();\n\t},\n\tgetChildBoundables: function () {\n\t\treturn this.childBoundables;\n\t},\n\taddChildBoundable: function (childBoundable) {\n\t\tAssert.isTrue(this.bounds === null);\n\t\tthis.childBoundables.add(childBoundable);\n\t},\n\tisEmpty: function () {\n\t\treturn this.childBoundables.isEmpty();\n\t},\n\tgetBounds: function () {\n\t\tif (this.bounds === null) {\n\t\t\tthis.bounds = this.computeBounds();\n\t\t}\n\t\treturn this.bounds;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Boundable, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn AbstractNode;\n\t}\n});\nAbstractNode.serialVersionUID = 6493722185909573708;\n","import IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport AbstractNode from './AbstractNode';\nimport extend from '../../../../../extend';\nimport Comparable from '../../../../../java/lang/Comparable';\nexport default function BoundablePair() {\n\tthis.boundable1 = null;\n\tthis.boundable2 = null;\n\tthis._distance = null;\n\tthis.itemDistance = null;\n\tlet boundable1 = arguments[0], boundable2 = arguments[1], itemDistance = arguments[2];\n\tthis.boundable1 = boundable1;\n\tthis.boundable2 = boundable2;\n\tthis.itemDistance = itemDistance;\n\tthis._distance = this.distance();\n}\nextend(BoundablePair.prototype, {\n\texpandToQueue: function (priQ, minDistance) {\n\t\tvar isComp1 = BoundablePair.isComposite(this.boundable1);\n\t\tvar isComp2 = BoundablePair.isComposite(this.boundable2);\n\t\tif (isComp1 && isComp2) {\n\t\t\tif (BoundablePair.area(this.boundable1) > BoundablePair.area(this.boundable2)) {\n\t\t\t\tthis.expand(this.boundable1, this.boundable2, priQ, minDistance);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tthis.expand(this.boundable2, this.boundable1, priQ, minDistance);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else if (isComp1) {\n\t\t\tthis.expand(this.boundable1, this.boundable2, priQ, minDistance);\n\t\t\treturn null;\n\t\t} else if (isComp2) {\n\t\t\tthis.expand(this.boundable2, this.boundable1, priQ, minDistance);\n\t\t\treturn null;\n\t\t}\n\t\tthrow new IllegalArgumentException(\"neither boundable is composite\");\n\t},\n\tisLeaves: function () {\n\t\treturn !(BoundablePair.isComposite(this.boundable1) || BoundablePair.isComposite(this.boundable2));\n\t},\n\tcompareTo: function (o) {\n\t\tvar nd = o;\n\t\tif (this._distance < nd._distance) return -1;\n\t\tif (this._distance > nd._distance) return 1;\n\t\treturn 0;\n\t},\n\texpand: function (bndComposite, bndOther, priQ, minDistance) {\n\t\tvar children = bndComposite.getChildBoundables();\n\t\tfor (var i = children.iterator(); i.hasNext(); ) {\n\t\t\tvar child = i.next();\n\t\t\tvar bp = new BoundablePair(child, bndOther, this.itemDistance);\n\t\t\tif (bp.getDistance() < minDistance) {\n\t\t\t\tpriQ.add(bp);\n\t\t\t}\n\t\t}\n\t},\n\tgetBoundable: function (i) {\n\t\tif (i === 0) return this.boundable1;\n\t\treturn this.boundable2;\n\t},\n\tgetDistance: function () {\n\t\treturn this._distance;\n\t},\n\tdistance: function () {\n\t\tif (this.isLeaves()) {\n\t\t\treturn this.itemDistance.distance(this.boundable1, this.boundable2);\n\t\t}\n\t\treturn this.boundable1.getBounds().distance(this.boundable2.getBounds());\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn BoundablePair;\n\t}\n});\nBoundablePair.area = function (b) {\n\treturn b.getBounds().getArea();\n};\nBoundablePair.isComposite = function (item) {\n\treturn item instanceof AbstractNode;\n};\n","import ItemBoundable from './ItemBoundable';\nimport hasInterface from '../../../../../hasInterface';\nimport ItemVisitor from '../ItemVisitor';\nimport AbstractNode from './AbstractNode';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Serializable from '../../../../../java/io/Serializable';\nimport Assert from '../../util/Assert';\nimport List from '../../../../../java/util/List';\nexport default function AbstractSTRtree() {\n\tthis.root = null;\n\tthis.built = false;\n\tthis.itemBoundables = new ArrayList();\n\tthis.nodeCapacity = null;\n\tif (arguments.length === 0) {\n\t\tAbstractSTRtree.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);\n\t} else if (arguments.length === 1) {\n\t\tlet nodeCapacity = arguments[0];\n\t\tAssert.isTrue(nodeCapacity > 1, \"Node capacity must be greater than 1\");\n\t\tthis.nodeCapacity = nodeCapacity;\n\t}\n}\nextend(AbstractSTRtree.prototype, {\n\tgetNodeCapacity: function () {\n\t\treturn this.nodeCapacity;\n\t},\n\tlastNode: function (nodes) {\n\t\treturn nodes.get(nodes.size() - 1);\n\t},\n\tsize: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tthis.build();\n\t\t\treturn this.size(this.root);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet node = arguments[0];\n\t\t\tvar size = 0;\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tsize += this.size(childBoundable);\n\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\tsize += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn size;\n\t\t}\n\t},\n\tremoveItem: function (node, item) {\n\t\tvar childToRemove = null;\n\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\tvar childBoundable = i.next();\n\t\t\tif (childBoundable instanceof ItemBoundable) {\n\t\t\t\tif (childBoundable.getItem() === item) childToRemove = childBoundable;\n\t\t\t}\n\t\t}\n\t\tif (childToRemove !== null) {\n\t\t\tnode.getChildBoundables().remove(childToRemove);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\titemsTree: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.build();\n\t\t\tvar valuesTree = this.itemsTree(this.root);\n\t\t\tif (valuesTree === null) return new ArrayList();\n\t\t\treturn valuesTree;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet node = arguments[0];\n\t\t\tvar valuesTreeForNode = new ArrayList();\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tvar valuesTreeForChild = this.itemsTree(childBoundable);\n\t\t\t\t\tif (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);\n\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\tvaluesTreeForNode.add(childBoundable.getItem());\n\t\t\t\t} else {\n\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (valuesTreeForNode.size() <= 0) return null;\n\t\t\treturn valuesTreeForNode;\n\t\t}\n\t},\n\tinsert: function (bounds, item) {\n\t\tAssert.isTrue(!this.built, \"Cannot insert items into an STR packed R-tree after it has been built.\");\n\t\tthis.itemBoundables.add(new ItemBoundable(bounds, item));\n\t},\n\tboundablesAtLevel: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet level = arguments[0];\n\t\t\tvar boundables = new ArrayList();\n\t\t\tthis.boundablesAtLevel(level, this.root, boundables);\n\t\t\treturn boundables;\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet level = arguments[0], top = arguments[1], boundables = arguments[2];\n\t\t\tAssert.isTrue(level > -2);\n\t\t\tif (top.getLevel() === level) {\n\t\t\t\tboundables.add(top);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor (var i = top.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\t\tvar boundable = i.next();\n\t\t\t\tif (boundable instanceof AbstractNode) {\n\t\t\t\t\tthis.boundablesAtLevel(level, boundable, boundables);\n\t\t\t\t} else {\n\t\t\t\t\tAssert.isTrue(boundable instanceof ItemBoundable);\n\t\t\t\t\tif (level === -1) {\n\t\t\t\t\t\tboundables.add(boundable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t},\n\tquery: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet searchBounds = arguments[0];\n\t\t\tthis.build();\n\t\t\tvar matches = new ArrayList();\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn matches;\n\t\t\t}\n\t\t\tif (this.getIntersectsOp().intersects(this.root.getBounds(), searchBounds)) {\n\t\t\t\tthis.query(searchBounds, this.root, matches);\n\t\t\t}\n\t\t\treturn matches;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet searchBounds = arguments[0], visitor = arguments[1];\n\t\t\tthis.build();\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (this.getIntersectsOp().intersects(this.root.getBounds(), searchBounds)) {\n\t\t\t\tthis.query(searchBounds, this.root, visitor);\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n\t\t\t\tlet searchBounds = arguments[0], node = arguments[1], visitor = arguments[2];\n\t\t\t\tvar childBoundables = node.getChildBoundables();\n\t\t\t\tfor (var i = 0; i < childBoundables.size(); i++) {\n\t\t\t\t\tvar childBoundable = childBoundables.get(i);\n\t\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\t\tthis.query(searchBounds, childBoundable, visitor);\n\t\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\t\tvisitor.visitItem(childBoundable.getItem());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n\t\t\t\tlet searchBounds = arguments[0], node = arguments[1], matches = arguments[2];\n\t\t\t\tvar childBoundables = node.getChildBoundables();\n\t\t\t\tfor (var i = 0; i < childBoundables.size(); i++) {\n\t\t\t\t\tvar childBoundable = childBoundables.get(i);\n\t\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\t\tthis.query(searchBounds, childBoundable, matches);\n\t\t\t\t\t} else if (childBoundable instanceof ItemBoundable) {\n\t\t\t\t\t\tmatches.add(childBoundable.getItem());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAssert.shouldNeverReachHere();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tbuild: function () {\n\t\tif (this.built) return null;\n\t\tthis.root = this.itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this.itemBoundables, -1);\n\t\tthis.itemBoundables = null;\n\t\tthis.built = true;\n\t},\n\tgetRoot: function () {\n\t\tthis.build();\n\t\treturn this.root;\n\t},\n\tremove: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet searchBounds = arguments[0], item = arguments[1];\n\t\t\tthis.build();\n\t\t\tif (this.getIntersectsOp().intersects(this.root.getBounds(), searchBounds)) {\n\t\t\t\treturn this.remove(searchBounds, this.root, item);\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet searchBounds = arguments[0], node = arguments[1], item = arguments[2];\n\t\t\tvar found = this.removeItem(node, item);\n\t\t\tif (found) return true;\n\t\t\tvar childToPrune = null;\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tfound = this.remove(searchBounds, childBoundable, item);\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tchildToPrune = childBoundable;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (childToPrune !== null) {\n\t\t\t\tif (childToPrune.getChildBoundables().isEmpty()) {\n\t\t\t\t\tnode.getChildBoundables().remove(childToPrune);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn found;\n\t\t}\n\t},\n\tcreateHigherLevels: function (boundablesOfALevel, level) {\n\t\tAssert.isTrue(!boundablesOfALevel.isEmpty());\n\t\tvar parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n\t\tif (parentBoundables.size() === 1) {\n\t\t\treturn parentBoundables.get(0);\n\t\t}\n\t\treturn this.createHigherLevels(parentBoundables, level + 1);\n\t},\n\tdepth: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tthis.build();\n\t\t\treturn this.depth(this.root);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet node = arguments[0];\n\t\t\tvar maxChildDepth = 0;\n\t\t\tfor (var i = node.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tif (childBoundable instanceof AbstractNode) {\n\t\t\t\t\tvar childDepth = this.depth(childBoundable);\n\t\t\t\t\tif (childDepth > maxChildDepth) maxChildDepth = childDepth;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxChildDepth + 1;\n\t\t}\n\t},\n\tcreateParentBoundables: function (childBoundables, newLevel) {\n\t\tAssert.isTrue(!childBoundables.isEmpty());\n\t\tvar parentBoundables = new ArrayList();\n\t\tparentBoundables.add(this.createNode(newLevel));\n\t\tvar sortedChildBoundables = new ArrayList(childBoundables);\n\t\tCollections.sort(sortedChildBoundables, this.getComparator());\n\t\tfor (var i = sortedChildBoundables.iterator(); i.hasNext(); ) {\n\t\t\tvar childBoundable = i.next();\n\t\t\tif (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {\n\t\t\t\tparentBoundables.add(this.createNode(newLevel));\n\t\t\t}\n\t\t\tthis.lastNode(parentBoundables).addChildBoundable(childBoundable);\n\t\t}\n\t\treturn parentBoundables;\n\t},\n\tisEmpty: function () {\n\t\tif (!this.built) return this.itemBoundables.isEmpty();\n\t\treturn this.root.isEmpty();\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn AbstractSTRtree;\n\t}\n});\nAbstractSTRtree.compareDoubles = function (a, b) {\n\treturn a > b ? 1 : a < b ? -1 : 0;\n};\nfunction IntersectsOp() {}\nAbstractSTRtree.IntersectsOp = IntersectsOp;\nAbstractSTRtree.serialVersionUID = -3886435814360241337;\nAbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;\n","import extend from '../../../../../extend';\nexport default function ItemDistance() {}\nextend(ItemDistance.prototype, {\n\tdistance: function (item1, item2) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ItemDistance;\n\t}\n});\n","import ItemBoundable from './ItemBoundable';\nimport PriorityQueue from '../../util/PriorityQueue';\nimport hasInterface from '../../../../../hasInterface';\nimport ItemVisitor from '../ItemVisitor';\nimport SpatialIndex from '../SpatialIndex';\nimport AbstractNode from './AbstractNode';\nimport Double from '../../../../../java/lang/Double';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport BoundablePair from './BoundablePair';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Comparator from '../../../../../java/util/Comparator';\nimport Serializable from '../../../../../java/io/Serializable';\nimport Envelope from '../../geom/Envelope';\nimport Assert from '../../util/Assert';\nimport inherits from '../../../../../inherits';\nimport List from '../../../../../java/util/List';\nimport AbstractSTRtree from './AbstractSTRtree';\nimport ItemDistance from './ItemDistance';\nexport default function STRtree() {\n\tif (arguments.length === 0) {\n\t\tSTRtree.call(this, STRtree.DEFAULT_NODE_CAPACITY);\n\t} else if (arguments.length === 1) {\n\t\tlet nodeCapacity = arguments[0];\n\t\tAbstractSTRtree.call(this, nodeCapacity);\n\t}\n}\ninherits(STRtree, AbstractSTRtree);\nextend(STRtree.prototype, {\n\tcreateParentBoundablesFromVerticalSlices: function (verticalSlices, newLevel) {\n\t\tAssert.isTrue(verticalSlices.length > 0);\n\t\tvar parentBoundables = new ArrayList();\n\t\tfor (var i = 0; i < verticalSlices.length; i++) {\n\t\t\tparentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n\t\t}\n\t\treturn parentBoundables;\n\t},\n\tcreateNode: function (level) {\n\t\treturn new STRtreeNode(level);\n\t},\n\tsize: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn AbstractSTRtree.prototype.size.call(this);\n\t\t} else return AbstractSTRtree.prototype.size.apply(this, arguments);\n\t},\n\tinsert: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet itemEnv = arguments[0], item = arguments[1];\n\t\t\tif (itemEnv.isNull()) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tAbstractSTRtree.prototype.insert.call(this, itemEnv, item);\n\t\t} else return AbstractSTRtree.prototype.insert.apply(this, arguments);\n\t},\n\tgetIntersectsOp: function () {\n\t\treturn STRtree.intersectsOp;\n\t},\n\tverticalSlices: function (childBoundables, sliceCount) {\n\t\tvar sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n\t\tvar slices = new Array(sliceCount).fill(null);\n\t\tvar i = childBoundables.iterator();\n\t\tfor (var j = 0; j < sliceCount; j++) {\n\t\t\tslices[j] = new ArrayList();\n\t\t\tvar boundablesAddedToSlice = 0;\n\t\t\twhile (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n\t\t\t\tvar childBoundable = i.next();\n\t\t\t\tslices[j].add(childBoundable);\n\t\t\t\tboundablesAddedToSlice++;\n\t\t\t}\n\t\t}\n\t\treturn slices;\n\t},\n\tquery: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet searchEnv = arguments[0];\n\t\t\treturn AbstractSTRtree.prototype.query.call(this, searchEnv);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet searchEnv = arguments[0], visitor = arguments[1];\n\t\t\tAbstractSTRtree.prototype.query.call(this, searchEnv, visitor);\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n\t\t\t\tlet searchBounds = arguments[0], node = arguments[1], visitor = arguments[2];\n\t\t\t\tAbstractSTRtree.prototype.query.call(this, searchBounds, node, visitor);\n\t\t\t} else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n\t\t\t\tlet searchBounds = arguments[0], node = arguments[1], matches = arguments[2];\n\t\t\t\tAbstractSTRtree.prototype.query.call(this, searchBounds, node, matches);\n\t\t\t}\n\t\t}\n\t},\n\tgetComparator: function () {\n\t\treturn STRtree.yComparator;\n\t},\n\tcreateParentBoundablesFromVerticalSlice: function (childBoundables, newLevel) {\n\t\treturn AbstractSTRtree.prototype.createParentBoundables.call(this, childBoundables, newLevel);\n\t},\n\tremove: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet itemEnv = arguments[0], item = arguments[1];\n\t\t\treturn AbstractSTRtree.prototype.remove.call(this, itemEnv, item);\n\t\t} else return AbstractSTRtree.prototype.remove.apply(this, arguments);\n\t},\n\tdepth: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn AbstractSTRtree.prototype.depth.call(this);\n\t\t} else return AbstractSTRtree.prototype.depth.apply(this, arguments);\n\t},\n\tcreateParentBoundables: function (childBoundables, newLevel) {\n\t\tAssert.isTrue(!childBoundables.isEmpty());\n\t\tvar minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n\t\tvar sortedChildBoundables = new ArrayList(childBoundables);\n\t\tCollections.sort(sortedChildBoundables, STRtree.xComparator);\n\t\tvar verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n\t\treturn this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);\n\t},\n\tnearestNeighbour: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (hasInterface(arguments[0], ItemDistance)) {\n\t\t\t\tlet itemDist = arguments[0];\n\t\t\t\tvar bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n\t\t\t\treturn this.nearestNeighbour(bp);\n\t\t\t} else if (arguments[0] instanceof BoundablePair) {\n\t\t\t\tlet initBndPair = arguments[0];\n\t\t\t\treturn this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {\n\t\t\t\tlet tree = arguments[0], itemDist = arguments[1];\n\t\t\t\tvar bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist);\n\t\t\t\treturn this.nearestNeighbour(bp);\n\t\t\t} else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === \"number\") {\n\t\t\t\tlet initBndPair = arguments[0], maxDistance = arguments[1];\n\t\t\t\tvar distanceLowerBound = maxDistance;\n\t\t\t\tvar minPair = null;\n\t\t\t\tvar priQ = new PriorityQueue();\n\t\t\t\tpriQ.add(initBndPair);\n\t\t\t\twhile (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n\t\t\t\t\tvar bndPair = priQ.poll();\n\t\t\t\t\tvar currentDistance = bndPair.getDistance();\n\t\t\t\t\tif (currentDistance >= distanceLowerBound) break;\n\t\t\t\t\tif (bndPair.isLeaves()) {\n\t\t\t\t\t\tdistanceLowerBound = currentDistance;\n\t\t\t\t\t\tminPair = bndPair;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbndPair.expandToQueue(priQ, distanceLowerBound);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet env = arguments[0], item = arguments[1], itemDist = arguments[2];\n\t\t\tvar bnd = new ItemBoundable(env, item);\n\t\t\tvar bp = new BoundablePair(this.getRoot(), bnd, itemDist);\n\t\t\treturn this.nearestNeighbour(bp)[0];\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [SpatialIndex, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn STRtree;\n\t}\n});\nSTRtree.centreX = function (e) {\n\treturn STRtree.avg(e.getMinX(), e.getMaxX());\n};\nSTRtree.avg = function (a, b) {\n\treturn (a + b) / 2;\n};\nSTRtree.centreY = function (e) {\n\treturn STRtree.avg(e.getMinY(), e.getMaxY());\n};\nfunction STRtreeNode() {\n\tlet level = arguments[0];\n\tAbstractNode.call(this, level);\n}\ninherits(STRtreeNode, AbstractNode);\nextend(STRtreeNode.prototype, {\n\tcomputeBounds: function () {\n\t\tvar bounds = null;\n\t\tfor (var i = this.getChildBoundables().iterator(); i.hasNext(); ) {\n\t\t\tvar childBoundable = i.next();\n\t\t\tif (bounds === null) {\n\t\t\t\tbounds = new Envelope(childBoundable.getBounds());\n\t\t\t} else {\n\t\t\t\tbounds.expandToInclude(childBoundable.getBounds());\n\t\t\t}\n\t\t}\n\t\treturn bounds;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn STRtreeNode;\n\t}\n});\nSTRtree.STRtreeNode = STRtreeNode;\nSTRtree.serialVersionUID = 259274702368956900;\nSTRtree.xComparator = {\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tcompare: function (o1, o2) {\n\t\treturn AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));\n\t}\n};\nSTRtree.yComparator = {\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tcompare: function (o1, o2) {\n\t\treturn AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));\n\t}\n};\nSTRtree.intersectsOp = {\n\tinterfaces_: function () {\n\t\treturn [IntersectsOp];\n\t},\n\tintersects: function (aBounds, bBounds) {\n\t\treturn aBounds.intersects(bBounds);\n\t}\n};\nSTRtree.DEFAULT_NODE_CAPACITY = 10;\n","import extend from '../../../../extend';\nimport Assert from '../util/Assert';\nexport default function SegmentPointComparator() {}\nextend(SegmentPointComparator.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentPointComparator;\n\t}\n});\nSegmentPointComparator.relativeSign = function (x0, x1) {\n\tif (x0 < x1) return -1;\n\tif (x0 > x1) return 1;\n\treturn 0;\n};\nSegmentPointComparator.compare = function (octant, p0, p1) {\n\tif (p0.equals2D(p1)) return 0;\n\tvar xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n\tvar ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n\tswitch (octant) {\n\t\tcase 0:\n\t\t\treturn SegmentPointComparator.compareValue(xSign, ySign);\n\t\tcase 1:\n\t\t\treturn SegmentPointComparator.compareValue(ySign, xSign);\n\t\tcase 2:\n\t\t\treturn SegmentPointComparator.compareValue(ySign, -xSign);\n\t\tcase 3:\n\t\t\treturn SegmentPointComparator.compareValue(-xSign, ySign);\n\t\tcase 4:\n\t\t\treturn SegmentPointComparator.compareValue(-xSign, -ySign);\n\t\tcase 5:\n\t\t\treturn SegmentPointComparator.compareValue(-ySign, -xSign);\n\t\tcase 6:\n\t\t\treturn SegmentPointComparator.compareValue(-ySign, xSign);\n\t\tcase 7:\n\t\t\treturn SegmentPointComparator.compareValue(xSign, -ySign);\n\t}\n\tAssert.shouldNeverReachHere(\"invalid octant value\");\n\treturn 0;\n};\nSegmentPointComparator.compareValue = function (compareSign0, compareSign1) {\n\tif (compareSign0 < 0) return -1;\n\tif (compareSign0 > 0) return 1;\n\tif (compareSign1 < 0) return -1;\n\tif (compareSign1 > 0) return 1;\n\treturn 0;\n};\n","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport SegmentPointComparator from './SegmentPointComparator';\nimport Comparable from '../../../../java/lang/Comparable';\nexport default function SegmentNode() {\n\tthis.segString = null;\n\tthis.coord = null;\n\tthis.segmentIndex = null;\n\tthis.segmentOctant = null;\n\tthis._isInterior = null;\n\tlet segString = arguments[0], coord = arguments[1], segmentIndex = arguments[2], segmentOctant = arguments[3];\n\tthis.segString = segString;\n\tthis.coord = new Coordinate(coord);\n\tthis.segmentIndex = segmentIndex;\n\tthis.segmentOctant = segmentOctant;\n\tthis._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n}\nextend(SegmentNode.prototype, {\n\tgetCoordinate: function () {\n\t\treturn this.coord;\n\t},\n\tprint: function (out) {\n\t\tout.print(this.coord);\n\t\tout.print(\" seg # = \" + this.segmentIndex);\n\t},\n\tcompareTo: function (obj) {\n\t\tvar other = obj;\n\t\tif (this.segmentIndex < other.segmentIndex) return -1;\n\t\tif (this.segmentIndex > other.segmentIndex) return 1;\n\t\tif (this.coord.equals2D(other.coord)) return 0;\n\t\treturn SegmentPointComparator.compare(this.segmentOctant, this.coord, other.coord);\n\t},\n\tisEndPoint: function (maxSegmentIndex) {\n\t\tif (this.segmentIndex === 0 && !this._isInterior) return true;\n\t\tif (this.segmentIndex === maxSegmentIndex) return true;\n\t\treturn false;\n\t},\n\tisInterior: function () {\n\t\treturn this._isInterior;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentNode;\n\t}\n});\n","import CoordinateList from '../geom/CoordinateList';\nimport SegmentNode from './SegmentNode';\nimport Iterator from '../../../../java/util/Iterator';\nimport Coordinate from '../geom/Coordinate';\nimport NodedSegmentString from './NodedSegmentString';\nimport extend from '../../../../extend';\nimport Integer from '../../../../java/lang/Integer';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nimport Assert from '../util/Assert';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function SegmentNodeList() {\n\tthis.nodeMap = new TreeMap();\n\tthis.edge = null;\n\tlet edge = arguments[0];\n\tthis.edge = edge;\n}\nextend(SegmentNodeList.prototype, {\n\tgetSplitCoordinates: function () {\n\t\tvar coordList = new CoordinateList();\n\t\tthis.addEndpoints();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tthis.addEdgeCoordinates(eiPrev, ei, coordList);\n\t\t\teiPrev = ei;\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t},\n\taddCollapsedNodes: function () {\n\t\tvar collapsedVertexIndexes = new ArrayList();\n\t\tthis.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n\t\tthis.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n\t\tfor (var it = collapsedVertexIndexes.iterator(); it.hasNext(); ) {\n\t\t\tvar vertexIndex = it.next().intValue();\n\t\t\tthis.add(this.edge.getCoordinate(vertexIndex), vertexIndex);\n\t\t}\n\t},\n\tprint: function (out) {\n\t\tout.println(\"Intersections:\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tei.print(out);\n\t\t}\n\t},\n\tfindCollapsesFromExistingVertices: function (collapsedVertexIndexes) {\n\t\tfor (var i = 0; i < this.edge.size() - 2; i++) {\n\t\t\tvar p0 = this.edge.getCoordinate(i);\n\t\t\tvar p1 = this.edge.getCoordinate(i + 1);\n\t\t\tvar p2 = this.edge.getCoordinate(i + 2);\n\t\t\tif (p0.equals2D(p2)) {\n\t\t\t\tcollapsedVertexIndexes.add(new Integer(i + 1));\n\t\t\t}\n\t\t}\n\t},\n\taddEdgeCoordinates: function (ei0, ei1, coordList) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this.edge.getCoordinate(ei1.segmentIndex);\n\t\tvar useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar ipt = 0;\n\t\tcoordList.add(new Coordinate(ei0.coord), false);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tcoordList.add(this.edge.getCoordinate(i));\n\t\t}\n\t\tif (useIntPt1) {\n\t\t\tcoordList.add(new Coordinate(ei1.coord));\n\t\t}\n\t},\n\titerator: function () {\n\t\treturn this.nodeMap.values().iterator();\n\t},\n\taddSplitEdges: function (edgeList) {\n\t\tthis.addEndpoints();\n\t\tthis.addCollapsedNodes();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n\t\t\tedgeList.add(newEdge);\n\t\t\teiPrev = ei;\n\t\t}\n\t},\n\tfindCollapseIndex: function (ei0, ei1, collapsedVertexIndex) {\n\t\tif (!ei0.coord.equals2D(ei1.coord)) return false;\n\t\tvar numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n\t\tif (!ei1.isInterior()) {\n\t\t\tnumVerticesBetween--;\n\t\t}\n\t\tif (numVerticesBetween === 1) {\n\t\t\tcollapsedVertexIndex[0] = ei0.segmentIndex + 1;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tfindCollapsesFromInsertedNodes: function (collapsedVertexIndexes) {\n\t\tvar collapsedVertexIndex = new Array(1).fill(null);\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n\t\t\tif (isCollapsed) collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));\n\t\t\teiPrev = ei;\n\t\t}\n\t},\n\tgetEdge: function () {\n\t\treturn this.edge;\n\t},\n\taddEndpoints: function () {\n\t\tvar maxSegIndex = this.edge.size() - 1;\n\t\tthis.add(this.edge.getCoordinate(0), 0);\n\t\tthis.add(this.edge.getCoordinate(maxSegIndex), maxSegIndex);\n\t},\n\tcreateSplitEdge: function (ei0, ei1) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this.edge.getCoordinate(ei1.segmentIndex);\n\t\tvar useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar pts = new Array(npts).fill(null);\n\t\tvar ipt = 0;\n\t\tpts[ipt++] = new Coordinate(ei0.coord);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tpts[ipt++] = this.edge.getCoordinate(i);\n\t\t}\n\t\tif (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);\n\t\treturn new NodedSegmentString(pts, this.edge.getData());\n\t},\n\tadd: function (intPt, segmentIndex) {\n\t\tvar eiNew = new SegmentNode(this.edge, intPt, segmentIndex, this.edge.getSegmentOctant(segmentIndex));\n\t\tvar ei = this.nodeMap.get(eiNew);\n\t\tif (ei !== null) {\n\t\t\tAssert.isTrue(ei.coord.equals2D(intPt), \"Found equal nodes with different coordinates\");\n\t\t\treturn ei;\n\t\t}\n\t\tthis.nodeMap.put(eiNew, eiNew);\n\t\treturn eiNew;\n\t},\n\tcheckSplitEdgesCorrectness: function (splitEdges) {\n\t\tvar edgePts = this.edge.getCoordinates();\n\t\tvar split0 = splitEdges.get(0);\n\t\tvar pt0 = split0.getCoordinate(0);\n\t\tif (!pt0.equals2D(edgePts[0])) throw new RuntimeException(\"bad split edge start point at \" + pt0);\n\t\tvar splitn = splitEdges.get(splitEdges.size() - 1);\n\t\tvar splitnPts = splitn.getCoordinates();\n\t\tvar ptn = splitnPts[splitnPts.length - 1];\n\t\tif (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException(\"bad split edge end point at \" + ptn);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentNodeList;\n\t}\n});\nfunction NodeVertexIterator() {\n\tthis.nodeList = null;\n\tthis.edge = null;\n\tthis.nodeIt = null;\n\tthis.currNode = null;\n\tthis.nextNode = null;\n\tthis.currSegIndex = 0;\n\tlet nodeList = arguments[0];\n\tthis.nodeList = nodeList;\n\tthis.edge = nodeList.getEdge();\n\tthis.nodeIt = nodeList.iterator();\n\tthis.readNextNode();\n}\nextend(NodeVertexIterator.prototype, {\n\tnext: function () {\n\t\tif (this.currNode === null) {\n\t\t\tthis.currNode = this.nextNode;\n\t\t\tthis.currSegIndex = this.currNode.segmentIndex;\n\t\t\tthis.readNextNode();\n\t\t\treturn this.currNode;\n\t\t}\n\t\tif (this.nextNode === null) return null;\n\t\tif (this.nextNode.segmentIndex === this.currNode.segmentIndex) {\n\t\t\tthis.currNode = this.nextNode;\n\t\t\tthis.currSegIndex = this.currNode.segmentIndex;\n\t\t\tthis.readNextNode();\n\t\t\treturn this.currNode;\n\t\t}\n\t\tif (this.nextNode.segmentIndex > this.currNode.segmentIndex) {}\n\t\treturn null;\n\t},\n\tremove: function () {\n\t\tthrow new UnsupportedOperationException(this.getClass().getName());\n\t},\n\thasNext: function () {\n\t\tif (this.nextNode === null) return false;\n\t\treturn true;\n\t},\n\treadNextNode: function () {\n\t\tif (this.nodeIt.hasNext()) this.nextNode = this.nodeIt.next(); else this.nextNode = null;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Iterator];\n\t},\n\tgetClass: function () {\n\t\treturn NodeVertexIterator;\n\t}\n});\n","import extend from '../../../../extend';\nimport SegmentString from './SegmentString';\nexport default function NodableSegmentString() {}\nextend(NodableSegmentString.prototype, {\n\taddIntersection: function (intPt, segmentIndex) {},\n\tinterfaces_: function () {\n\t\treturn [SegmentString];\n\t},\n\tgetClass: function () {\n\t\treturn NodableSegmentString;\n\t}\n});\n","import SegmentNodeList from './SegmentNodeList';\nimport WKTWriter from '../io/WKTWriter';\nimport CoordinateArraySequence from '../geom/impl/CoordinateArraySequence';\nimport Coordinate from '../geom/Coordinate';\nimport Octant from './Octant';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport NodableSegmentString from './NodableSegmentString';\nexport default function NodedSegmentString() {\n\tthis.nodeList = new SegmentNodeList(this);\n\tthis.pts = null;\n\tthis.data = null;\n\tlet pts = arguments[0], data = arguments[1];\n\tthis.pts = pts;\n\tthis.data = data;\n}\nextend(NodedSegmentString.prototype, {\n\tgetCoordinates: function () {\n\t\treturn this.pts;\n\t},\n\tsize: function () {\n\t\treturn this.pts.length;\n\t},\n\tgetCoordinate: function (i) {\n\t\treturn this.pts[i];\n\t},\n\tisClosed: function () {\n\t\treturn this.pts[0].equals(this.pts[this.pts.length - 1]);\n\t},\n\tgetSegmentOctant: function (index) {\n\t\tif (index === this.pts.length - 1) return -1;\n\t\treturn this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));\n\t},\n\tsetData: function (data) {\n\t\tthis.data = data;\n\t},\n\tsafeOctant: function (p0, p1) {\n\t\tif (p0.equals2D(p1)) return 0;\n\t\treturn Octant.octant(p0, p1);\n\t},\n\tgetData: function () {\n\t\treturn this.data;\n\t},\n\taddIntersection: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet intPt = arguments[0], segmentIndex = arguments[1];\n\t\t\tthis.addIntersectionNode(intPt, segmentIndex);\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet li = arguments[0], segmentIndex = arguments[1], geomIndex = arguments[2], intIndex = arguments[3];\n\t\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n\t\t\tthis.addIntersection(intPt, segmentIndex);\n\t\t}\n\t},\n\ttoString: function () {\n\t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this.pts));\n\t},\n\tgetNodeList: function () {\n\t\treturn this.nodeList;\n\t},\n\taddIntersectionNode: function (intPt, segmentIndex) {\n\t\tvar normalizedSegmentIndex = segmentIndex;\n\t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n\t\tif (nextSegIndex < this.pts.length) {\n\t\t\tvar nextPt = this.pts[nextSegIndex];\n\t\t\tif (intPt.equals2D(nextPt)) {\n\t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n\t\t\t}\n\t\t}\n\t\tvar ei = this.nodeList.add(intPt, normalizedSegmentIndex);\n\t\treturn ei;\n\t},\n\taddIntersections: function (li, segmentIndex, geomIndex) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [NodableSegmentString];\n\t},\n\tgetClass: function () {\n\t\treturn NodedSegmentString;\n\t}\n});\nNodedSegmentString.getNodedSubstrings = function () {\n\tif (arguments.length === 1) {\n\t\tlet segStrings = arguments[0];\n\t\tvar resultEdgelist = new ArrayList();\n\t\tNodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n\t\treturn resultEdgelist;\n\t} else if (arguments.length === 2) {\n\t\tlet segStrings = arguments[0], resultEdgelist = arguments[1];\n\t\tfor (var i = segStrings.iterator(); i.hasNext(); ) {\n\t\t\tvar ss = i.next();\n\t\t\tss.getNodeList().addSplitEdges(resultEdgelist);\n\t\t}\n\t}\n};\n","import extend from '../../../../../extend';\nimport LineSegment from '../../geom/LineSegment';\nimport Envelope from '../../geom/Envelope';\nexport default function MonotoneChainOverlapAction() {\n\tthis.tempEnv1 = new Envelope();\n\tthis.tempEnv2 = new Envelope();\n\tthis.overlapSeg1 = new LineSegment();\n\tthis.overlapSeg2 = new LineSegment();\n}\nextend(MonotoneChainOverlapAction.prototype, {\n\toverlap: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet seg1 = arguments[0], seg2 = arguments[1];\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3];\n\t\t\tmc1.getLineSegment(start1, this.overlapSeg1);\n\t\t\tmc2.getLineSegment(start2, this.overlapSeg2);\n\t\t\tthis.overlap(this.overlapSeg1, this.overlapSeg2);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChainOverlapAction;\n\t}\n});\n","import extend from '../../../../../extend';\nimport Envelope from '../../geom/Envelope';\nexport default function MonotoneChain() {\n\tthis.pts = null;\n\tthis.start = null;\n\tthis.end = null;\n\tthis.env = null;\n\tthis.context = null;\n\tthis.id = null;\n\tlet pts = arguments[0], start = arguments[1], end = arguments[2], context = arguments[3];\n\tthis.pts = pts;\n\tthis.start = start;\n\tthis.end = end;\n\tthis.context = context;\n}\nextend(MonotoneChain.prototype, {\n\tgetLineSegment: function (index, ls) {\n\t\tls.p0 = this.pts[index];\n\t\tls.p1 = this.pts[index + 1];\n\t},\n\tcomputeSelect: function (searchEnv, start0, end0, mcs) {\n\t\tvar p0 = this.pts[start0];\n\t\tvar p1 = this.pts[end0];\n\t\tmcs.tempEnv1.init(p0, p1);\n\t\tif (end0 - start0 === 1) {\n\t\t\tmcs.select(this, start0);\n\t\t\treturn null;\n\t\t}\n\t\tif (!searchEnv.intersects(mcs.tempEnv1)) return null;\n\t\tvar mid = Math.trunc((start0 + end0) / 2);\n\t\tif (start0 < mid) {\n\t\t\tthis.computeSelect(searchEnv, start0, mid, mcs);\n\t\t}\n\t\tif (mid < end0) {\n\t\t\tthis.computeSelect(searchEnv, mid, end0, mcs);\n\t\t}\n\t},\n\tgetCoordinates: function () {\n\t\tvar coord = new Array(this.end - this.start + 1).fill(null);\n\t\tvar index = 0;\n\t\tfor (var i = this.start; i <= this.end; i++) {\n\t\t\tcoord[index++] = this.pts[i];\n\t\t}\n\t\treturn coord;\n\t},\n\tcomputeOverlaps: function (mc, mco) {\n\t\tthis.computeOverlapsInternal(this.start, this.end, mc, mc.start, mc.end, mco);\n\t},\n\tsetId: function (id) {\n\t\tthis.id = id;\n\t},\n\tselect: function (searchEnv, mcs) {\n\t\tthis.computeSelect(searchEnv, this.start, this.end, mcs);\n\t},\n\tgetEnvelope: function () {\n\t\tif (this.env === null) {\n\t\t\tvar p0 = this.pts[this.start];\n\t\t\tvar p1 = this.pts[this.end];\n\t\t\tthis.env = new Envelope(p0, p1);\n\t\t}\n\t\treturn this.env;\n\t},\n\tgetEndIndex: function () {\n\t\treturn this.end;\n\t},\n\tgetStartIndex: function () {\n\t\treturn this.start;\n\t},\n\tgetContext: function () {\n\t\treturn this.context;\n\t},\n\tgetId: function () {\n\t\treturn this.id;\n\t},\n\tcomputeOverlapsInternal: function (start0, end0, mc, start1, end1, mco) {\n\t\tvar p00 = this.pts[start0];\n\t\tvar p01 = this.pts[end0];\n\t\tvar p10 = mc.pts[start1];\n\t\tvar p11 = mc.pts[end1];\n\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n\t\t\tmco.overlap(this, start0, mc, start1);\n\t\t\treturn null;\n\t\t}\n\t\tmco.tempEnv1.init(p00, p01);\n\t\tmco.tempEnv2.init(p10, p11);\n\t\tif (!mco.tempEnv1.intersects(mco.tempEnv2)) return null;\n\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n\t\tif (start0 < mid0) {\n\t\t\tif (start1 < mid1) this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco);\n\t\t\tif (mid1 < end1) this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco);\n\t\t}\n\t\tif (mid0 < end0) {\n\t\t\tif (start1 < mid1) this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco);\n\t\t\tif (mid1 < end1) this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChain;\n\t}\n});\n","import Coordinate from '../geom/Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nexport default function Quadrant() {}\nextend(Quadrant.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Quadrant;\n\t}\n});\nQuadrant.isNorthern = function (quad) {\n\treturn quad === Quadrant.NE || quad === Quadrant.NW;\n};\nQuadrant.isOpposite = function (quad1, quad2) {\n\tif (quad1 === quad2) return false;\n\tvar diff = (quad1 - quad2 + 4) % 4;\n\tif (diff === 2) return true;\n\treturn false;\n};\nQuadrant.commonHalfPlane = function (quad1, quad2) {\n\tif (quad1 === quad2) return quad1;\n\tvar diff = (quad1 - quad2 + 4) % 4;\n\tif (diff === 2) return -1;\n\tvar min = quad1 < quad2 ? quad1 : quad2;\n\tvar max = quad1 > quad2 ? quad1 : quad2;\n\tif (min === 0 && max === 3) return 3;\n\treturn min;\n};\nQuadrant.isInHalfPlane = function (quad, halfPlane) {\n\tif (halfPlane === Quadrant.SE) {\n\t\treturn quad === Quadrant.SE || quad === Quadrant.SW;\n\t}\n\treturn quad === halfPlane || quad === halfPlane + 1;\n};\nQuadrant.quadrant = function () {\n\tif (typeof arguments[0] === \"number\" && typeof arguments[1] === \"number\") {\n\t\tlet dx = arguments[0], dy = arguments[1];\n\t\tif (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException(\"Cannot compute the quadrant for point ( \" + dx + \", \" + dy + \" )\");\n\t\tif (dx >= 0.0) {\n\t\t\tif (dy >= 0.0) return Quadrant.NE; else return Quadrant.SE;\n\t\t} else {\n\t\t\tif (dy >= 0.0) return Quadrant.NW; else return Quadrant.SW;\n\t\t}\n\t} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tif (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\n\t\tif (p1.x >= p0.x) {\n\t\t\tif (p1.y >= p0.y) return Quadrant.NE; else return Quadrant.SE;\n\t\t} else {\n\t\t\tif (p1.y >= p0.y) return Quadrant.NW; else return Quadrant.SW;\n\t\t}\n\t}\n};\nQuadrant.NE = 0;\nQuadrant.NW = 1;\nQuadrant.SW = 2;\nQuadrant.SE = 3;\n","import MonotoneChain from './MonotoneChain';\nimport extend from '../../../../../extend';\nimport Integer from '../../../../../java/lang/Integer';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Quadrant from '../../geomgraph/Quadrant';\nexport default function MonotoneChainBuilder() {}\nextend(MonotoneChainBuilder.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChainBuilder;\n\t}\n});\nMonotoneChainBuilder.getChainStartIndices = function (pts) {\n\tvar start = 0;\n\tvar startIndexList = new ArrayList();\n\tstartIndexList.add(new Integer(start));\n\tdo {\n\t\tvar last = MonotoneChainBuilder.findChainEnd(pts, start);\n\t\tstartIndexList.add(new Integer(last));\n\t\tstart = last;\n\t} while (start < pts.length - 1);\n\tvar startIndex = MonotoneChainBuilder.toIntArray(startIndexList);\n\treturn startIndex;\n};\nMonotoneChainBuilder.findChainEnd = function (pts, start) {\n\tvar safeStart = start;\n\twhile (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {\n\t\tsafeStart++;\n\t}\n\tif (safeStart >= pts.length - 1) {\n\t\treturn pts.length - 1;\n\t}\n\tvar chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n\tvar last = start + 1;\n\twhile (last < pts.length) {\n\t\tif (!pts[last - 1].equals2D(pts[last])) {\n\t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n\t\t\tif (quad !== chainQuad) break;\n\t\t}\n\t\tlast++;\n\t}\n\treturn last - 1;\n};\nMonotoneChainBuilder.getChains = function () {\n\tif (arguments.length === 1) {\n\t\tlet pts = arguments[0];\n\t\treturn MonotoneChainBuilder.getChains(pts, null);\n\t} else if (arguments.length === 2) {\n\t\tlet pts = arguments[0], context = arguments[1];\n\t\tvar mcList = new ArrayList();\n\t\tvar startIndex = MonotoneChainBuilder.getChainStartIndices(pts);\n\t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n\t\t\tvar mc = new MonotoneChain(pts, startIndex[i], startIndex[i + 1], context);\n\t\t\tmcList.add(mc);\n\t\t}\n\t\treturn mcList;\n\t}\n};\nMonotoneChainBuilder.toIntArray = function (list) {\n\tvar array = new Array(list.size()).fill(null);\n\tfor (var i = 0; i < array.length; i++) {\n\t\tarray[i] = list.get(i).intValue();\n\t}\n\treturn array;\n};\n","import extend from '../../../../extend';\nexport default function Noder() {}\nextend(Noder.prototype, {\n\tcomputeNodes: function (segStrings) {},\n\tgetNodedSubstrings: function () {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Noder;\n\t}\n});\n","import Noder from './Noder';\nimport extend from '../../../../extend';\nexport default function SinglePassNoder() {\n\tthis.segInt = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet segInt = arguments[0];\n\t\tthis.setSegmentIntersector(segInt);\n\t}\n}\nextend(SinglePassNoder.prototype, {\n\tsetSegmentIntersector: function (segInt) {\n\t\tthis.segInt = segInt;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Noder];\n\t},\n\tgetClass: function () {\n\t\treturn SinglePassNoder;\n\t}\n});\n","import STRtree from '../index/strtree/STRtree';\nimport NodedSegmentString from './NodedSegmentString';\nimport MonotoneChainOverlapAction from '../index/chain/MonotoneChainOverlapAction';\nimport extend from '../../../../extend';\nimport MonotoneChainBuilder from '../index/chain/MonotoneChainBuilder';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport inherits from '../../../../inherits';\nimport SinglePassNoder from './SinglePassNoder';\nexport default function MCIndexNoder() {\n\tthis.monoChains = new ArrayList();\n\tthis.index = new STRtree();\n\tthis.idCounter = 0;\n\tthis.nodedSegStrings = null;\n\tthis.nOverlaps = 0;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet si = arguments[0];\n\t\tSinglePassNoder.call(this, si);\n\t}\n}\ninherits(MCIndexNoder, SinglePassNoder);\nextend(MCIndexNoder.prototype, {\n\tgetMonotoneChains: function () {\n\t\treturn this.monoChains;\n\t},\n\tgetNodedSubstrings: function () {\n\t\treturn NodedSegmentString.getNodedSubstrings(this.nodedSegStrings);\n\t},\n\tgetIndex: function () {\n\t\treturn this.index;\n\t},\n\tadd: function (segStr) {\n\t\tvar segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n\t\tfor (var i = segChains.iterator(); i.hasNext(); ) {\n\t\t\tvar mc = i.next();\n\t\t\tmc.setId(this.idCounter++);\n\t\t\tthis.index.insert(mc.getEnvelope(), mc);\n\t\t\tthis.monoChains.add(mc);\n\t\t}\n\t},\n\tcomputeNodes: function (inputSegStrings) {\n\t\tthis.nodedSegStrings = inputSegStrings;\n\t\tfor (var i = inputSegStrings.iterator(); i.hasNext(); ) {\n\t\t\tthis.add(i.next());\n\t\t}\n\t\tthis.intersectChains();\n\t},\n\tintersectChains: function () {\n\t\tvar overlapAction = new SegmentOverlapAction(this.segInt);\n\t\tfor (var i = this.monoChains.iterator(); i.hasNext(); ) {\n\t\t\tvar queryChain = i.next();\n\t\t\tvar overlapChains = this.index.query(queryChain.getEnvelope());\n\t\t\tfor (var j = overlapChains.iterator(); j.hasNext(); ) {\n\t\t\t\tvar testChain = j.next();\n\t\t\t\tif (testChain.getId() > queryChain.getId()) {\n\t\t\t\t\tqueryChain.computeOverlaps(testChain, overlapAction);\n\t\t\t\t\tthis.nOverlaps++;\n\t\t\t\t}\n\t\t\t\tif (this.segInt.isDone()) return null;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MCIndexNoder;\n\t}\n});\nfunction SegmentOverlapAction() {\n\tMonotoneChainOverlapAction.apply(this);\n\tthis.si = null;\n\tlet si = arguments[0];\n\tthis.si = si;\n}\ninherits(SegmentOverlapAction, MonotoneChainOverlapAction);\nextend(SegmentOverlapAction.prototype, {\n\toverlap: function () {\n\t\tif (arguments.length === 4) {\n\t\t\tlet mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3];\n\t\t\tvar ss1 = mc1.getContext();\n\t\t\tvar ss2 = mc2.getContext();\n\t\t\tthis.si.processIntersections(ss1, start1, ss2, start2);\n\t\t} else return MonotoneChainOverlapAction.prototype.overlap.apply(this, arguments);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentOverlapAction;\n\t}\n});\nMCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;\n","import Coordinate from './Coordinate';\nimport extend from '../../../../extend';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nimport inherits from '../../../../inherits';\nexport default function TopologyException() {\n\tthis.pt = null;\n\tif (arguments.length === 1) {\n\t\tlet msg = arguments[0];\n\t\tRuntimeException.call(this, msg);\n\t} else if (arguments.length === 2) {\n\t\tlet msg = arguments[0], pt = arguments[1];\n\t\tRuntimeException.call(this, TopologyException.msgWithCoord(msg, pt));\n\t\tthis.name = 'TopologyException';\n\t\tthis.pt = new Coordinate(pt);\n\t}\n}\ninherits(TopologyException, RuntimeException);\nextend(TopologyException.prototype, {\n\tgetCoordinate: function () {\n\t\treturn this.pt;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TopologyException;\n\t}\n});\nTopologyException.msgWithCoord = function (msg, pt) {\n\tif (pt !== null) return msg + \" [ \" + pt + \" ]\";\n\treturn msg;\n};\n","import extend from '../../../../extend';\nexport default function SegmentIntersector() {}\nextend(SegmentIntersector.prototype, {\n\tprocessIntersections: function (e0, segIndex0, e1, segIndex1) {},\n\tisDone: function () {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentIntersector;\n\t}\n});\n","import extend from '../../../../extend';\nimport SegmentIntersector from './SegmentIntersector';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function InteriorIntersectionFinder() {\n\tthis.findAllIntersections = false;\n\tthis.isCheckEndSegmentsOnly = false;\n\tthis.li = null;\n\tthis.interiorIntersection = null;\n\tthis.intSegments = null;\n\tthis.intersections = new ArrayList();\n\tthis.intersectionCount = 0;\n\tthis.keepIntersections = true;\n\tlet li = arguments[0];\n\tthis.li = li;\n\tthis.interiorIntersection = null;\n}\nextend(InteriorIntersectionFinder.prototype, {\n\tgetInteriorIntersection: function () {\n\t\treturn this.interiorIntersection;\n\t},\n\tsetCheckEndSegmentsOnly: function (isCheckEndSegmentsOnly) {\n\t\tthis.isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n\t},\n\tgetIntersectionSegments: function () {\n\t\treturn this.intSegments;\n\t},\n\tcount: function () {\n\t\treturn this.intersectionCount;\n\t},\n\tgetIntersections: function () {\n\t\treturn this.intersections;\n\t},\n\tsetFindAllIntersections: function (findAllIntersections) {\n\t\tthis.findAllIntersections = findAllIntersections;\n\t},\n\tsetKeepIntersections: function (keepIntersections) {\n\t\tthis.keepIntersections = keepIntersections;\n\t},\n\tprocessIntersections: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (!this.findAllIntersections && this.hasIntersection()) return null;\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tif (this.isCheckEndSegmentsOnly) {\n\t\t\tvar isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);\n\t\t\tif (!isEndSegPresent) return null;\n\t\t}\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis.li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this.li.hasIntersection()) {\n\t\t\tif (this.li.isInteriorIntersection()) {\n\t\t\t\tthis.intSegments = new Array(4).fill(null);\n\t\t\t\tthis.intSegments[0] = p00;\n\t\t\t\tthis.intSegments[1] = p01;\n\t\t\t\tthis.intSegments[2] = p10;\n\t\t\t\tthis.intSegments[3] = p11;\n\t\t\t\tthis.interiorIntersection = this.li.getIntersection(0);\n\t\t\t\tif (this.keepIntersections) this.intersections.add(this.interiorIntersection);\n\t\t\t\tthis.intersectionCount++;\n\t\t\t}\n\t\t}\n\t},\n\tisEndSegment: function (segStr, index) {\n\t\tif (index === 0) return true;\n\t\tif (index >= segStr.size() - 2) return true;\n\t\treturn false;\n\t},\n\thasIntersection: function () {\n\t\treturn this.interiorIntersection !== null;\n\t},\n\tisDone: function () {\n\t\tif (this.findAllIntersections) return false;\n\t\treturn this.interiorIntersection !== null;\n\t},\n\tinterfaces_: function () {\n\t\treturn [SegmentIntersector];\n\t},\n\tgetClass: function () {\n\t\treturn InteriorIntersectionFinder;\n\t}\n});\nInteriorIntersectionFinder.createAllIntersectionsFinder = function (li) {\n\tvar finder = new InteriorIntersectionFinder(li);\n\tfinder.setFindAllIntersections(true);\n\treturn finder;\n};\nInteriorIntersectionFinder.createAnyIntersectionFinder = function (li) {\n\treturn new InteriorIntersectionFinder(li);\n};\nInteriorIntersectionFinder.createIntersectionCounter = function (li) {\n\tvar finder = new InteriorIntersectionFinder(li);\n\tfinder.setFindAllIntersections(true);\n\tfinder.setKeepIntersections(false);\n\treturn finder;\n};\n","import WKTWriter from '../io/WKTWriter';\nimport MCIndexNoder from './MCIndexNoder';\nimport TopologyException from '../geom/TopologyException';\nimport extend from '../../../../extend';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nimport InteriorIntersectionFinder from './InteriorIntersectionFinder';\nexport default function FastNodingValidator() {\n\tthis.li = new RobustLineIntersector();\n\tthis.segStrings = null;\n\tthis.findAllIntersections = false;\n\tthis.segInt = null;\n\tthis._isValid = true;\n\tlet segStrings = arguments[0];\n\tthis.segStrings = segStrings;\n}\nextend(FastNodingValidator.prototype, {\n\texecute: function () {\n\t\tif (this.segInt !== null) return null;\n\t\tthis.checkInteriorIntersections();\n\t},\n\tgetIntersections: function () {\n\t\treturn this.segInt.getIntersections();\n\t},\n\tisValid: function () {\n\t\tthis.execute();\n\t\treturn this._isValid;\n\t},\n\tsetFindAllIntersections: function (findAllIntersections) {\n\t\tthis.findAllIntersections = findAllIntersections;\n\t},\n\tcheckInteriorIntersections: function () {\n\t\tthis._isValid = true;\n\t\tthis.segInt = new InteriorIntersectionFinder(this.li);\n\t\tthis.segInt.setFindAllIntersections(this.findAllIntersections);\n\t\tvar noder = new MCIndexNoder();\n\t\tnoder.setSegmentIntersector(this.segInt);\n\t\tnoder.computeNodes(this.segStrings);\n\t\tif (this.segInt.hasIntersection()) {\n\t\t\tthis._isValid = false;\n\t\t\treturn null;\n\t\t}\n\t},\n\tcheckValid: function () {\n\t\tthis.execute();\n\t\tif (!this._isValid) throw new TopologyException(this.getErrorMessage(), this.segInt.getInteriorIntersection());\n\t},\n\tgetErrorMessage: function () {\n\t\tif (this._isValid) return \"no intersections found\";\n\t\tvar intSegs = this.segInt.getIntersectionSegments();\n\t\treturn \"found non-noded intersection between \" + WKTWriter.toLineString(intSegs[0], intSegs[1]) + \" and \" + WKTWriter.toLineString(intSegs[2], intSegs[3]);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn FastNodingValidator;\n\t}\n});\nFastNodingValidator.computeIntersections = function (segStrings) {\n\tvar nv = new FastNodingValidator(segStrings);\n\tnv.setFindAllIntersections(true);\n\tnv.isValid();\n\treturn nv.getIntersections();\n};\n","import BasicSegmentString from '../noding/BasicSegmentString';\nimport extend from '../../../../extend';\nimport FastNodingValidator from '../noding/FastNodingValidator';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function EdgeNodingValidator() {\n\tthis.nv = null;\n\tlet edges = arguments[0];\n\tthis.nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n}\nextend(EdgeNodingValidator.prototype, {\n\tcheckValid: function () {\n\t\tthis.nv.checkValid();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeNodingValidator;\n\t}\n});\nEdgeNodingValidator.toSegmentStrings = function (edges) {\n\tvar segStrings = new ArrayList();\n\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\tvar e = i.next();\n\t\tsegStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n\t}\n\treturn segStrings;\n};\nEdgeNodingValidator.checkValid = function (edges) {\n\tvar validator = new EdgeNodingValidator(edges);\n\tvalidator.checkValid();\n};\n","import GeometryFactory from '../GeometryFactory';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function GeometryCollectionMapper() {\n\tthis.mapOp = null;\n\tlet mapOp = arguments[0];\n\tthis.mapOp = mapOp;\n}\nextend(GeometryCollectionMapper.prototype, {\n\tmap: function (gc) {\n\t\tvar mapped = new ArrayList();\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = this.mapOp.map(gc.getGeometryN(i));\n\t\t\tif (!g.isEmpty()) mapped.add(g);\n\t\t}\n\t\treturn gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryCollectionMapper;\n\t}\n});\nGeometryCollectionMapper.map = function (gc, op) {\n\tvar mapper = new GeometryCollectionMapper(op);\n\treturn mapper.map(gc);\n};\n","import extend from '../../../../extend';\nexport default function Position() {}\nextend(Position.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Position;\n\t}\n});\nPosition.opposite = function (position) {\n\tif (position === Position.LEFT) return Position.RIGHT;\n\tif (position === Position.RIGHT) return Position.LEFT;\n\treturn position;\n};\nPosition.ON = 0;\nPosition.LEFT = 1;\nPosition.RIGHT = 2;\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport extend from '../../../../extend';\nexport default function TopologyLocation() {\n\tthis.location = null;\n\tif (arguments.length === 1) {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet location = arguments[0];\n\t\t\tthis.init(location.length);\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet on = arguments[0];\n\t\t\tthis.init(1);\n\t\t\tthis.location[Position.ON] = on;\n\t\t} else if (arguments[0] instanceof TopologyLocation) {\n\t\t\tlet gl = arguments[0];\n\t\t\tthis.init(gl.location.length);\n\t\t\tif (gl !== null) {\n\t\t\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\t\t\tthis.location[i] = gl.location[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tlet on = arguments[0], left = arguments[1], right = arguments[2];\n\t\tthis.init(3);\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t}\n}\nextend(TopologyLocation.prototype, {\n\tsetAllLocations: function (locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tthis.location[i] = locValue;\n\t\t}\n\t},\n\tisNull: function () {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== Location.NONE) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tsetAllLocationsIfNull: function (locValue) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) this.location[i] = locValue;\n\t\t}\n\t},\n\tisLine: function () {\n\t\treturn this.location.length === 1;\n\t},\n\tmerge: function (gl) {\n\t\tif (gl.location.length > this.location.length) {\n\t\t\tvar newLoc = new Array(3).fill(null);\n\t\t\tnewLoc[Position.ON] = this.location[Position.ON];\n\t\t\tnewLoc[Position.LEFT] = Location.NONE;\n\t\t\tnewLoc[Position.RIGHT] = Location.NONE;\n\t\t\tthis.location = newLoc;\n\t\t}\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];\n\t\t}\n\t},\n\tgetLocations: function () {\n\t\treturn this.location;\n\t},\n\tflip: function () {\n\t\tif (this.location.length <= 1) return null;\n\t\tvar temp = this.location[Position.LEFT];\n\t\tthis.location[Position.LEFT] = this.location[Position.RIGHT];\n\t\tthis.location[Position.RIGHT] = temp;\n\t},\n\ttoString: function () {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n\t\tbuf.append(Location.toLocationSymbol(this.location[Position.ON]));\n\t\tif (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n\t\treturn buf.toString();\n\t},\n\tsetLocations: function (on, left, right) {\n\t\tthis.location[Position.ON] = on;\n\t\tthis.location[Position.LEFT] = left;\n\t\tthis.location[Position.RIGHT] = right;\n\t},\n\tget: function (posIndex) {\n\t\tif (posIndex < this.location.length) return this.location[posIndex];\n\t\treturn Location.NONE;\n\t},\n\tisArea: function () {\n\t\treturn this.location.length > 1;\n\t},\n\tisAnyNull: function () {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] === Location.NONE) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tsetLocation: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet locValue = arguments[0];\n\t\t\tthis.setLocation(Position.ON, locValue);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet locIndex = arguments[0], locValue = arguments[1];\n\t\t\tthis.location[locIndex] = locValue;\n\t\t}\n\t},\n\tinit: function (size) {\n\t\tthis.location = new Array(size).fill(null);\n\t\tthis.setAllLocations(Location.NONE);\n\t},\n\tisEqualOnSide: function (le, locIndex) {\n\t\treturn this.location[locIndex] === le.location[locIndex];\n\t},\n\tallPositionsEqual: function (loc) {\n\t\tfor (var i = 0; i < this.location.length; i++) {\n\t\t\tif (this.location[i] !== loc) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TopologyLocation;\n\t}\n});\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport extend from '../../../../extend';\nimport TopologyLocation from './TopologyLocation';\nexport default function Label() {\n\tthis.elt = new Array(2).fill(null);\n\tif (arguments.length === 1) {\n\t\tif (Number.isInteger(arguments[0])) {\n\t\t\tlet onLoc = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(onLoc);\n\t\t\tthis.elt[1] = new TopologyLocation(onLoc);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tlet lbl = arguments[0];\n\t\t\tthis.elt[0] = new TopologyLocation(lbl.elt[0]);\n\t\t\tthis.elt[1] = new TopologyLocation(lbl.elt[1]);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet geomIndex = arguments[0], onLoc = arguments[1];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE);\n\t\tthis.elt[geomIndex].setLocation(onLoc);\n\t} else if (arguments.length === 3) {\n\t\tlet onLoc = arguments[0], leftLoc = arguments[1], rightLoc = arguments[2];\n\t\tthis.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t\tthis.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n\t} else if (arguments.length === 4) {\n\t\tlet geomIndex = arguments[0], onLoc = arguments[1], leftLoc = arguments[2], rightLoc = arguments[3];\n\t\tthis.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n\t\tthis.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);\n\t}\n}\nextend(Label.prototype, {\n\tgetGeometryCount: function () {\n\t\tvar count = 0;\n\t\tif (!this.elt[0].isNull()) count++;\n\t\tif (!this.elt[1].isNull()) count++;\n\t\treturn count;\n\t},\n\tsetAllLocations: function (geomIndex, location) {\n\t\tthis.elt[geomIndex].setAllLocations(location);\n\t},\n\tisNull: function (geomIndex) {\n\t\treturn this.elt[geomIndex].isNull();\n\t},\n\tsetAllLocationsIfNull: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet location = arguments[0];\n\t\t\tthis.setAllLocationsIfNull(0, location);\n\t\t\tthis.setAllLocationsIfNull(1, location);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], location = arguments[1];\n\t\t\tthis.elt[geomIndex].setAllLocationsIfNull(location);\n\t\t}\n\t},\n\tisLine: function (geomIndex) {\n\t\treturn this.elt[geomIndex].isLine();\n\t},\n\tmerge: function (lbl) {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.elt[i] === null && lbl.elt[i] !== null) {\n\t\t\t\tthis.elt[i] = new TopologyLocation(lbl.elt[i]);\n\t\t\t} else {\n\t\t\t\tthis.elt[i].merge(lbl.elt[i]);\n\t\t\t}\n\t\t}\n\t},\n\tflip: function () {\n\t\tthis.elt[0].flip();\n\t\tthis.elt[1].flip();\n\t},\n\tgetLocation: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].get(Position.ON);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1];\n\t\t\treturn this.elt[geomIndex].get(posIndex);\n\t\t}\n\t},\n\ttoString: function () {\n\t\tvar buf = new StringBuffer();\n\t\tif (this.elt[0] !== null) {\n\t\t\tbuf.append(\"A:\");\n\t\t\tbuf.append(this.elt[0].toString());\n\t\t}\n\t\tif (this.elt[1] !== null) {\n\t\t\tbuf.append(\" B:\");\n\t\t\tbuf.append(this.elt[1].toString());\n\t\t}\n\t\treturn buf.toString();\n\t},\n\tisArea: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.elt[0].isArea() || this.elt[1].isArea();\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.elt[geomIndex].isArea();\n\t\t}\n\t},\n\tisAnyNull: function (geomIndex) {\n\t\treturn this.elt[geomIndex].isAnyNull();\n\t},\n\tsetLocation: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], location = arguments[1];\n\t\t\tthis.elt[geomIndex].setLocation(Position.ON, location);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];\n\t\t\tthis.elt[geomIndex].setLocation(posIndex, location);\n\t\t}\n\t},\n\tisEqualOnSide: function (lbl, side) {\n\t\treturn this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n\t},\n\tallPositionsEqual: function (geomIndex, loc) {\n\t\treturn this.elt[geomIndex].allPositionsEqual(loc);\n\t},\n\ttoLine: function (geomIndex) {\n\t\tif (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Label;\n\t}\n});\nLabel.toLineLabel = function (label) {\n\tvar lineLabel = new Label(Location.NONE);\n\tfor (var i = 0; i < 2; i++) {\n\t\tlineLabel.setLocation(i, label.getLocation(i));\n\t}\n\treturn lineLabel;\n};\n","import Location from '../geom/Location';\nimport CGAlgorithms from '../algorithm/CGAlgorithms';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport extend from '../../../../extend';\nimport Label from './Label';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Assert from '../util/Assert';\nexport default function EdgeRing() {\n\tthis.startDe = null;\n\tthis.maxNodeDegree = -1;\n\tthis.edges = new ArrayList();\n\tthis.pts = new ArrayList();\n\tthis.label = new Label(Location.NONE);\n\tthis.ring = null;\n\tthis._isHole = null;\n\tthis.shell = null;\n\tthis.holes = new ArrayList();\n\tthis.geometryFactory = null;\n\tlet start = arguments[0], geometryFactory = arguments[1];\n\tthis.geometryFactory = geometryFactory;\n\tthis.computePoints(start);\n\tthis.computeRing();\n}\nextend(EdgeRing.prototype, {\n\tcomputeRing: function () {\n\t\tif (this.ring !== null) return null;\n\t\tvar coord = new Array(this.pts.size()).fill(null);\n\t\tfor (var i = 0; i < this.pts.size(); i++) {\n\t\t\tcoord[i] = this.pts.get(i);\n\t\t}\n\t\tthis.ring = this.geometryFactory.createLinearRing(coord);\n\t\tthis._isHole = CGAlgorithms.isCCW(this.ring.getCoordinates());\n\t},\n\tisIsolated: function () {\n\t\treturn this.label.getGeometryCount() === 1;\n\t},\n\tcomputePoints: function (start) {\n\t\tthis.startDe = start;\n\t\tvar de = start;\n\t\tvar isFirstEdge = true;\n\t\tdo {\n\t\t\tif (de === null) throw new TopologyException(\"Found null DirectedEdge\");\n\t\t\tif (de.getEdgeRing() === this) throw new TopologyException(\"Directed Edge visited twice during ring-building at \" + de.getCoordinate());\n\t\t\tthis.edges.add(de);\n\t\t\tvar label = de.getLabel();\n\t\t\tAssert.isTrue(label.isArea());\n\t\t\tthis.mergeLabel(label);\n\t\t\tthis.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n\t\t\tisFirstEdge = false;\n\t\t\tthis.setEdgeRing(de, this);\n\t\t\tde = this.getNext(de);\n\t\t} while (de !== this.startDe);\n\t},\n\tgetLinearRing: function () {\n\t\treturn this.ring;\n\t},\n\tgetCoordinate: function (i) {\n\t\treturn this.pts.get(i);\n\t},\n\tcomputeMaxNodeDegree: function () {\n\t\tthis.maxNodeDegree = 0;\n\t\tvar de = this.startDe;\n\t\tdo {\n\t\t\tvar node = de.getNode();\n\t\t\tvar degree = node.getEdges().getOutgoingDegree(this);\n\t\t\tif (degree > this.maxNodeDegree) this.maxNodeDegree = degree;\n\t\t\tde = this.getNext(de);\n\t\t} while (de !== this.startDe);\n\t\tthis.maxNodeDegree *= 2;\n\t},\n\taddPoints: function (edge, isForward, isFirstEdge) {\n\t\tvar edgePts = edge.getCoordinates();\n\t\tif (isForward) {\n\t\t\tvar startIndex = 1;\n\t\t\tif (isFirstEdge) startIndex = 0;\n\t\t\tfor (var i = startIndex; i < edgePts.length; i++) {\n\t\t\t\tthis.pts.add(edgePts[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tvar startIndex = edgePts.length - 2;\n\t\t\tif (isFirstEdge) startIndex = edgePts.length - 1;\n\t\t\tfor (var i = startIndex; i >= 0; i--) {\n\t\t\t\tthis.pts.add(edgePts[i]);\n\t\t\t}\n\t\t}\n\t},\n\tisHole: function () {\n\t\treturn this._isHole;\n\t},\n\tsetInResult: function () {\n\t\tvar de = this.startDe;\n\t\tdo {\n\t\t\tde.getEdge().setInResult(true);\n\t\t\tde = de.getNext();\n\t\t} while (de !== this.startDe);\n\t},\n\tcontainsPoint: function (p) {\n\t\tvar shell = this.getLinearRing();\n\t\tvar env = shell.getEnvelopeInternal();\n\t\tif (!env.contains(p)) return false;\n\t\tif (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) return false;\n\t\tfor (var i = this.holes.iterator(); i.hasNext(); ) {\n\t\t\tvar hole = i.next();\n\t\t\tif (hole.containsPoint(p)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\taddHole: function (ring) {\n\t\tthis.holes.add(ring);\n\t},\n\tisShell: function () {\n\t\treturn this.shell === null;\n\t},\n\tgetLabel: function () {\n\t\treturn this.label;\n\t},\n\tgetEdges: function () {\n\t\treturn this.edges;\n\t},\n\tgetMaxNodeDegree: function () {\n\t\tif (this.maxNodeDegree < 0) this.computeMaxNodeDegree();\n\t\treturn this.maxNodeDegree;\n\t},\n\tgetShell: function () {\n\t\treturn this.shell;\n\t},\n\tmergeLabel: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet deLabel = arguments[0];\n\t\t\tthis.mergeLabel(deLabel, 0);\n\t\t\tthis.mergeLabel(deLabel, 1);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet deLabel = arguments[0], geomIndex = arguments[1];\n\t\t\tvar loc = deLabel.getLocation(geomIndex, Position.RIGHT);\n\t\t\tif (loc === Location.NONE) return null;\n\t\t\tif (this.label.getLocation(geomIndex) === Location.NONE) {\n\t\t\t\tthis.label.setLocation(geomIndex, loc);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tsetShell: function (shell) {\n\t\tthis.shell = shell;\n\t\tif (shell !== null) shell.addHole(this);\n\t},\n\ttoPolygon: function (geometryFactory) {\n\t\tvar holeLR = new Array(this.holes.size()).fill(null);\n\t\tfor (var i = 0; i < this.holes.size(); i++) {\n\t\t\tholeLR[i] = this.holes.get(i).getLinearRing();\n\t\t}\n\t\tvar poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n\t\treturn poly;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeRing;\n\t}\n});\n","import extend from '../../../../../extend';\nimport EdgeRing from '../../geomgraph/EdgeRing';\nimport inherits from '../../../../../inherits';\nexport default function MinimalEdgeRing() {\n\tlet start = arguments[0], geometryFactory = arguments[1];\n\tEdgeRing.call(this, start, geometryFactory);\n}\ninherits(MinimalEdgeRing, EdgeRing);\nextend(MinimalEdgeRing.prototype, {\n\tsetEdgeRing: function (de, er) {\n\t\tde.setMinEdgeRing(er);\n\t},\n\tgetNext: function (de) {\n\t\treturn de.getNextMin();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MinimalEdgeRing;\n\t}\n});\n","import MinimalEdgeRing from './MinimalEdgeRing';\nimport extend from '../../../../../extend';\nimport EdgeRing from '../../geomgraph/EdgeRing';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport inherits from '../../../../../inherits';\nexport default function MaximalEdgeRing() {\n\tlet start = arguments[0], geometryFactory = arguments[1];\n\tEdgeRing.call(this, start, geometryFactory);\n}\ninherits(MaximalEdgeRing, EdgeRing);\nextend(MaximalEdgeRing.prototype, {\n\tbuildMinimalRings: function () {\n\t\tvar minEdgeRings = new ArrayList();\n\t\tvar de = this.startDe;\n\t\tdo {\n\t\t\tif (de.getMinEdgeRing() === null) {\n\t\t\t\tvar minEr = new MinimalEdgeRing(de, this.geometryFactory);\n\t\t\t\tminEdgeRings.add(minEr);\n\t\t\t}\n\t\t\tde = de.getNext();\n\t\t} while (de !== this.startDe);\n\t\treturn minEdgeRings;\n\t},\n\tsetEdgeRing: function (de, er) {\n\t\tde.setEdgeRing(er);\n\t},\n\tlinkDirectedEdgesForMinimalEdgeRings: function () {\n\t\tvar de = this.startDe;\n\t\tdo {\n\t\t\tvar node = de.getNode();\n\t\t\tnode.getEdges().linkMinimalDirectedEdges(this);\n\t\t\tde = de.getNext();\n\t\t} while (de !== this.startDe);\n\t},\n\tgetNext: function (de) {\n\t\treturn de.getNext();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MaximalEdgeRing;\n\t}\n});\n","import extend from '../../../../extend';\nimport Assert from '../util/Assert';\nexport default function GraphComponent() {\n\tthis.label = null;\n\tthis._isInResult = false;\n\tthis._isCovered = false;\n\tthis._isCoveredSet = false;\n\tthis._isVisited = false;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet label = arguments[0];\n\t\tthis.label = label;\n\t}\n}\nextend(GraphComponent.prototype, {\n\tsetVisited: function (isVisited) {\n\t\tthis._isVisited = isVisited;\n\t},\n\tsetInResult: function (isInResult) {\n\t\tthis._isInResult = isInResult;\n\t},\n\tisCovered: function () {\n\t\treturn this._isCovered;\n\t},\n\tisCoveredSet: function () {\n\t\treturn this._isCoveredSet;\n\t},\n\tsetLabel: function (label) {\n\t\tthis.label = label;\n\t},\n\tgetLabel: function () {\n\t\treturn this.label;\n\t},\n\tsetCovered: function (isCovered) {\n\t\tthis._isCovered = isCovered;\n\t\tthis._isCoveredSet = true;\n\t},\n\tupdateIM: function (im) {\n\t\tAssert.isTrue(this.label.getGeometryCount() >= 2, \"found partial label\");\n\t\tthis.computeIM(im);\n\t},\n\tisInResult: function () {\n\t\treturn this._isInResult;\n\t},\n\tisVisited: function () {\n\t\treturn this._isVisited;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GraphComponent;\n\t}\n});\n","import Location from '../geom/Location';\nimport extend from '../../../../extend';\nimport Label from './Label';\nimport inherits from '../../../../inherits';\nimport GraphComponent from './GraphComponent';\nexport default function Node() {\n\tGraphComponent.apply(this);\n\tthis.coord = null;\n\tthis.edges = null;\n\tlet coord = arguments[0], edges = arguments[1];\n\tthis.coord = coord;\n\tthis.edges = edges;\n\tthis.label = new Label(0, Location.NONE);\n}\ninherits(Node, GraphComponent);\nextend(Node.prototype, {\n\tisIncidentEdgeInResult: function () {\n\t\tfor (var it = this.getEdges().getEdges().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getEdge().isInResult()) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tisIsolated: function () {\n\t\treturn this.label.getGeometryCount() === 1;\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.coord;\n\t},\n\tprint: function (out) {\n\t\tout.println(\"node \" + this.coord + \" lbl: \" + this.label);\n\t},\n\tcomputeIM: function (im) {},\n\tcomputeMergedLocation: function (label2, eltIndex) {\n\t\tvar loc = Location.NONE;\n\t\tloc = this.label.getLocation(eltIndex);\n\t\tif (!label2.isNull(eltIndex)) {\n\t\t\tvar nLoc = label2.getLocation(eltIndex);\n\t\t\tif (loc !== Location.BOUNDARY) loc = nLoc;\n\t\t}\n\t\treturn loc;\n\t},\n\tsetLabel: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet argIndex = arguments[0], onLocation = arguments[1];\n\t\t\tif (this.label === null) {\n\t\t\t\tthis.label = new Label(argIndex, onLocation);\n\t\t\t} else this.label.setLocation(argIndex, onLocation);\n\t\t} else return GraphComponent.prototype.setLabel.apply(this, arguments);\n\t},\n\tgetEdges: function () {\n\t\treturn this.edges;\n\t},\n\tmergeLabel: function () {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet n = arguments[0];\n\t\t\tthis.mergeLabel(n.label);\n\t\t} else if (arguments[0] instanceof Label) {\n\t\t\tlet label2 = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tvar loc = this.computeMergedLocation(label2, i);\n\t\t\t\tvar thisLoc = this.label.getLocation(i);\n\t\t\t\tif (thisLoc === Location.NONE) this.label.setLocation(i, loc);\n\t\t\t}\n\t\t}\n\t},\n\tadd: function (e) {\n\t\tthis.edges.insert(e);\n\t\te.setNode(this);\n\t},\n\tsetLabelBoundary: function (argIndex) {\n\t\tif (this.label === null) return null;\n\t\tvar loc = Location.NONE;\n\t\tif (this.label !== null) loc = this.label.getLocation(argIndex);\n\t\tvar newLoc = null;\n\t\tswitch (loc) {\n\t\t\tcase Location.BOUNDARY:\n\t\t\t\tnewLoc = Location.INTERIOR;\n\t\t\t\tbreak;\n\t\t\tcase Location.INTERIOR:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnewLoc = Location.BOUNDARY;\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.label.setLocation(argIndex, newLoc);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Node;\n\t}\n});\n","import Location from '../geom/Location';\nimport Coordinate from '../geom/Coordinate';\nimport Node from './Node';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function NodeMap() {\n\tthis.nodeMap = new TreeMap();\n\tthis.nodeFact = null;\n\tlet nodeFact = arguments[0];\n\tthis.nodeFact = nodeFact;\n}\nextend(NodeMap.prototype, {\n\tfind: function (coord) {\n\t\treturn this.nodeMap.get(coord);\n\t},\n\taddNode: function () {\n\t\tif (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\tvar node = this.nodeMap.get(coord);\n\t\t\tif (node === null) {\n\t\t\t\tnode = this.nodeFact.createNode(coord);\n\t\t\t\tthis.nodeMap.put(coord, node);\n\t\t\t}\n\t\t\treturn node;\n\t\t} else if (arguments[0] instanceof Node) {\n\t\t\tlet n = arguments[0];\n\t\t\tvar node = this.nodeMap.get(n.getCoordinate());\n\t\t\tif (node === null) {\n\t\t\t\tthis.nodeMap.put(n.getCoordinate(), n);\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tnode.mergeLabel(n);\n\t\t\treturn node;\n\t\t}\n\t},\n\tprint: function (out) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar n = it.next();\n\t\t\tn.print(out);\n\t\t}\n\t},\n\titerator: function () {\n\t\treturn this.nodeMap.values().iterator();\n\t},\n\tvalues: function () {\n\t\treturn this.nodeMap.values();\n\t},\n\tgetBoundaryNodes: function (geomIndex) {\n\t\tvar bdyNodes = new ArrayList();\n\t\tfor (var i = this.iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tif (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);\n\t\t}\n\t\treturn bdyNodes;\n\t},\n\tadd: function (e) {\n\t\tvar p = e.getCoordinate();\n\t\tvar n = this.addNode(p);\n\t\tn.add(e);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NodeMap;\n\t}\n});\n","import CGAlgorithms from '../algorithm/CGAlgorithms';\nimport extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nimport Quadrant from './Quadrant';\nimport Assert from '../util/Assert';\nexport default function EdgeEnd() {\n\tthis.edge = null;\n\tthis.label = null;\n\tthis.node = null;\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tthis.dx = null;\n\tthis.dy = null;\n\tthis.quadrant = null;\n\tif (arguments.length === 1) {\n\t\tlet edge = arguments[0];\n\t\tthis.edge = edge;\n\t} else if (arguments.length === 3) {\n\t\tlet edge = arguments[0], p0 = arguments[1], p1 = arguments[2];\n\t\tEdgeEnd.call(this, edge, p0, p1, null);\n\t} else if (arguments.length === 4) {\n\t\tlet edge = arguments[0], p0 = arguments[1], p1 = arguments[2], label = arguments[3];\n\t\tEdgeEnd.call(this, edge);\n\t\tthis.init(p0, p1);\n\t\tthis.label = label;\n\t}\n}\nextend(EdgeEnd.prototype, {\n\tcompareDirection: function (e) {\n\t\tif (this.dx === e.dx && this.dy === e.dy) return 0;\n\t\tif (this.quadrant > e.quadrant) return 1;\n\t\tif (this.quadrant < e.quadrant) return -1;\n\t\treturn CGAlgorithms.computeOrientation(e.p0, e.p1, this.p1);\n\t},\n\tgetDy: function () {\n\t\treturn this.dy;\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.p0;\n\t},\n\tsetNode: function (node) {\n\t\tthis.node = node;\n\t},\n\tprint: function (out) {\n\t\tvar angle = Math.atan2(this.dy, this.dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\tout.print(\"  \" + name + \": \" + this.p0 + \" - \" + this.p1 + \" \" + this.quadrant + \":\" + angle + \"   \" + this.label);\n\t},\n\tcompareTo: function (obj) {\n\t\tvar e = obj;\n\t\treturn this.compareDirection(e);\n\t},\n\tgetDirectedCoordinate: function () {\n\t\treturn this.p1;\n\t},\n\tgetDx: function () {\n\t\treturn this.dx;\n\t},\n\tgetLabel: function () {\n\t\treturn this.label;\n\t},\n\tgetEdge: function () {\n\t\treturn this.edge;\n\t},\n\tgetQuadrant: function () {\n\t\treturn this.quadrant;\n\t},\n\tgetNode: function () {\n\t\treturn this.node;\n\t},\n\ttoString: function () {\n\t\tvar angle = Math.atan2(this.dy, this.dx);\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\treturn \"  \" + name + \": \" + this.p0 + \" - \" + this.p1 + \" \" + this.quadrant + \":\" + angle + \"   \" + this.label;\n\t},\n\tcomputeLabel: function (boundaryNodeRule) {},\n\tinit: function (p0, p1) {\n\t\tthis.p0 = p0;\n\t\tthis.p1 = p1;\n\t\tthis.dx = p1.x - p0.x;\n\t\tthis.dy = p1.y - p0.y;\n\t\tthis.quadrant = Quadrant.quadrant(this.dx, this.dy);\n\t\tAssert.isTrue(!(this.dx === 0 && this.dy === 0), \"EdgeEnd with identical endpoints found\");\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeEnd;\n\t}\n});\n","import Location from '../geom/Location';\nimport EdgeEnd from './EdgeEnd';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport extend from '../../../../extend';\nimport Label from './Label';\nimport inherits from '../../../../inherits';\nexport default function DirectedEdge() {\n\tthis._isForward = null;\n\tthis._isInResult = false;\n\tthis._isVisited = false;\n\tthis.sym = null;\n\tthis.next = null;\n\tthis.nextMin = null;\n\tthis.edgeRing = null;\n\tthis.minEdgeRing = null;\n\tthis.depth = [0, -999, -999];\n\tlet edge = arguments[0], isForward = arguments[1];\n\tEdgeEnd.call(this, edge);\n\tthis._isForward = isForward;\n\tif (isForward) {\n\t\tthis.init(edge.getCoordinate(0), edge.getCoordinate(1));\n\t} else {\n\t\tvar n = edge.getNumPoints() - 1;\n\t\tthis.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n\t}\n\tthis.computeDirectedLabel();\n}\ninherits(DirectedEdge, EdgeEnd);\nextend(DirectedEdge.prototype, {\n\tgetNextMin: function () {\n\t\treturn this.nextMin;\n\t},\n\tgetDepth: function (position) {\n\t\treturn this.depth[position];\n\t},\n\tsetVisited: function (isVisited) {\n\t\tthis._isVisited = isVisited;\n\t},\n\tcomputeDirectedLabel: function () {\n\t\tthis.label = new Label(this.edge.getLabel());\n\t\tif (!this._isForward) this.label.flip();\n\t},\n\tgetNext: function () {\n\t\treturn this.next;\n\t},\n\tsetDepth: function (position, depthVal) {\n\t\tif (this.depth[position] !== -999) {\n\t\t\tif (this.depth[position] !== depthVal) throw new TopologyException(\"assigned depths do not match\", this.getCoordinate());\n\t\t}\n\t\tthis.depth[position] = depthVal;\n\t},\n\tisInteriorAreaEdge: function () {\n\t\tvar isInteriorAreaEdge = true;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!(this.label.isArea(i) && this.label.getLocation(i, Position.LEFT) === Location.INTERIOR && this.label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n\t\t\t\tisInteriorAreaEdge = false;\n\t\t\t}\n\t\t}\n\t\treturn isInteriorAreaEdge;\n\t},\n\tsetNextMin: function (nextMin) {\n\t\tthis.nextMin = nextMin;\n\t},\n\tprint: function (out) {\n\t\tEdgeEnd.prototype.print.call(this, out);\n\t\tout.print(\" \" + this.depth[Position.LEFT] + \"/\" + this.depth[Position.RIGHT]);\n\t\tout.print(\" (\" + this.getDepthDelta() + \")\");\n\t\tif (this._isInResult) out.print(\" inResult\");\n\t},\n\tsetMinEdgeRing: function (minEdgeRing) {\n\t\tthis.minEdgeRing = minEdgeRing;\n\t},\n\tisLineEdge: function () {\n\t\tvar isLine = this.label.isLine(0) || this.label.isLine(1);\n\t\tvar isExteriorIfArea0 = !this.label.isArea(0) || this.label.allPositionsEqual(0, Location.EXTERIOR);\n\t\tvar isExteriorIfArea1 = !this.label.isArea(1) || this.label.allPositionsEqual(1, Location.EXTERIOR);\n\t\treturn isLine && isExteriorIfArea0 && isExteriorIfArea1;\n\t},\n\tsetEdgeRing: function (edgeRing) {\n\t\tthis.edgeRing = edgeRing;\n\t},\n\tgetMinEdgeRing: function () {\n\t\treturn this.minEdgeRing;\n\t},\n\tgetDepthDelta: function () {\n\t\tvar depthDelta = this.edge.getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\treturn depthDelta;\n\t},\n\tsetInResult: function (isInResult) {\n\t\tthis._isInResult = isInResult;\n\t},\n\tgetSym: function () {\n\t\treturn this.sym;\n\t},\n\tisForward: function () {\n\t\treturn this._isForward;\n\t},\n\tgetEdge: function () {\n\t\treturn this.edge;\n\t},\n\tprintEdge: function (out) {\n\t\tthis.print(out);\n\t\tout.print(\" \");\n\t\tif (this._isForward) this.edge.print(out); else this.edge.printReverse(out);\n\t},\n\tsetSym: function (de) {\n\t\tthis.sym = de;\n\t},\n\tsetVisitedEdge: function (isVisited) {\n\t\tthis.setVisited(isVisited);\n\t\tthis.sym.setVisited(isVisited);\n\t},\n\tsetEdgeDepths: function (position, depth) {\n\t\tvar depthDelta = this.getEdge().getDepthDelta();\n\t\tif (!this._isForward) depthDelta = -depthDelta;\n\t\tvar directionFactor = 1;\n\t\tif (position === Position.LEFT) directionFactor = -1;\n\t\tvar oppositePos = Position.opposite(position);\n\t\tvar delta = depthDelta * directionFactor;\n\t\tvar oppositeDepth = depth + delta;\n\t\tthis.setDepth(position, depth);\n\t\tthis.setDepth(oppositePos, oppositeDepth);\n\t},\n\tgetEdgeRing: function () {\n\t\treturn this.edgeRing;\n\t},\n\tisInResult: function () {\n\t\treturn this._isInResult;\n\t},\n\tsetNext: function (next) {\n\t\tthis.next = next;\n\t},\n\tisVisited: function () {\n\t\treturn this._isVisited;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DirectedEdge;\n\t}\n});\nDirectedEdge.depthFactor = function (currLocation, nextLocation) {\n\tif (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1; else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;\n\treturn 0;\n};\n","import Node from './Node';\nimport extend from '../../../../extend';\nexport default function NodeFactory() {}\nextend(NodeFactory.prototype, {\n\tcreateNode: function (coord) {\n\t\treturn new Node(coord, null);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NodeFactory;\n\t}\n});\n","import Location from '../geom/Location';\nimport CGAlgorithms from '../algorithm/CGAlgorithms';\nimport Coordinate from '../geom/Coordinate';\nimport Node from './Node';\nimport extend from '../../../../extend';\nimport NodeMap from './NodeMap';\nimport DirectedEdge from './DirectedEdge';\nimport System from '../../../../java/lang/System';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Quadrant from './Quadrant';\nimport NodeFactory from './NodeFactory';\nexport default function PlanarGraph() {\n\tthis.edges = new ArrayList();\n\tthis.nodes = null;\n\tthis.edgeEndList = new ArrayList();\n\tif (arguments.length === 0) {\n\t\tthis.nodes = new NodeMap(new NodeFactory());\n\t} else if (arguments.length === 1) {\n\t\tlet nodeFact = arguments[0];\n\t\tthis.nodes = new NodeMap(nodeFact);\n\t}\n}\nextend(PlanarGraph.prototype, {\n\tprintEdges: function (out) {\n\t\tout.println(\"Edges:\");\n\t\tfor (var i = 0; i < this.edges.size(); i++) {\n\t\t\tout.println(\"edge \" + i + \":\");\n\t\t\tvar e = this.edges.get(i);\n\t\t\te.print(out);\n\t\t\te.eiList.print(out);\n\t\t}\n\t},\n\tfind: function (coord) {\n\t\treturn this.nodes.find(coord);\n\t},\n\taddNode: function () {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet node = arguments[0];\n\t\t\treturn this.nodes.addNode(node);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet coord = arguments[0];\n\t\t\treturn this.nodes.addNode(coord);\n\t\t}\n\t},\n\tgetNodeIterator: function () {\n\t\treturn this.nodes.iterator();\n\t},\n\tlinkResultDirectedEdges: function () {\n\t\tfor (var nodeit = this.nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkResultDirectedEdges();\n\t\t}\n\t},\n\tdebugPrintln: function (o) {\n\t\tSystem.out.println(o);\n\t},\n\tisBoundaryNode: function (geomIndex, coord) {\n\t\tvar node = this.nodes.find(coord);\n\t\tif (node === null) return false;\n\t\tvar label = node.getLabel();\n\t\tif (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;\n\t\treturn false;\n\t},\n\tlinkAllDirectedEdges: function () {\n\t\tfor (var nodeit = this.nodes.iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().linkAllDirectedEdges();\n\t\t}\n\t},\n\tmatchInSameDirection: function (p0, p1, ep0, ep1) {\n\t\tif (!p0.equals(ep0)) return false;\n\t\tif (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;\n\t\treturn false;\n\t},\n\tgetEdgeEnds: function () {\n\t\treturn this.edgeEndList;\n\t},\n\tdebugPrint: function (o) {\n\t\tSystem.out.print(o);\n\t},\n\tgetEdgeIterator: function () {\n\t\treturn this.edges.iterator();\n\t},\n\tfindEdgeInSameDirection: function (p0, p1) {\n\t\tfor (var i = 0; i < this.edges.size(); i++) {\n\t\t\tvar e = this.edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;\n\t\t\tif (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;\n\t\t}\n\t\treturn null;\n\t},\n\tinsertEdge: function (e) {\n\t\tthis.edges.add(e);\n\t},\n\tfindEdgeEnd: function (e) {\n\t\tfor (var i = this.getEdgeEnds().iterator(); i.hasNext(); ) {\n\t\t\tvar ee = i.next();\n\t\t\tif (ee.getEdge() === e) return ee;\n\t\t}\n\t\treturn null;\n\t},\n\taddEdges: function (edgesToAdd) {\n\t\tfor (var it = edgesToAdd.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tthis.edges.add(e);\n\t\t\tvar de1 = new DirectedEdge(e, true);\n\t\t\tvar de2 = new DirectedEdge(e, false);\n\t\t\tde1.setSym(de2);\n\t\t\tde2.setSym(de1);\n\t\t\tthis.add(de1);\n\t\t\tthis.add(de2);\n\t\t}\n\t},\n\tadd: function (e) {\n\t\tthis.nodes.add(e);\n\t\tthis.edgeEndList.add(e);\n\t},\n\tgetNodes: function () {\n\t\treturn this.nodes.values();\n\t},\n\tfindEdge: function (p0, p1) {\n\t\tfor (var i = 0; i < this.edges.size(); i++) {\n\t\t\tvar e = this.edges.get(i);\n\t\t\tvar eCoord = e.getCoordinates();\n\t\t\tif (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;\n\t\t}\n\t\treturn null;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PlanarGraph;\n\t}\n});\nPlanarGraph.linkResultDirectedEdges = function (nodes) {\n\tfor (var nodeit = nodes.iterator(); nodeit.hasNext(); ) {\n\t\tvar node = nodeit.next();\n\t\tnode.getEdges().linkResultDirectedEdges();\n\t}\n};\n","import CGAlgorithms from '../../algorithm/CGAlgorithms';\nimport TopologyException from '../../geom/TopologyException';\nimport extend from '../../../../../extend';\nimport MaximalEdgeRing from './MaximalEdgeRing';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport PlanarGraph from '../../geomgraph/PlanarGraph';\nexport default function PolygonBuilder() {\n\tthis.geometryFactory = null;\n\tthis.shellList = new ArrayList();\n\tlet geometryFactory = arguments[0];\n\tthis.geometryFactory = geometryFactory;\n}\nextend(PolygonBuilder.prototype, {\n\tsortShellsAndHoles: function (edgeRings, shellList, freeHoleList) {\n\t\tfor (var it = edgeRings.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.isHole()) {\n\t\t\t\tfreeHoleList.add(er);\n\t\t\t} else {\n\t\t\t\tshellList.add(er);\n\t\t\t}\n\t\t}\n\t},\n\tcomputePolygons: function (shellList) {\n\t\tvar resultPolyList = new ArrayList();\n\t\tfor (var it = shellList.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tvar poly = er.toPolygon(this.geometryFactory);\n\t\t\tresultPolyList.add(poly);\n\t\t}\n\t\treturn resultPolyList;\n\t},\n\tplaceFreeHoles: function (shellList, freeHoleList) {\n\t\tfor (var it = freeHoleList.iterator(); it.hasNext(); ) {\n\t\t\tvar hole = it.next();\n\t\t\tif (hole.getShell() === null) {\n\t\t\t\tvar shell = this.findEdgeRingContaining(hole, shellList);\n\t\t\t\tif (shell === null) throw new TopologyException(\"unable to assign hole to a shell\", hole.getCoordinate(0));\n\t\t\t\thole.setShell(shell);\n\t\t\t}\n\t\t}\n\t},\n\tbuildMinimalEdgeRings: function (maxEdgeRings, shellList, freeHoleList) {\n\t\tvar edgeRings = new ArrayList();\n\t\tfor (var it = maxEdgeRings.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.getMaxNodeDegree() > 2) {\n\t\t\t\ter.linkDirectedEdgesForMinimalEdgeRings();\n\t\t\t\tvar minEdgeRings = er.buildMinimalRings();\n\t\t\t\tvar shell = this.findShell(minEdgeRings);\n\t\t\t\tif (shell !== null) {\n\t\t\t\t\tthis.placePolygonHoles(shell, minEdgeRings);\n\t\t\t\t\tshellList.add(shell);\n\t\t\t\t} else {\n\t\t\t\t\tfreeHoleList.addAll(minEdgeRings);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tedgeRings.add(er);\n\t\t\t}\n\t\t}\n\t\treturn edgeRings;\n\t},\n\tcontainsPoint: function (p) {\n\t\tfor (var it = this.shellList.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.containsPoint(p)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tbuildMaximalEdgeRings: function (dirEdges) {\n\t\tvar maxEdgeRings = new ArrayList();\n\t\tfor (var it = dirEdges.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.isInResult() && de.getLabel().isArea()) {\n\t\t\t\tif (de.getEdgeRing() === null) {\n\t\t\t\t\tvar er = new MaximalEdgeRing(de, this.geometryFactory);\n\t\t\t\t\tmaxEdgeRings.add(er);\n\t\t\t\t\ter.setInResult();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxEdgeRings;\n\t},\n\tplacePolygonHoles: function (shell, minEdgeRings) {\n\t\tfor (var it = minEdgeRings.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tif (er.isHole()) {\n\t\t\t\ter.setShell(shell);\n\t\t\t}\n\t\t}\n\t},\n\tgetPolygons: function () {\n\t\tvar resultPolyList = this.computePolygons(this.shellList);\n\t\treturn resultPolyList;\n\t},\n\tfindEdgeRingContaining: function (testEr, shellList) {\n\t\tvar testRing = testEr.getLinearRing();\n\t\tvar testEnv = testRing.getEnvelopeInternal();\n\t\tvar testPt = testRing.getCoordinateN(0);\n\t\tvar minShell = null;\n\t\tvar minEnv = null;\n\t\tfor (var it = shellList.iterator(); it.hasNext(); ) {\n\t\t\tvar tryShell = it.next();\n\t\t\tvar tryRing = tryShell.getLinearRing();\n\t\t\tvar tryEnv = tryRing.getEnvelopeInternal();\n\t\t\tif (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();\n\t\t\tvar isContained = false;\n\t\t\tif (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) isContained = true;\n\t\t\tif (isContained) {\n\t\t\t\tif (minShell === null || minEnv.contains(tryEnv)) {\n\t\t\t\t\tminShell = tryShell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn minShell;\n\t},\n\tfindShell: function (minEdgeRings) {\n\t\tvar shellCount = 0;\n\t\tvar shell = null;\n\t\tfor (var it = minEdgeRings.iterator(); it.hasNext(); ) {\n\t\t\tvar er = it.next();\n\t\t\tif (!er.isHole()) {\n\t\t\t\tshell = er;\n\t\t\t\tshellCount++;\n\t\t\t}\n\t\t}\n\t\tAssert.isTrue(shellCount <= 1, \"found two shells in MinimalEdgeRing list\");\n\t\treturn shell;\n\t},\n\tadd: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet graph = arguments[0];\n\t\t\tthis.add(graph.getEdgeEnds(), graph.getNodes());\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet dirEdges = arguments[0], nodes = arguments[1];\n\t\t\tPlanarGraph.linkResultDirectedEdges(nodes);\n\t\t\tvar maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n\t\t\tvar freeHoleList = new ArrayList();\n\t\t\tvar edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this.shellList, freeHoleList);\n\t\t\tthis.sortShellsAndHoles(edgeRings, this.shellList, freeHoleList);\n\t\t\tthis.placeFreeHoles(this.shellList, freeHoleList);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PolygonBuilder;\n\t}\n});\n","import extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport OverlayOp from './OverlayOp';\nexport default function LineBuilder() {\n\tthis.op = null;\n\tthis.geometryFactory = null;\n\tthis.ptLocator = null;\n\tthis.lineEdgesList = new ArrayList();\n\tthis.resultLineList = new ArrayList();\n\tlet op = arguments[0], geometryFactory = arguments[1], ptLocator = arguments[2];\n\tthis.op = op;\n\tthis.geometryFactory = geometryFactory;\n\tthis.ptLocator = ptLocator;\n}\nextend(LineBuilder.prototype, {\n\tcollectLines: function (opCode) {\n\t\tfor (var it = this.op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tthis.collectLineEdge(de, opCode, this.lineEdgesList);\n\t\t\tthis.collectBoundaryTouchEdge(de, opCode, this.lineEdgesList);\n\t\t}\n\t},\n\tlabelIsolatedLine: function (e, targetIndex) {\n\t\tvar loc = this.ptLocator.locate(e.getCoordinate(), this.op.getArgGeometry(targetIndex));\n\t\te.getLabel().setLocation(targetIndex, loc);\n\t},\n\tbuild: function (opCode) {\n\t\tthis.findCoveredLineEdges();\n\t\tthis.collectLines(opCode);\n\t\tthis.buildLines(opCode);\n\t\treturn this.resultLineList;\n\t},\n\tcollectLineEdge: function (de, opCode, edges) {\n\t\tvar label = de.getLabel();\n\t\tvar e = de.getEdge();\n\t\tif (de.isLineEdge()) {\n\t\t\tif (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n\t\t\t\tedges.add(e);\n\t\t\t\tde.setVisitedEdge(true);\n\t\t\t}\n\t\t}\n\t},\n\tfindCoveredLineEdges: function () {\n\t\tfor (var nodeit = this.op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().findCoveredLineEdges();\n\t\t}\n\t\tfor (var it = this.op.getGraph().getEdgeEnds().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tvar e = de.getEdge();\n\t\t\tif (de.isLineEdge() && !e.isCoveredSet()) {\n\t\t\t\tvar isCovered = this.op.isCoveredByA(de.getCoordinate());\n\t\t\t\te.setCovered(isCovered);\n\t\t\t}\n\t\t}\n\t},\n\tlabelIsolatedLines: function (edgesList) {\n\t\tfor (var it = edgesList.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (e.isIsolated()) {\n\t\t\t\tif (label.isNull(0)) this.labelIsolatedLine(e, 0); else this.labelIsolatedLine(e, 1);\n\t\t\t}\n\t\t}\n\t},\n\tbuildLines: function (opCode) {\n\t\tfor (var it = this.lineEdgesList.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tvar line = this.geometryFactory.createLineString(e.getCoordinates());\n\t\t\tthis.resultLineList.add(line);\n\t\t\te.setInResult(true);\n\t\t}\n\t},\n\tcollectBoundaryTouchEdge: function (de, opCode, edges) {\n\t\tvar label = de.getLabel();\n\t\tif (de.isLineEdge()) return null;\n\t\tif (de.isVisited()) return null;\n\t\tif (de.isInteriorAreaEdge()) return null;\n\t\tif (de.getEdge().isInResult()) return null;\n\t\tAssert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n\t\tif (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n\t\t\tedges.add(de.getEdge());\n\t\t\tde.setVisitedEdge(true);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineBuilder;\n\t}\n});\n","import extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport OverlayOp from './OverlayOp';\nexport default function PointBuilder() {\n\tthis.op = null;\n\tthis.geometryFactory = null;\n\tthis.resultPointList = new ArrayList();\n\tlet op = arguments[0], geometryFactory = arguments[1], ptLocator = arguments[2];\n\tthis.op = op;\n\tthis.geometryFactory = geometryFactory;\n}\nextend(PointBuilder.prototype, {\n\tfilterCoveredNodeToPoint: function (n) {\n\t\tvar coord = n.getCoordinate();\n\t\tif (!this.op.isCoveredByLA(coord)) {\n\t\t\tvar pt = this.geometryFactory.createPoint(coord);\n\t\t\tthis.resultPointList.add(pt);\n\t\t}\n\t},\n\textractNonCoveredResultNodes: function (opCode) {\n\t\tfor (var nodeit = this.op.getGraph().getNodes().iterator(); nodeit.hasNext(); ) {\n\t\t\tvar n = nodeit.next();\n\t\t\tif (n.isInResult()) continue;\n\t\t\tif (n.isIncidentEdgeInResult()) continue;\n\t\t\tif (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n\t\t\t\tvar label = n.getLabel();\n\t\t\t\tif (OverlayOp.isResultOfOp(label, opCode)) {\n\t\t\t\t\tthis.filterCoveredNodeToPoint(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tbuild: function (opCode) {\n\t\tthis.extractNonCoveredResultNodes(opCode);\n\t\treturn this.resultPointList;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PointBuilder;\n\t}\n});\n","import extend from '../../../../../extend';\nexport default function PointOnGeometryLocator() {}\nextend(PointOnGeometryLocator.prototype, {\n\tlocate: function (p) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PointOnGeometryLocator;\n\t}\n});\n","import Location from '../../geom/Location';\nimport CGAlgorithms from '../CGAlgorithms';\nimport Polygon from '../../geom/Polygon';\nimport PointOnGeometryLocator from './PointOnGeometryLocator';\nimport extend from '../../../../../extend';\nimport GeometryCollectionIterator from '../../geom/GeometryCollectionIterator';\nimport GeometryCollection from '../../geom/GeometryCollection';\nexport default function SimplePointInAreaLocator() {\n\tthis.geom = null;\n\tlet geom = arguments[0];\n\tthis.geom = geom;\n}\nextend(SimplePointInAreaLocator.prototype, {\n\tlocate: function (p) {\n\t\treturn SimplePointInAreaLocator.locate(p, this.geom);\n\t},\n\tinterfaces_: function () {\n\t\treturn [PointOnGeometryLocator];\n\t},\n\tgetClass: function () {\n\t\treturn SimplePointInAreaLocator;\n\t}\n});\nSimplePointInAreaLocator.isPointInRing = function (p, ring) {\n\tif (!ring.getEnvelopeInternal().intersects(p)) return false;\n\treturn CGAlgorithms.isPointInRing(p, ring.getCoordinates());\n};\nSimplePointInAreaLocator.containsPointInPolygon = function (p, poly) {\n\tif (poly.isEmpty()) return false;\n\tvar shell = poly.getExteriorRing();\n\tif (!SimplePointInAreaLocator.isPointInRing(p, shell)) return false;\n\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\tvar hole = poly.getInteriorRingN(i);\n\t\tif (SimplePointInAreaLocator.isPointInRing(p, hole)) return false;\n\t}\n\treturn true;\n};\nSimplePointInAreaLocator.containsPoint = function (p, geom) {\n\tif (geom instanceof Polygon) {\n\t\treturn SimplePointInAreaLocator.containsPointInPolygon(p, geom);\n\t} else if (geom instanceof GeometryCollection) {\n\t\tvar geomi = new GeometryCollectionIterator(geom);\n\t\twhile (geomi.hasNext()) {\n\t\t\tvar g2 = geomi.next();\n\t\t\tif (g2 !== geom) if (SimplePointInAreaLocator.containsPoint(p, g2)) return true;\n\t\t}\n\t}\n\treturn false;\n};\nSimplePointInAreaLocator.locate = function (p, geom) {\n\tif (geom.isEmpty()) return Location.EXTERIOR;\n\tif (SimplePointInAreaLocator.containsPoint(p, geom)) return Location.INTERIOR;\n\treturn Location.EXTERIOR;\n};\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport Location from '../geom/Location';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport extend from '../../../../extend';\nimport System from '../../../../java/lang/System';\nimport SimplePointInAreaLocator from '../algorithm/locate/SimplePointInAreaLocator';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Assert from '../util/Assert';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function EdgeEndStar() {\n\tthis.edgeMap = new TreeMap();\n\tthis.edgeList = null;\n\tthis.ptInAreaLocation = [Location.NONE, Location.NONE];\n}\nextend(EdgeEndStar.prototype, {\n\tgetNextCW: function (ee) {\n\t\tthis.getEdges();\n\t\tvar i = this.edgeList.indexOf(ee);\n\t\tvar iNextCW = i - 1;\n\t\tif (i === 0) iNextCW = this.edgeList.size() - 1;\n\t\treturn this.edgeList.get(iNextCW);\n\t},\n\tpropagateSideLabels: function (geomIndex) {\n\t\tvar startLoc = Location.NONE;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t}\n\t\tif (startLoc === Location.NONE) return null;\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tif (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);\n\t\t\tif (label.isArea(geomIndex)) {\n\t\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\t\tif (rightLoc !== Location.NONE) {\n\t\t\t\t\tif (rightLoc !== currLoc) throw new TopologyException(\"side location conflict\", e.getCoordinate());\n\t\t\t\t\tif (leftLoc === Location.NONE) {\n\t\t\t\t\t\tAssert.shouldNeverReachHere(\"found single null side (at \" + e.getCoordinate() + \")\");\n\t\t\t\t\t}\n\t\t\t\t\tcurrLoc = leftLoc;\n\t\t\t\t} else {\n\t\t\t\t\tAssert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, \"found single null side\");\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.RIGHT, currLoc);\n\t\t\t\t\tlabel.setLocation(geomIndex, Position.LEFT, currLoc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function () {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext()) return null;\n\t\tvar e = it.next();\n\t\treturn e.getCoordinate();\n\t},\n\tprint: function (out) {\n\t\tSystem.out.println(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\te.print(out);\n\t\t}\n\t},\n\tisAreaLabelsConsistent: function (geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n\t\treturn this.checkAreaLabelsConsistent(0);\n\t},\n\tcheckAreaLabelsConsistent: function (geomIndex) {\n\t\tvar edges = this.getEdges();\n\t\tif (edges.size() <= 0) return true;\n\t\tvar lastEdgeIndex = edges.size() - 1;\n\t\tvar startLabel = edges.get(lastEdgeIndex).getLabel();\n\t\tvar startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n\t\tAssert.isTrue(startLoc !== Location.NONE, \"Found unlabelled area edge\");\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tAssert.isTrue(label.isArea(geomIndex), \"Found non-area edge\");\n\t\t\tvar leftLoc = label.getLocation(geomIndex, Position.LEFT);\n\t\t\tvar rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\t\t\tif (leftLoc === rightLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rightLoc !== currLoc) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcurrLoc = leftLoc;\n\t\t}\n\t\treturn true;\n\t},\n\tfindIndex: function (eSearch) {\n\t\tthis.iterator();\n\t\tfor (var i = 0; i < this.edgeList.size(); i++) {\n\t\t\tvar e = this.edgeList.get(i);\n\t\t\tif (e === eSearch) return i;\n\t\t}\n\t\treturn -1;\n\t},\n\titerator: function () {\n\t\treturn this.getEdges().iterator();\n\t},\n\tgetEdges: function () {\n\t\tif (this.edgeList === null) {\n\t\t\tthis.edgeList = new ArrayList(this.edgeMap.values());\n\t\t}\n\t\treturn this.edgeList;\n\t},\n\tgetLocation: function (geomIndex, p, geom) {\n\t\tif (this.ptInAreaLocation[geomIndex] === Location.NONE) {\n\t\t\tthis.ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n\t\t}\n\t\treturn this.ptInAreaLocation[geomIndex];\n\t},\n\ttoString: function () {\n\t\tvar buf = new StringBuffer();\n\t\tbuf.append(\"EdgeEndStar:   \" + this.getCoordinate());\n\t\tbuf.append(\"\\n\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tbuf.append(e);\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t},\n\tcomputeEdgeEndLabels: function (boundaryNodeRule) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tee.computeLabel(boundaryNodeRule);\n\t\t}\n\t},\n\tcomputeLabelling: function (geomGraph) {\n\t\tthis.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n\t\tthis.propagateSideLabels(0);\n\t\tthis.propagateSideLabels(1);\n\t\tvar hasDimensionalCollapseEdge = [false, false];\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;\n\t\t\t}\n\t\t}\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar label = e.getLabel();\n\t\t\tfor (var geomi = 0; geomi < 2; geomi++) {\n\t\t\t\tif (label.isAnyNull(geomi)) {\n\t\t\t\t\tvar loc = Location.NONE;\n\t\t\t\t\tif (hasDimensionalCollapseEdge[geomi]) {\n\t\t\t\t\t\tloc = Location.EXTERIOR;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar p = e.getCoordinate();\n\t\t\t\t\t\tloc = this.getLocation(geomi, p, geomGraph);\n\t\t\t\t\t}\n\t\t\t\t\tlabel.setAllLocationsIfNull(geomi, loc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetDegree: function () {\n\t\treturn this.edgeMap.size();\n\t},\n\tinsertEdgeEnd: function (e, obj) {\n\t\tthis.edgeMap.put(e, obj);\n\t\tthis.edgeList = null;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeEndStar;\n\t}\n});\n","import Location from '../geom/Location';\nimport Position from './Position';\nimport TopologyException from '../geom/TopologyException';\nimport extend from '../../../../extend';\nimport EdgeEndStar from './EdgeEndStar';\nimport System from '../../../../java/lang/System';\nimport Label from './Label';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Quadrant from './Quadrant';\nimport Assert from '../util/Assert';\nimport inherits from '../../../../inherits';\nexport default function DirectedEdgeStar() {\n\tEdgeEndStar.apply(this);\n\tthis.resultAreaEdgeList = null;\n\tthis.label = null;\n\tthis.SCANNING_FOR_INCOMING = 1;\n\tthis.LINKING_TO_OUTGOING = 2;\n}\ninherits(DirectedEdgeStar, EdgeEndStar);\nextend(DirectedEdgeStar.prototype, {\n\tlinkResultDirectedEdges: function () {\n\t\tthis.getResultAreaEdges();\n\t\tvar firstOut = null;\n\t\tvar incoming = null;\n\t\tvar state = this.SCANNING_FOR_INCOMING;\n\t\tfor (var i = 0; i < this.resultAreaEdgeList.size(); i++) {\n\t\t\tvar nextOut = this.resultAreaEdgeList.get(i);\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (!nextOut.getLabel().isArea()) continue;\n\t\t\tif (firstOut === null && nextOut.isInResult()) firstOut = nextOut;\n\t\t\tswitch (state) {\n\t\t\t\tcase this.SCANNING_FOR_INCOMING:\n\t\t\t\t\tif (!nextIn.isInResult()) continue;\n\t\t\t\t\tincoming = nextIn;\n\t\t\t\t\tstate = this.LINKING_TO_OUTGOING;\n\t\t\t\t\tbreak;\n\t\t\t\tcase this.LINKING_TO_OUTGOING:\n\t\t\t\t\tif (!nextOut.isInResult()) continue;\n\t\t\t\t\tincoming.setNext(nextOut);\n\t\t\t\t\tstate = this.SCANNING_FOR_INCOMING;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (state === this.LINKING_TO_OUTGOING) {\n\t\t\tif (firstOut === null) throw new TopologyException(\"no outgoing dirEdge found\", this.getCoordinate());\n\t\t\tAssert.isTrue(firstOut.isInResult(), \"unable to link last incoming dirEdge\");\n\t\t\tincoming.setNext(firstOut);\n\t\t}\n\t},\n\tinsert: function (ee) {\n\t\tvar de = ee;\n\t\tthis.insertEdgeEnd(de, de);\n\t},\n\tgetRightmostEdge: function () {\n\t\tvar edges = this.getEdges();\n\t\tvar size = edges.size();\n\t\tif (size < 1) return null;\n\t\tvar de0 = edges.get(0);\n\t\tif (size === 1) return de0;\n\t\tvar deLast = edges.get(size - 1);\n\t\tvar quad0 = de0.getQuadrant();\n\t\tvar quad1 = deLast.getQuadrant();\n\t\tif (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) return de0; else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) return deLast; else {\n\t\t\tvar nonHorizontalEdge = null;\n\t\t\tif (de0.getDy() !== 0) return de0; else if (deLast.getDy() !== 0) return deLast;\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"found two horizontal edges incident on node\");\n\t\treturn null;\n\t},\n\tprint: function (out) {\n\t\tSystem.out.println(\"DirectedEdgeStar: \" + this.getCoordinate());\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tout.print(\"out \");\n\t\t\tde.print(out);\n\t\t\tout.println();\n\t\t\tout.print(\"in \");\n\t\t\tde.getSym().print(out);\n\t\t\tout.println();\n\t\t}\n\t},\n\tgetResultAreaEdges: function () {\n\t\tif (this.resultAreaEdgeList !== null) return this.resultAreaEdgeList;\n\t\tthis.resultAreaEdgeList = new ArrayList();\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.isInResult() || de.getSym().isInResult()) this.resultAreaEdgeList.add(de);\n\t\t}\n\t\treturn this.resultAreaEdgeList;\n\t},\n\tupdateLabelling: function (nodeLabel) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tlabel.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n\t\t\tlabel.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n\t\t}\n\t},\n\tlinkAllDirectedEdges: function () {\n\t\tthis.getEdges();\n\t\tvar prevOut = null;\n\t\tvar firstIn = null;\n\t\tfor (var i = this.edgeList.size() - 1; i >= 0; i--) {\n\t\t\tvar nextOut = this.edgeList.get(i);\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (firstIn === null) firstIn = nextIn;\n\t\t\tif (prevOut !== null) nextIn.setNext(prevOut);\n\t\t\tprevOut = nextOut;\n\t\t}\n\t\tfirstIn.setNext(prevOut);\n\t},\n\tcomputeDepths: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet de = arguments[0];\n\t\t\tvar edgeIndex = this.findIndex(de);\n\t\t\tvar label = de.getLabel();\n\t\t\tvar startDepth = de.getDepth(Position.LEFT);\n\t\t\tvar targetLastDepth = de.getDepth(Position.RIGHT);\n\t\t\tvar nextDepth = this.computeDepths(edgeIndex + 1, this.edgeList.size(), startDepth);\n\t\t\tvar lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n\t\t\tif (lastDepth !== targetLastDepth) throw new TopologyException(\"depth mismatch at \" + de.getCoordinate());\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet startIndex = arguments[0], endIndex = arguments[1], startDepth = arguments[2];\n\t\t\tvar currDepth = startDepth;\n\t\t\tfor (var i = startIndex; i < endIndex; i++) {\n\t\t\t\tvar nextDe = this.edgeList.get(i);\n\t\t\t\tvar label = nextDe.getLabel();\n\t\t\t\tnextDe.setEdgeDepths(Position.RIGHT, currDepth);\n\t\t\t\tcurrDepth = nextDe.getDepth(Position.LEFT);\n\t\t\t}\n\t\t\treturn currDepth;\n\t\t}\n\t},\n\tmergeSymLabels: function () {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tlabel.merge(de.getSym().getLabel());\n\t\t}\n\t},\n\tlinkMinimalDirectedEdges: function (er) {\n\t\tvar firstOut = null;\n\t\tvar incoming = null;\n\t\tvar state = this.SCANNING_FOR_INCOMING;\n\t\tfor (var i = this.resultAreaEdgeList.size() - 1; i >= 0; i--) {\n\t\t\tvar nextOut = this.resultAreaEdgeList.get(i);\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;\n\t\t\tswitch (state) {\n\t\t\t\tcase this.SCANNING_FOR_INCOMING:\n\t\t\t\t\tif (nextIn.getEdgeRing() !== er) continue;\n\t\t\t\t\tincoming = nextIn;\n\t\t\t\t\tstate = this.LINKING_TO_OUTGOING;\n\t\t\t\t\tbreak;\n\t\t\t\tcase this.LINKING_TO_OUTGOING:\n\t\t\t\t\tif (nextOut.getEdgeRing() !== er) continue;\n\t\t\t\t\tincoming.setNextMin(nextOut);\n\t\t\t\t\tstate = this.SCANNING_FOR_INCOMING;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (state === this.LINKING_TO_OUTGOING) {\n\t\t\tAssert.isTrue(firstOut !== null, \"found null for first outgoing dirEdge\");\n\t\t\tAssert.isTrue(firstOut.getEdgeRing() === er, \"unable to link last incoming dirEdge\");\n\t\t\tincoming.setNextMin(firstOut);\n\t\t}\n\t},\n\tgetOutgoingDegree: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tvar degree = 0;\n\t\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\t\tvar de = it.next();\n\t\t\t\tif (de.isInResult()) degree++;\n\t\t\t}\n\t\t\treturn degree;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet er = arguments[0];\n\t\t\tvar degree = 0;\n\t\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\t\tvar de = it.next();\n\t\t\t\tif (de.getEdgeRing() === er) degree++;\n\t\t\t}\n\t\t\treturn degree;\n\t\t}\n\t},\n\tgetLabel: function () {\n\t\treturn this.label;\n\t},\n\tfindCoveredLineEdges: function () {\n\t\tvar startLoc = Location.NONE;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar nextOut = it.next();\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (!nextOut.isLineEdge()) {\n\t\t\t\tif (nextOut.isInResult()) {\n\t\t\t\t\tstartLoc = Location.INTERIOR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (nextIn.isInResult()) {\n\t\t\t\t\tstartLoc = Location.EXTERIOR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (startLoc === Location.NONE) return null;\n\t\tvar currLoc = startLoc;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar nextOut = it.next();\n\t\t\tvar nextIn = nextOut.getSym();\n\t\t\tif (nextOut.isLineEdge()) {\n\t\t\t\tnextOut.getEdge().setCovered(currLoc === Location.INTERIOR);\n\t\t\t} else {\n\t\t\t\tif (nextOut.isInResult()) currLoc = Location.EXTERIOR;\n\t\t\t\tif (nextIn.isInResult()) currLoc = Location.INTERIOR;\n\t\t\t}\n\t\t}\n\t},\n\tcomputeLabelling: function (geom) {\n\t\tEdgeEndStar.prototype.computeLabelling.call(this, geom);\n\t\tthis.label = new Label(Location.NONE);\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tvar e = ee.getEdge();\n\t\t\tvar eLabel = e.getLabel();\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tvar eLoc = eLabel.getLocation(i);\n\t\t\t\tif (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this.label.setLocation(i, Location.INTERIOR);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DirectedEdgeStar;\n\t}\n});\n","import DirectedEdgeStar from '../../geomgraph/DirectedEdgeStar';\nimport Node from '../../geomgraph/Node';\nimport extend from '../../../../../extend';\nimport inherits from '../../../../../inherits';\nimport NodeFactory from '../../geomgraph/NodeFactory';\nexport default function OverlayNodeFactory() {\n\tNodeFactory.apply(this);\n}\ninherits(OverlayNodeFactory, NodeFactory);\nextend(OverlayNodeFactory.prototype, {\n\tcreateNode: function (coord) {\n\t\treturn new Node(coord, new DirectedEdgeStar());\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OverlayNodeFactory;\n\t}\n});\n","import extend from '../../../../../extend';\nexport default function MonotoneChain() {\n\tthis.mce = null;\n\tthis.chainIndex = null;\n\tlet mce = arguments[0], chainIndex = arguments[1];\n\tthis.mce = mce;\n\tthis.chainIndex = chainIndex;\n}\nextend(MonotoneChain.prototype, {\n\tcomputeIntersections: function (mc, si) {\n\t\tthis.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChain;\n\t}\n});\n","import extend from '../../../../../extend';\nimport Comparable from '../../../../../java/lang/Comparable';\nexport default function SweepLineEvent() {\n\tthis.label = null;\n\tthis.xValue = null;\n\tthis.eventType = null;\n\tthis.insertEvent = null;\n\tthis.deleteEventIndex = null;\n\tthis.obj = null;\n\tif (arguments.length === 2) {\n\t\tlet x = arguments[0], insertEvent = arguments[1];\n\t\tthis.eventType = SweepLineEvent.DELETE;\n\t\tthis.xValue = x;\n\t\tthis.insertEvent = insertEvent;\n\t} else if (arguments.length === 3) {\n\t\tlet label = arguments[0], x = arguments[1], obj = arguments[2];\n\t\tthis.eventType = SweepLineEvent.INSERT;\n\t\tthis.label = label;\n\t\tthis.xValue = x;\n\t\tthis.obj = obj;\n\t}\n}\nextend(SweepLineEvent.prototype, {\n\tisDelete: function () {\n\t\treturn this.eventType === SweepLineEvent.DELETE;\n\t},\n\tsetDeleteEventIndex: function (deleteEventIndex) {\n\t\tthis.deleteEventIndex = deleteEventIndex;\n\t},\n\tgetObject: function () {\n\t\treturn this.obj;\n\t},\n\tcompareTo: function (o) {\n\t\tvar pe = o;\n\t\tif (this.xValue < pe.xValue) return -1;\n\t\tif (this.xValue > pe.xValue) return 1;\n\t\tif (this.eventType < pe.eventType) return -1;\n\t\tif (this.eventType > pe.eventType) return 1;\n\t\treturn 0;\n\t},\n\tgetInsertEvent: function () {\n\t\treturn this.insertEvent;\n\t},\n\tisInsert: function () {\n\t\treturn this.eventType === SweepLineEvent.INSERT;\n\t},\n\tisSameLabel: function (ev) {\n\t\tif (this.label === null) return false;\n\t\treturn this.label === ev.label;\n\t},\n\tgetDeleteEventIndex: function () {\n\t\treturn this.deleteEventIndex;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn SweepLineEvent;\n\t}\n});\nSweepLineEvent.INSERT = 1;\nSweepLineEvent.DELETE = 2;\n","import extend from '../../../../../extend';\nexport default function EdgeSetIntersector() {}\nextend(EdgeSetIntersector.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeSetIntersector;\n\t}\n});\n","import extend from '../../../../../extend';\nexport default function SegmentIntersector() {\n\tthis._hasIntersection = false;\n\tthis.hasProper = false;\n\tthis.hasProperInterior = false;\n\tthis.properIntersectionPoint = null;\n\tthis.li = null;\n\tthis.includeProper = null;\n\tthis.recordIsolated = null;\n\tthis.isSelfIntersection = null;\n\tthis.numIntersections = 0;\n\tthis.numTests = 0;\n\tthis.bdyNodes = null;\n\tthis._isDone = false;\n\tthis.isDoneWhenProperInt = false;\n\tlet li = arguments[0], includeProper = arguments[1], recordIsolated = arguments[2];\n\tthis.li = li;\n\tthis.includeProper = includeProper;\n\tthis.recordIsolated = recordIsolated;\n}\nextend(SegmentIntersector.prototype, {\n\tisTrivialIntersection: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1) {\n\t\t\tif (this.li.getIntersectionNum() === 1) {\n\t\t\t\tif (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\t\t\t\tif (e0.isClosed()) {\n\t\t\t\t\tvar maxSegIndex = e0.getNumPoints() - 1;\n\t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetProperIntersectionPoint: function () {\n\t\treturn this.properIntersectionPoint;\n\t},\n\tsetIsDoneIfProperInt: function (isDoneWhenProperInt) {\n\t\tthis.isDoneWhenProperInt = isDoneWhenProperInt;\n\t},\n\thasProperInteriorIntersection: function () {\n\t\treturn this.hasProperInterior;\n\t},\n\tisBoundaryPointInternal: function (li, bdyNodes) {\n\t\tfor (var i = bdyNodes.iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tvar pt = node.getCoordinate();\n\t\t\tif (li.isIntersection(pt)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\thasProperIntersection: function () {\n\t\treturn this.hasProper;\n\t},\n\thasIntersection: function () {\n\t\treturn this._hasIntersection;\n\t},\n\tisDone: function () {\n\t\treturn this._isDone;\n\t},\n\tisBoundaryPoint: function (li, bdyNodes) {\n\t\tif (bdyNodes === null) return false;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;\n\t\tif (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;\n\t\treturn false;\n\t},\n\tsetBoundaryNodes: function (bdyNodes0, bdyNodes1) {\n\t\tthis.bdyNodes = new Array(2).fill(null);\n\t\tthis.bdyNodes[0] = bdyNodes0;\n\t\tthis.bdyNodes[1] = bdyNodes1;\n\t},\n\taddIntersections: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tthis.numTests++;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis.li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this.li.hasIntersection()) {\n\t\t\tif (this.recordIsolated) {\n\t\t\t\te0.setIsolated(false);\n\t\t\t\te1.setIsolated(false);\n\t\t\t}\n\t\t\tthis.numIntersections++;\n\t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\tif (this.includeProper || !this.li.isProper()) {\n\t\t\t\t\te0.addIntersections(this.li, segIndex0, 0);\n\t\t\t\t\te1.addIntersections(this.li, segIndex1, 1);\n\t\t\t\t}\n\t\t\t\tif (this.li.isProper()) {\n\t\t\t\t\tthis.properIntersectionPoint = this.li.getIntersection(0).copy();\n\t\t\t\t\tthis.hasProper = true;\n\t\t\t\t\tif (this.isDoneWhenProperInt) {\n\t\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.isBoundaryPoint(this.li, this.bdyNodes)) this.hasProperInterior = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentIntersector;\n\t}\n});\nSegmentIntersector.isAdjacentSegments = function (i1, i2) {\n\treturn Math.abs(i1 - i2) === 1;\n};\n","import hasInterface from '../../../../../hasInterface';\nimport MonotoneChain from './MonotoneChain';\nimport SweepLineEvent from './SweepLineEvent';\nimport EdgeSetIntersector from './EdgeSetIntersector';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport SegmentIntersector from './SegmentIntersector';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport inherits from '../../../../../inherits';\nimport List from '../../../../../java/util/List';\nexport default function SimpleMCSweepLineIntersector() {\n\tEdgeSetIntersector.apply(this);\n\tthis.events = new ArrayList();\n\tthis.nOverlaps = null;\n}\ninherits(SimpleMCSweepLineIntersector, EdgeSetIntersector);\nextend(SimpleMCSweepLineIntersector.prototype, {\n\tprepareEvents: function () {\n\t\tCollections.sort(this.events);\n\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\tvar ev = this.events.get(i);\n\t\t\tif (ev.isDelete()) {\n\t\t\t\tev.getInsertEvent().setDeleteEventIndex(i);\n\t\t\t}\n\t\t}\n\t},\n\tcomputeIntersections: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet si = arguments[0];\n\t\t\tthis.nOverlaps = 0;\n\t\t\tthis.prepareEvents();\n\t\t\tfor (var i = 0; i < this.events.size(); i++) {\n\t\t\t\tvar ev = this.events.get(i);\n\t\t\t\tif (ev.isInsert()) {\n\t\t\t\t\tthis.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n\t\t\t\t}\n\t\t\t\tif (si.isDone()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (arguments[2] instanceof SegmentIntersector && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n\t\t\t\tlet edges0 = arguments[0], edges1 = arguments[1], si = arguments[2];\n\t\t\t\tthis.addEdges(edges0, edges0);\n\t\t\t\tthis.addEdges(edges1, edges1);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t} else if (typeof arguments[2] === \"boolean\" && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector)) {\n\t\t\t\tlet edges = arguments[0], si = arguments[1], testAllSegments = arguments[2];\n\t\t\t\tif (testAllSegments) this.addEdges(edges, null); else this.addEdges(edges);\n\t\t\t\tthis.computeIntersections(si);\n\t\t\t}\n\t\t}\n\t},\n\taddEdge: function (edge, edgeSet) {\n\t\tvar mce = edge.getMonotoneChainEdge();\n\t\tvar startIndex = mce.getStartIndexes();\n\t\tfor (var i = 0; i < startIndex.length - 1; i++) {\n\t\t\tvar mc = new MonotoneChain(mce, i);\n\t\t\tvar insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n\t\t\tthis.events.add(insertEvent);\n\t\t\tthis.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n\t\t}\n\t},\n\tprocessOverlaps: function (start, end, ev0, si) {\n\t\tvar mc0 = ev0.getObject();\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar ev1 = this.events.get(i);\n\t\t\tif (ev1.isInsert()) {\n\t\t\t\tvar mc1 = ev1.getObject();\n\t\t\t\tif (!ev0.isSameLabel(ev1)) {\n\t\t\t\t\tmc0.computeIntersections(mc1, si);\n\t\t\t\t\tthis.nOverlaps++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\taddEdges: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet edges = arguments[0];\n\t\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edge);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet edges = arguments[0], edgeSet = arguments[1];\n\t\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar edge = i.next();\n\t\t\t\tthis.addEdge(edge, edgeSet);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SimpleMCSweepLineIntersector;\n\t}\n});\n","import WKTWriter from '../../io/WKTWriter';\nimport Coordinate from '../../geom/Coordinate';\nimport Double from '../../../../../java/lang/Double';\nimport extend from '../../../../../extend';\nimport Comparator from '../../../../../java/util/Comparator';\nexport default function IntervalRTreeNode() {\n\tthis.min = Double.POSITIVE_INFINITY;\n\tthis.max = Double.NEGATIVE_INFINITY;\n}\nextend(IntervalRTreeNode.prototype, {\n\tgetMin: function () {\n\t\treturn this.min;\n\t},\n\tintersects: function (queryMin, queryMax) {\n\t\tif (this.min > queryMax || this.max < queryMin) return false;\n\t\treturn true;\n\t},\n\tgetMax: function () {\n\t\treturn this.max;\n\t},\n\ttoString: function () {\n\t\treturn WKTWriter.toLineString(new Coordinate(this.min, 0), new Coordinate(this.max, 0));\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IntervalRTreeNode;\n\t}\n});\nfunction NodeComparator() {}\nextend(NodeComparator.prototype, {\n\tcompare: function (o1, o2) {\n\t\tvar n1 = o1;\n\t\tvar n2 = o2;\n\t\tvar mid1 = (n1.min + n1.max) / 2;\n\t\tvar mid2 = (n2.min + n2.max) / 2;\n\t\tif (mid1 < mid2) return -1;\n\t\tif (mid1 > mid2) return 1;\n\t\treturn 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function () {\n\t\treturn NodeComparator;\n\t}\n});\nIntervalRTreeNode.NodeComparator = NodeComparator;\n","import IntervalRTreeNode from './IntervalRTreeNode';\nimport extend from '../../../../../extend';\nimport inherits from '../../../../../inherits';\nexport default function IntervalRTreeLeafNode() {\n\tIntervalRTreeNode.apply(this);\n\tthis.item = null;\n\tlet min = arguments[0], max = arguments[1], item = arguments[2];\n\tthis.min = min;\n\tthis.max = max;\n\tthis.item = item;\n}\ninherits(IntervalRTreeLeafNode, IntervalRTreeNode);\nextend(IntervalRTreeLeafNode.prototype, {\n\tquery: function (queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) return null;\n\t\tvisitor.visitItem(this.item);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IntervalRTreeLeafNode;\n\t}\n});\n","import IntervalRTreeNode from './IntervalRTreeNode';\nimport extend from '../../../../../extend';\nimport inherits from '../../../../../inherits';\nexport default function IntervalRTreeBranchNode() {\n\tIntervalRTreeNode.apply(this);\n\tthis.node1 = null;\n\tthis.node2 = null;\n\tlet n1 = arguments[0], n2 = arguments[1];\n\tthis.node1 = n1;\n\tthis.node2 = n2;\n\tthis.buildExtent(this.node1, this.node2);\n}\ninherits(IntervalRTreeBranchNode, IntervalRTreeNode);\nextend(IntervalRTreeBranchNode.prototype, {\n\tbuildExtent: function (n1, n2) {\n\t\tthis.min = Math.min(n1.min, n2.min);\n\t\tthis.max = Math.max(n1.max, n2.max);\n\t},\n\tquery: function (queryMin, queryMax, visitor) {\n\t\tif (!this.intersects(queryMin, queryMax)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.node1 !== null) this.node1.query(queryMin, queryMax, visitor);\n\t\tif (this.node2 !== null) this.node2.query(queryMin, queryMax, visitor);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IntervalRTreeBranchNode;\n\t}\n});\n","import WKTWriter from '../../io/WKTWriter';\nimport Coordinate from '../../geom/Coordinate';\nimport IntervalRTreeLeafNode from './IntervalRTreeLeafNode';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport System from '../../../../../java/lang/System';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport IntervalRTreeBranchNode from './IntervalRTreeBranchNode';\nexport default function SortedPackedIntervalRTree() {\n\tthis.leaves = new ArrayList();\n\tthis.root = null;\n\tthis.level = 0;\n}\nextend(SortedPackedIntervalRTree.prototype, {\n\tbuildTree: function () {\n\t\tCollections.sort(this.leaves, new IntervalRTreeNode.NodeComparator());\n\t\tvar src = this.leaves;\n\t\tvar temp = null;\n\t\tvar dest = new ArrayList();\n\t\twhile (true) {\n\t\t\tthis.buildLevel(src, dest);\n\t\t\tif (dest.size() === 1) return dest.get(0);\n\t\t\ttemp = src;\n\t\t\tsrc = dest;\n\t\t\tdest = temp;\n\t\t}\n\t},\n\tinsert: function (min, max, item) {\n\t\tif (this.root !== null) throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\n\t\tthis.leaves.add(new IntervalRTreeLeafNode(min, max, item));\n\t},\n\tquery: function (min, max, visitor) {\n\t\tthis.init();\n\t\tthis.root.query(min, max, visitor);\n\t},\n\tbuildRoot: function () {\n\t\tif (this.root !== null) return null;\n\t\tthis.root = this.buildTree();\n\t},\n\tprintNode: function (node) {\n\t\tSystem.out.println(WKTWriter.toLineString(new Coordinate(node.min, this.level), new Coordinate(node.max, this.level)));\n\t},\n\tinit: function () {\n\t\tif (this.root !== null) return null;\n\t\tthis.buildRoot();\n\t},\n\tbuildLevel: function (src, dest) {\n\t\tthis.level++;\n\t\tdest.clear();\n\t\tfor (var i = 0; i < src.size(); i += 2) {\n\t\t\tvar n1 = src.get(i);\n\t\t\tvar n2 = i + 1 < src.size() ? src.get(i) : null;\n\t\t\tif (n2 === null) {\n\t\t\t\tdest.add(n1);\n\t\t\t} else {\n\t\t\t\tvar node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n\t\t\t\tdest.add(node);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SortedPackedIntervalRTree;\n\t}\n});\n","import LineString from '../LineString';\nimport Geometry from '../Geometry';\nimport hasInterface from '../../../../../hasInterface';\nimport Collection from '../../../../../java/util/Collection';\nimport LinearRing from '../LinearRing';\nimport extend from '../../../../../extend';\nimport GeometryComponentFilter from '../GeometryComponentFilter';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function LinearComponentExtracter() {\n\tthis.lines = null;\n\tthis.isForcedToLineString = false;\n\tif (arguments.length === 1) {\n\t\tlet lines = arguments[0];\n\t\tthis.lines = lines;\n\t} else if (arguments.length === 2) {\n\t\tlet lines = arguments[0], isForcedToLineString = arguments[1];\n\t\tthis.lines = lines;\n\t\tthis.isForcedToLineString = isForcedToLineString;\n\t}\n}\nextend(LinearComponentExtracter.prototype, {\n\tfilter: function (geom) {\n\t\tif (this.isForcedToLineString && geom instanceof LinearRing) {\n\t\t\tvar line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n\t\t\tthis.lines.add(line);\n\t\t\treturn null;\n\t\t}\n\t\tif (geom instanceof LineString) this.lines.add(geom);\n\t},\n\tsetForceToLineString: function (isForcedToLineString) {\n\t\tthis.isForcedToLineString = isForcedToLineString;\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tgetClass: function () {\n\t\treturn LinearComponentExtracter;\n\t}\n});\nLinearComponentExtracter.getGeometry = function () {\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n\t} else if (arguments.length === 2) {\n\t\tlet geom = arguments[0], forceToLineString = arguments[1];\n\t\treturn geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));\n\t}\n};\nLinearComponentExtracter.getLines = function () {\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\treturn LinearComponentExtracter.getLines(geom, false);\n\t} else if (arguments.length === 2) {\n\t\tif (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n\t\t\tlet geoms = arguments[0], lines = arguments[1];\n\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\tvar g = i.next();\n\t\t\t\tLinearComponentExtracter.getLines(g, lines);\n\t\t\t}\n\t\t\treturn lines;\n\t\t} else if (arguments[0] instanceof Geometry && typeof arguments[1] === \"boolean\") {\n\t\t\tlet geom = arguments[0], forceToLineString = arguments[1];\n\t\t\tvar lines = new ArrayList();\n\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\treturn lines;\n\t\t} else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n\t\t\tlet geom = arguments[0], lines = arguments[1];\n\t\t\tif (geom instanceof LineString) {\n\t\t\t\tlines.add(geom);\n\t\t\t} else {\n\t\t\t\tgeom.apply(new LinearComponentExtracter(lines));\n\t\t\t}\n\t\t\treturn lines;\n\t\t}\n\t} else if (arguments.length === 3) {\n\t\tif (typeof arguments[2] === \"boolean\" && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {\n\t\t\tlet geoms = arguments[0], lines = arguments[1], forceToLineString = arguments[2];\n\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\tvar g = i.next();\n\t\t\t\tLinearComponentExtracter.getLines(g, lines, forceToLineString);\n\t\t\t}\n\t\t\treturn lines;\n\t\t} else if (typeof arguments[2] === \"boolean\" && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {\n\t\t\tlet geom = arguments[0], lines = arguments[1], forceToLineString = arguments[2];\n\t\t\tgeom.apply(new LinearComponentExtracter(lines, forceToLineString));\n\t\t\treturn lines;\n\t\t}\n\t}\n};\n","import ItemVisitor from './ItemVisitor';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function ArrayListVisitor() {\n\tthis.items = new ArrayList();\n}\nextend(ArrayListVisitor.prototype, {\n\tvisitItem: function (item) {\n\t\tthis.items.add(item);\n\t},\n\tgetItems: function () {\n\t\treturn this.items;\n\t},\n\tinterfaces_: function () {\n\t\treturn [ItemVisitor];\n\t},\n\tgetClass: function () {\n\t\treturn ArrayListVisitor;\n\t}\n});\n","import hasInterface from '../../../../../hasInterface';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport ItemVisitor from '../../index/ItemVisitor';\nimport PointOnGeometryLocator from './PointOnGeometryLocator';\nimport extend from '../../../../../extend';\nimport SortedPackedIntervalRTree from '../../index/intervalrtree/SortedPackedIntervalRTree';\nimport LineSegment from '../../geom/LineSegment';\nimport Polygonal from '../../geom/Polygonal';\nimport LinearComponentExtracter from '../../geom/util/LinearComponentExtracter';\nimport ArrayListVisitor from '../../index/ArrayListVisitor';\nimport RayCrossingCounter from '../RayCrossingCounter';\nexport default function IndexedPointInAreaLocator() {\n\tthis.index = null;\n\tlet g = arguments[0];\n\tif (!hasInterface(g, Polygonal)) throw new IllegalArgumentException(\"Argument must be Polygonal\");\n\tthis.index = new IntervalIndexedGeometry(g);\n}\nextend(IndexedPointInAreaLocator.prototype, {\n\tlocate: function (p) {\n\t\tvar rcc = new RayCrossingCounter(p);\n\t\tvar visitor = new SegmentVisitor(rcc);\n\t\tthis.index.query(p.y, p.y, visitor);\n\t\treturn rcc.getLocation();\n\t},\n\tinterfaces_: function () {\n\t\treturn [PointOnGeometryLocator];\n\t},\n\tgetClass: function () {\n\t\treturn IndexedPointInAreaLocator;\n\t}\n});\nfunction SegmentVisitor() {\n\tthis.counter = null;\n\tlet counter = arguments[0];\n\tthis.counter = counter;\n}\nextend(SegmentVisitor.prototype, {\n\tvisitItem: function (item) {\n\t\tvar seg = item;\n\t\tthis.counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n\t},\n\tinterfaces_: function () {\n\t\treturn [ItemVisitor];\n\t},\n\tgetClass: function () {\n\t\treturn SegmentVisitor;\n\t}\n});\nfunction IntervalIndexedGeometry() {\n\tthis.index = new SortedPackedIntervalRTree();\n\tlet geom = arguments[0];\n\tthis.init(geom);\n}\nextend(IntervalIndexedGeometry.prototype, {\n\tinit: function (geom) {\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tfor (var i = lines.iterator(); i.hasNext(); ) {\n\t\t\tvar line = i.next();\n\t\t\tvar pts = line.getCoordinates();\n\t\t\tthis.addLine(pts);\n\t\t}\n\t},\n\taddLine: function (pts) {\n\t\tfor (var i = 1; i < pts.length; i++) {\n\t\t\tvar seg = new LineSegment(pts[i - 1], pts[i]);\n\t\t\tvar min = Math.min(seg.p0.y, seg.p1.y);\n\t\t\tvar max = Math.max(seg.p0.y, seg.p1.y);\n\t\t\tthis.index.insert(min, max, seg);\n\t\t}\n\t},\n\tquery: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet min = arguments[0], max = arguments[1];\n\t\t\tvar visitor = new ArrayListVisitor();\n\t\t\tthis.index.query(min, max, visitor);\n\t\t\treturn visitor.getItems();\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet min = arguments[0], max = arguments[1], visitor = arguments[2];\n\t\t\tthis.index.query(min, max, visitor);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IntervalIndexedGeometry;\n\t}\n});\nIndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;\nIndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;\n","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nexport default function EdgeIntersection() {\n\tthis.coord = null;\n\tthis.segmentIndex = null;\n\tthis.dist = null;\n\tlet coord = arguments[0], segmentIndex = arguments[1], dist = arguments[2];\n\tthis.coord = new Coordinate(coord);\n\tthis.segmentIndex = segmentIndex;\n\tthis.dist = dist;\n}\nextend(EdgeIntersection.prototype, {\n\tgetSegmentIndex: function () {\n\t\treturn this.segmentIndex;\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.coord;\n\t},\n\tprint: function (out) {\n\t\tout.print(this.coord);\n\t\tout.print(\" seg # = \" + this.segmentIndex);\n\t\tout.println(\" dist = \" + this.dist);\n\t},\n\tcompareTo: function (obj) {\n\t\tvar other = obj;\n\t\treturn this.compare(other.segmentIndex, other.dist);\n\t},\n\tisEndPoint: function (maxSegmentIndex) {\n\t\tif (this.segmentIndex === 0 && this.dist === 0.0) return true;\n\t\tif (this.segmentIndex === maxSegmentIndex) return true;\n\t\treturn false;\n\t},\n\ttoString: function () {\n\t\treturn this.coord + \" seg # = \" + this.segmentIndex + \" dist = \" + this.dist;\n\t},\n\tgetDistance: function () {\n\t\treturn this.dist;\n\t},\n\tcompare: function (segmentIndex, dist) {\n\t\tif (this.segmentIndex < segmentIndex) return -1;\n\t\tif (this.segmentIndex > segmentIndex) return 1;\n\t\tif (this.dist < dist) return -1;\n\t\tif (this.dist > dist) return 1;\n\t\treturn 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeIntersection;\n\t}\n});\n","import EdgeIntersection from './EdgeIntersection';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport Label from './Label';\nimport Edge from './Edge';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function EdgeIntersectionList() {\n\tthis.nodeMap = new TreeMap();\n\tthis.edge = null;\n\tlet edge = arguments[0];\n\tthis.edge = edge;\n}\nextend(EdgeIntersectionList.prototype, {\n\tprint: function (out) {\n\t\tout.println(\"Intersections:\");\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tei.print(out);\n\t\t}\n\t},\n\titerator: function () {\n\t\treturn this.nodeMap.values().iterator();\n\t},\n\taddSplitEdges: function (edgeList) {\n\t\tthis.addEndpoints();\n\t\tvar it = this.iterator();\n\t\tvar eiPrev = it.next();\n\t\twhile (it.hasNext()) {\n\t\t\tvar ei = it.next();\n\t\t\tvar newEdge = this.createSplitEdge(eiPrev, ei);\n\t\t\tedgeList.add(newEdge);\n\t\t\teiPrev = ei;\n\t\t}\n\t},\n\taddEndpoints: function () {\n\t\tvar maxSegIndex = this.edge.pts.length - 1;\n\t\tthis.add(this.edge.pts[0], 0, 0.0);\n\t\tthis.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n\t},\n\tcreateSplitEdge: function (ei0, ei1) {\n\t\tvar npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n\t\tvar lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n\t\tvar useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n\t\tif (!useIntPt1) {\n\t\t\tnpts--;\n\t\t}\n\t\tvar pts = new Array(npts).fill(null);\n\t\tvar ipt = 0;\n\t\tpts[ipt++] = new Coordinate(ei0.coord);\n\t\tfor (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n\t\t\tpts[ipt++] = this.edge.pts[i];\n\t\t}\n\t\tif (useIntPt1) pts[ipt] = ei1.coord;\n\t\treturn new Edge(pts, new Label(this.edge.label));\n\t},\n\tadd: function (intPt, segmentIndex, dist) {\n\t\tvar eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n\t\tvar ei = this.nodeMap.get(eiNew);\n\t\tif (ei !== null) {\n\t\t\treturn ei;\n\t\t}\n\t\tthis.nodeMap.put(eiNew, eiNew);\n\t\treturn eiNew;\n\t},\n\tisIntersection: function (pt) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ei = it.next();\n\t\t\tif (ei.coord.equals(pt)) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeIntersectionList;\n\t}\n});\n","import extend from '../../../../../extend';\nimport Integer from '../../../../../java/lang/Integer';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Quadrant from '../Quadrant';\nexport default function MonotoneChainIndexer() {}\nextend(MonotoneChainIndexer.prototype, {\n\tgetChainStartIndices: function (pts) {\n\t\tvar start = 0;\n\t\tvar startIndexList = new ArrayList();\n\t\tstartIndexList.add(new Integer(start));\n\t\tdo {\n\t\t\tvar last = this.findChainEnd(pts, start);\n\t\t\tstartIndexList.add(new Integer(last));\n\t\t\tstart = last;\n\t\t} while (start < pts.length - 1);\n\t\tvar startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n\t\treturn startIndex;\n\t},\n\tfindChainEnd: function (pts, start) {\n\t\tvar chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n\t\tvar last = start + 1;\n\t\twhile (last < pts.length) {\n\t\t\tvar quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n\t\t\tif (quad !== chainQuad) break;\n\t\t\tlast++;\n\t\t}\n\t\treturn last - 1;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChainIndexer;\n\t}\n});\nMonotoneChainIndexer.toIntArray = function (list) {\n\tvar array = new Array(list.size()).fill(null);\n\tfor (var i = 0; i < array.length; i++) {\n\t\tarray[i] = list.get(i).intValue();\n\t}\n\treturn array;\n};\n","import extend from '../../../../../extend';\nimport MonotoneChainIndexer from './MonotoneChainIndexer';\nimport Envelope from '../../geom/Envelope';\nexport default function MonotoneChainEdge() {\n\tthis.e = null;\n\tthis.pts = null;\n\tthis.startIndex = null;\n\tthis.env1 = new Envelope();\n\tthis.env2 = new Envelope();\n\tlet e = arguments[0];\n\tthis.e = e;\n\tthis.pts = e.getCoordinates();\n\tvar mcb = new MonotoneChainIndexer();\n\tthis.startIndex = mcb.getChainStartIndices(this.pts);\n}\nextend(MonotoneChainEdge.prototype, {\n\tgetCoordinates: function () {\n\t\treturn this.pts;\n\t},\n\tgetMaxX: function (chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 > x2 ? x1 : x2;\n\t},\n\tgetMinX: function (chainIndex) {\n\t\tvar x1 = this.pts[this.startIndex[chainIndex]].x;\n\t\tvar x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n\t\treturn x1 < x2 ? x1 : x2;\n\t},\n\tcomputeIntersectsForChain: function () {\n\t\tif (arguments.length === 4) {\n\t\t\tlet chainIndex0 = arguments[0], mce = arguments[1], chainIndex1 = arguments[2], si = arguments[3];\n\t\t\tthis.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n\t\t} else if (arguments.length === 6) {\n\t\t\tlet start0 = arguments[0], end0 = arguments[1], mce = arguments[2], start1 = arguments[3], end1 = arguments[4], ei = arguments[5];\n\t\t\tvar p00 = this.pts[start0];\n\t\t\tvar p01 = this.pts[end0];\n\t\t\tvar p10 = mce.pts[start1];\n\t\t\tvar p11 = mce.pts[end1];\n\t\t\tif (end0 - start0 === 1 && end1 - start1 === 1) {\n\t\t\t\tei.addIntersections(this.e, start0, mce.e, start1);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis.env1.init(p00, p01);\n\t\t\tthis.env2.init(p10, p11);\n\t\t\tif (!this.env1.intersects(this.env2)) return null;\n\t\t\tvar mid0 = Math.trunc((start0 + end0) / 2);\n\t\t\tvar mid1 = Math.trunc((start1 + end1) / 2);\n\t\t\tif (start0 < mid0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t\tif (mid0 < end0) {\n\t\t\t\tif (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);\n\t\t\t\tif (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);\n\t\t\t}\n\t\t}\n\t},\n\tgetStartIndexes: function () {\n\t\treturn this.startIndex;\n\t},\n\tcomputeIntersects: function (mce, si) {\n\t\tfor (var i = 0; i < this.startIndex.length - 1; i++) {\n\t\t\tfor (var j = 0; j < mce.startIndex.length - 1; j++) {\n\t\t\t\tthis.computeIntersectsForChain(i, mce, j, si);\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChainEdge;\n\t}\n});\n","import Location from '../geom/Location';\nimport Position from './Position';\nimport extend from '../../../../extend';\nexport default function Depth() {\n\tthis.depth = Array(2).fill().map(() => Array(3));\n\tfor (var i = 0; i < 2; i++) {\n\t\tfor (var j = 0; j < 3; j++) {\n\t\t\tthis.depth[i][j] = Depth.NULL_VALUE;\n\t\t}\n\t}\n}\nextend(Depth.prototype, {\n\tgetDepth: function (geomIndex, posIndex) {\n\t\treturn this.depth[geomIndex][posIndex];\n\t},\n\tsetDepth: function (geomIndex, posIndex, depthValue) {\n\t\tthis.depth[geomIndex][posIndex] = depthValue;\n\t},\n\tisNull: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\t\tif (this.depth[i][j] !== Depth.NULL_VALUE) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomIndex = arguments[0];\n\t\t\treturn this.depth[geomIndex][1] === Depth.NULL_VALUE;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1];\n\t\t\treturn this.depth[geomIndex][posIndex] === Depth.NULL_VALUE;\n\t\t}\n\t},\n\tnormalize: function () {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (!this.isNull(i)) {\n\t\t\t\tvar minDepth = this.depth[i][1];\n\t\t\t\tif (this.depth[i][2] < minDepth) minDepth = this.depth[i][2];\n\t\t\t\tif (minDepth < 0) minDepth = 0;\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar newValue = 0;\n\t\t\t\t\tif (this.depth[i][j] > minDepth) newValue = 1;\n\t\t\t\t\tthis.depth[i][j] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetDelta: function (geomIndex) {\n\t\treturn this.depth[geomIndex][Position.RIGHT] - this.depth[geomIndex][Position.LEFT];\n\t},\n\tgetLocation: function (geomIndex, posIndex) {\n\t\tif (this.depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;\n\t\treturn Location.INTERIOR;\n\t},\n\ttoString: function () {\n\t\treturn \"A: \" + this.depth[0][1] + \",\" + this.depth[0][2] + \" B: \" + this.depth[1][1] + \",\" + this.depth[1][2];\n\t},\n\tadd: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet lbl = arguments[0];\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tfor (var j = 1; j < 3; j++) {\n\t\t\t\t\tvar loc = lbl.getLocation(i, j);\n\t\t\t\t\tif (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n\t\t\t\t\t\tif (this.isNull(i, j)) {\n\t\t\t\t\t\t\tthis.depth[i][j] = Depth.depthAtLocation(loc);\n\t\t\t\t\t\t} else this.depth[i][j] += Depth.depthAtLocation(loc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];\n\t\t\tif (location === Location.INTERIOR) this.depth[geomIndex][posIndex]++;\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Depth;\n\t}\n});\nDepth.depthAtLocation = function (location) {\n\tif (location === Location.EXTERIOR) return 0;\n\tif (location === Location.INTERIOR) return 1;\n\treturn Depth.NULL_VALUE;\n};\nDepth.NULL_VALUE = -1;\n","import StringBuffer from '../../../../java/lang/StringBuffer';\nimport EdgeIntersectionList from './EdgeIntersectionList';\nimport MonotoneChainEdge from './index/MonotoneChainEdge';\nimport Position from './Position';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport Label from './Label';\nimport Envelope from '../geom/Envelope';\nimport inherits from '../../../../inherits';\nimport Depth from './Depth';\nimport GraphComponent from './GraphComponent';\nexport default function Edge() {\n\tGraphComponent.apply(this);\n\tthis.pts = null;\n\tthis.env = null;\n\tthis.eiList = new EdgeIntersectionList(this);\n\tthis.name = null;\n\tthis.mce = null;\n\tthis._isIsolated = true;\n\tthis.depth = new Depth();\n\tthis.depthDelta = 0;\n\tif (arguments.length === 1) {\n\t\tlet pts = arguments[0];\n\t\tEdge.call(this, pts, null);\n\t} else if (arguments.length === 2) {\n\t\tlet pts = arguments[0], label = arguments[1];\n\t\tthis.pts = pts;\n\t\tthis.label = label;\n\t}\n}\ninherits(Edge, GraphComponent);\nextend(Edge.prototype, {\n\tgetDepth: function () {\n\t\treturn this.depth;\n\t},\n\tgetCollapsedEdge: function () {\n\t\tvar newPts = new Array(2).fill(null);\n\t\tnewPts[0] = this.pts[0];\n\t\tnewPts[1] = this.pts[1];\n\t\tvar newe = new Edge(newPts, Label.toLineLabel(this.label));\n\t\treturn newe;\n\t},\n\tisIsolated: function () {\n\t\treturn this._isIsolated;\n\t},\n\tgetCoordinates: function () {\n\t\treturn this.pts;\n\t},\n\tsetIsolated: function (isIsolated) {\n\t\tthis._isIsolated = isIsolated;\n\t},\n\tsetName: function (name) {\n\t\tthis.name = name;\n\t},\n\tequals: function (o) {\n\t\tif (!(o instanceof Edge)) return false;\n\t\tvar e = o;\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tvar isEqualForward = true;\n\t\tvar isEqualReverse = true;\n\t\tvar iRev = this.pts.length;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\tisEqualForward = false;\n\t\t\t}\n\t\t\tif (!this.pts[i].equals2D(e.pts[-- iRev])) {\n\t\t\t\tisEqualReverse = false;\n\t\t\t}\n\t\t\tif (!isEqualForward && !isEqualReverse) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tgetCoordinate: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.pts.length > 0) return this.pts[0];\n\t\t\treturn null;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this.pts[i];\n\t\t}\n\t},\n\tprint: function (out) {\n\t\tout.print(\"edge \" + this.name + \": \");\n\t\tout.print(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) out.print(\",\");\n\t\t\tout.print(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tout.print(\")  \" + this.label + \" \" + this.depthDelta);\n\t},\n\tcomputeIM: function (im) {\n\t\tEdge.updateIM(this.label, im);\n\t},\n\tisCollapsed: function () {\n\t\tif (!this.label.isArea()) return false;\n\t\tif (this.pts.length !== 3) return false;\n\t\tif (this.pts[0].equals(this.pts[2])) return true;\n\t\treturn false;\n\t},\n\tisClosed: function () {\n\t\treturn this.pts[0].equals(this.pts[this.pts.length - 1]);\n\t},\n\tgetMaximumSegmentIndex: function () {\n\t\treturn this.pts.length - 1;\n\t},\n\tgetDepthDelta: function () {\n\t\treturn this.depthDelta;\n\t},\n\tgetNumPoints: function () {\n\t\treturn this.pts.length;\n\t},\n\tprintReverse: function (out) {\n\t\tout.print(\"edge \" + this.name + \": \");\n\t\tfor (var i = this.pts.length - 1; i >= 0; i--) {\n\t\t\tout.print(this.pts[i] + \" \");\n\t\t}\n\t\tout.println(\"\");\n\t},\n\tgetMonotoneChainEdge: function () {\n\t\tif (this.mce === null) this.mce = new MonotoneChainEdge(this);\n\t\treturn this.mce;\n\t},\n\tgetEnvelope: function () {\n\t\tif (this.env === null) {\n\t\t\tthis.env = new Envelope();\n\t\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\t\tthis.env.expandToInclude(this.pts[i]);\n\t\t\t}\n\t\t}\n\t\treturn this.env;\n\t},\n\taddIntersection: function (li, segmentIndex, geomIndex, intIndex) {\n\t\tvar intPt = new Coordinate(li.getIntersection(intIndex));\n\t\tvar normalizedSegmentIndex = segmentIndex;\n\t\tvar dist = li.getEdgeDistance(geomIndex, intIndex);\n\t\tvar nextSegIndex = normalizedSegmentIndex + 1;\n\t\tif (nextSegIndex < this.pts.length) {\n\t\t\tvar nextPt = this.pts[nextSegIndex];\n\t\t\tif (intPt.equals2D(nextPt)) {\n\t\t\t\tnormalizedSegmentIndex = nextSegIndex;\n\t\t\t\tdist = 0.0;\n\t\t\t}\n\t\t}\n\t\tvar ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);\n\t},\n\ttoString: function () {\n\t\tvar buf = new StringBuffer();\n\t\tbuf.append(\"edge \" + this.name + \": \");\n\t\tbuf.append(\"LINESTRING (\");\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (i > 0) buf.append(\",\");\n\t\t\tbuf.append(this.pts[i].x + \" \" + this.pts[i].y);\n\t\t}\n\t\tbuf.append(\")  \" + this.label + \" \" + this.depthDelta);\n\t\treturn buf.toString();\n\t},\n\tisPointwiseEqual: function (e) {\n\t\tif (this.pts.length !== e.pts.length) return false;\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (!this.pts[i].equals2D(e.pts[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tsetDepthDelta: function (depthDelta) {\n\t\tthis.depthDelta = depthDelta;\n\t},\n\tgetEdgeIntersectionList: function () {\n\t\treturn this.eiList;\n\t},\n\taddIntersections: function (li, segmentIndex, geomIndex) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tthis.addIntersection(li, segmentIndex, geomIndex, i);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Edge;\n\t}\n});\nEdge.updateIM = function () {\n\tif (arguments.length === 2) {\n\t\tlet label = arguments[0], im = arguments[1];\n\t\tim.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n\t\tif (label.isArea()) {\n\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n\t\t\tim.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n\t\t}\n\t} else return GraphComponent.prototype.updateIM.apply(this, arguments);\n};\n","import PointLocator from '../algorithm/PointLocator';\nimport Location from '../geom/Location';\nimport LineString from '../geom/LineString';\nimport HashMap from '../../../../java/util/HashMap';\nimport CGAlgorithms from '../algorithm/CGAlgorithms';\nimport hasInterface from '../../../../hasInterface';\nimport Position from './Position';\nimport Coordinate from '../geom/Coordinate';\nimport Point from '../geom/Point';\nimport Polygon from '../geom/Polygon';\nimport MultiPoint from '../geom/MultiPoint';\nimport SimpleMCSweepLineIntersector from './index/SimpleMCSweepLineIntersector';\nimport LinearRing from '../geom/LinearRing';\nimport BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport extend from '../../../../extend';\nimport SegmentIntersector from './index/SegmentIntersector';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport Label from './Label';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport Polygonal from '../geom/Polygonal';\nimport IndexedPointInAreaLocator from '../algorithm/locate/IndexedPointInAreaLocator';\nimport Assert from '../util/Assert';\nimport Edge from './Edge';\nimport inherits from '../../../../inherits';\nimport MultiLineString from '../geom/MultiLineString';\nimport PlanarGraph from './PlanarGraph';\nexport default function GeometryGraph() {\n\tPlanarGraph.apply(this);\n\tthis.parentGeom = null;\n\tthis.lineEdgeMap = new HashMap();\n\tthis.boundaryNodeRule = null;\n\tthis.useBoundaryDeterminationRule = true;\n\tthis.argIndex = null;\n\tthis.boundaryNodes = null;\n\tthis._hasTooFewPoints = false;\n\tthis.invalidPoint = null;\n\tthis.areaPtLocator = null;\n\tthis.ptLocator = new PointLocator();\n\tif (arguments.length === 2) {\n\t\tlet argIndex = arguments[0], parentGeom = arguments[1];\n\t\tGeometryGraph.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tlet argIndex = arguments[0], parentGeom = arguments[1], boundaryNodeRule = arguments[2];\n\t\tthis.argIndex = argIndex;\n\t\tthis.parentGeom = parentGeom;\n\t\tthis.boundaryNodeRule = boundaryNodeRule;\n\t\tif (parentGeom !== null) {\n\t\t\tthis.add(parentGeom);\n\t\t}\n\t}\n}\ninherits(GeometryGraph, PlanarGraph);\nextend(GeometryGraph.prototype, {\n\tinsertBoundaryPoint: function (argIndex, coord) {\n\t\tvar n = this.nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tvar boundaryCount = 1;\n\t\tvar loc = Location.NONE;\n\t\tloc = lbl.getLocation(argIndex, Position.ON);\n\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\tvar newLoc = GeometryGraph.determineBoundary(this.boundaryNodeRule, boundaryCount);\n\t\tlbl.setLocation(argIndex, newLoc);\n\t},\n\tcomputeSelfNodes: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet li = arguments[0], computeRingSelfNodes = arguments[1];\n\t\t\treturn this.computeSelfNodes(li, computeRingSelfNodes, false);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet li = arguments[0], computeRingSelfNodes = arguments[1], isDoneIfProperInt = arguments[2];\n\t\t\tvar si = new SegmentIntersector(li, true, false);\n\t\t\tsi.setIsDoneIfProperInt(isDoneIfProperInt);\n\t\t\tvar esi = this.createEdgeSetIntersector();\n\t\t\tvar isRings = this.parentGeom instanceof LinearRing || this.parentGeom instanceof Polygon || this.parentGeom instanceof MultiPolygon;\n\t\t\tvar computeAllSegments = computeRingSelfNodes || !isRings;\n\t\t\tesi.computeIntersections(this.edges, si, computeAllSegments);\n\t\t\tthis.addSelfIntersectionNodes(this.argIndex);\n\t\t\treturn si;\n\t\t}\n\t},\n\tcomputeSplitEdges: function (edgelist) {\n\t\tfor (var i = this.edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\te.eiList.addSplitEdges(edgelist);\n\t\t}\n\t},\n\tcomputeEdgeIntersections: function (g, li, includeProper) {\n\t\tvar si = new SegmentIntersector(li, includeProper, true);\n\t\tsi.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n\t\tvar esi = this.createEdgeSetIntersector();\n\t\tesi.computeIntersections(this.edges, g.edges, si);\n\t\treturn si;\n\t},\n\tgetGeometry: function () {\n\t\treturn this.parentGeom;\n\t},\n\tgetBoundaryNodeRule: function () {\n\t\treturn this.boundaryNodeRule;\n\t},\n\thasTooFewPoints: function () {\n\t\treturn this._hasTooFewPoints;\n\t},\n\taddPoint: function () {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tlet p = arguments[0];\n\t\t\tvar coord = p.getCoordinate();\n\t\t\tthis.insertPoint(this.argIndex, coord, Location.INTERIOR);\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet pt = arguments[0];\n\t\t\tthis.insertPoint(this.argIndex, pt, Location.INTERIOR);\n\t\t}\n\t},\n\taddPolygon: function (p) {\n\t\tthis.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tthis.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n\t\t}\n\t},\n\taddEdge: function (e) {\n\t\tthis.insertEdge(e);\n\t\tvar coord = e.getCoordinates();\n\t\tthis.insertPoint(this.argIndex, coord[0], Location.BOUNDARY);\n\t\tthis.insertPoint(this.argIndex, coord[coord.length - 1], Location.BOUNDARY);\n\t},\n\taddLineString: function (line) {\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tif (coord.length < 2) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis.invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this.argIndex, Location.INTERIOR));\n\t\tthis.lineEdgeMap.put(line, e);\n\t\tthis.insertEdge(e);\n\t\tAssert.isTrue(coord.length >= 2, \"found LineString with single point\");\n\t\tthis.insertBoundaryPoint(this.argIndex, coord[0]);\n\t\tthis.insertBoundaryPoint(this.argIndex, coord[coord.length - 1]);\n\t},\n\tgetInvalidPoint: function () {\n\t\treturn this.invalidPoint;\n\t},\n\tgetBoundaryPoints: function () {\n\t\tvar coll = this.getBoundaryNodes();\n\t\tvar pts = new Array(coll.size()).fill(null);\n\t\tvar i = 0;\n\t\tfor (var it = coll.iterator(); it.hasNext(); ) {\n\t\t\tvar node = it.next();\n\t\t\tpts[i++] = node.getCoordinate().copy();\n\t\t}\n\t\treturn pts;\n\t},\n\tgetBoundaryNodes: function () {\n\t\tif (this.boundaryNodes === null) this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex);\n\t\treturn this.boundaryNodes;\n\t},\n\taddSelfIntersectionNode: function (argIndex, coord, loc) {\n\t\tif (this.isBoundaryNode(argIndex, coord)) return null;\n\t\tif (loc === Location.BOUNDARY && this.useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord); else this.insertPoint(argIndex, coord, loc);\n\t},\n\taddPolygonRing: function (lr, cwLeft, cwRight) {\n\t\tif (lr.isEmpty()) return null;\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n\t\tif (coord.length < 4) {\n\t\t\tthis._hasTooFewPoints = true;\n\t\t\tthis.invalidPoint = coord[0];\n\t\t\treturn null;\n\t\t}\n\t\tvar left = cwLeft;\n\t\tvar right = cwRight;\n\t\tif (CGAlgorithms.isCCW(coord)) {\n\t\t\tleft = cwRight;\n\t\t\tright = cwLeft;\n\t\t}\n\t\tvar e = new Edge(coord, new Label(this.argIndex, Location.BOUNDARY, left, right));\n\t\tthis.lineEdgeMap.put(lr, e);\n\t\tthis.insertEdge(e);\n\t\tthis.insertPoint(this.argIndex, coord[0], Location.BOUNDARY);\n\t},\n\tinsertPoint: function (argIndex, coord, onLocation) {\n\t\tvar n = this.nodes.addNode(coord);\n\t\tvar lbl = n.getLabel();\n\t\tif (lbl === null) {\n\t\t\tn.label = new Label(argIndex, onLocation);\n\t\t} else lbl.setLocation(argIndex, onLocation);\n\t},\n\tcreateEdgeSetIntersector: function () {\n\t\treturn new SimpleMCSweepLineIntersector();\n\t},\n\taddSelfIntersectionNodes: function (argIndex) {\n\t\tfor (var i = this.edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.eiList.iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tthis.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n\t\t\t}\n\t\t}\n\t},\n\tadd: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet g = arguments[0];\n\t\t\tif (g.isEmpty()) return null;\n\t\t\tif (g instanceof MultiPolygon) this.useBoundaryDeterminationRule = false;\n\t\t\tif (g instanceof Polygon) this.addPolygon(g); else if (g instanceof LineString) this.addLineString(g); else if (g instanceof Point) this.addPoint(g); else if (g instanceof MultiPoint) this.addCollection(g); else if (g instanceof MultiLineString) this.addCollection(g); else if (g instanceof MultiPolygon) this.addCollection(g); else if (g instanceof GeometryCollection) this.addCollection(g); else throw new UnsupportedOperationException(g.getClass().getName());\n\t\t} else return PlanarGraph.prototype.add.apply(this, arguments);\n\t},\n\taddCollection: function (gc) {\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = gc.getGeometryN(i);\n\t\t\tthis.add(g);\n\t\t}\n\t},\n\tlocate: function (pt) {\n\t\tif (hasInterface(this.parentGeom, Polygonal) && this.parentGeom.getNumGeometries() > 50) {\n\t\t\tif (this.areaPtLocator === null) {\n\t\t\t\tthis.areaPtLocator = new IndexedPointInAreaLocator(this.parentGeom);\n\t\t\t}\n\t\t\treturn this.areaPtLocator.locate(pt);\n\t\t}\n\t\treturn this.ptLocator.locate(pt, this.parentGeom);\n\t},\n\tfindEdge: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet line = arguments[0];\n\t\t\treturn this.lineEdgeMap.get(line);\n\t\t} else return PlanarGraph.prototype.findEdge.apply(this, arguments);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryGraph;\n\t}\n});\nGeometryGraph.determineBoundary = function (boundaryNodeRule, boundaryCount) {\n\treturn boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n};\n","import BoundaryNodeRule from '../algorithm/BoundaryNodeRule';\nimport extend from '../../../../extend';\nimport GeometryGraph from '../geomgraph/GeometryGraph';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nexport default function GeometryGraphOperation() {\n\tthis.li = new RobustLineIntersector();\n\tthis.resultPrecisionModel = null;\n\tthis.arg = null;\n\tif (arguments.length === 1) {\n\t\tlet g0 = arguments[0];\n\t\tthis.setComputationPrecision(g0.getPrecisionModel());\n\t\tthis.arg = new Array(1).fill(null);\n\t\tthis.arg[0] = new GeometryGraph(0, g0);\n\t\t;\n\t} else if (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tGeometryGraphOperation.call(this, g0, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];\n\t\tif (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel()); else this.setComputationPrecision(g1.getPrecisionModel());\n\t\tthis.arg = new Array(2).fill(null);\n\t\tthis.arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);\n\t\tthis.arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n\t}\n}\nextend(GeometryGraphOperation.prototype, {\n\tgetArgGeometry: function (i) {\n\t\treturn this.arg[i].getGeometry();\n\t},\n\tsetComputationPrecision: function (pm) {\n\t\tthis.resultPrecisionModel = pm;\n\t\tthis.li.setPrecisionModel(this.resultPrecisionModel);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryGraphOperation;\n\t}\n});\n","import extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nexport default function OrientedCoordinateArray() {\n\tthis.pts = null;\n\tthis._orientation = null;\n\tlet pts = arguments[0];\n\tthis.pts = pts;\n\tthis._orientation = OrientedCoordinateArray.orientation(pts);\n}\nextend(OrientedCoordinateArray.prototype, {\n\tcompareTo: function (o1) {\n\t\tvar oca = o1;\n\t\tvar comp = OrientedCoordinateArray.compareOriented(this.pts, this._orientation, oca.pts, oca._orientation);\n\t\treturn comp;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn OrientedCoordinateArray;\n\t}\n});\nOrientedCoordinateArray.orientation = function (pts) {\n\treturn CoordinateArrays.increasingDirection(pts) === 1;\n};\nOrientedCoordinateArray.compareOriented = function (pts1, orientation1, pts2, orientation2) {\n\tvar dir1 = orientation1 ? 1 : -1;\n\tvar dir2 = orientation2 ? 1 : -1;\n\tvar limit1 = orientation1 ? pts1.length : -1;\n\tvar limit2 = orientation2 ? pts2.length : -1;\n\tvar i1 = orientation1 ? 0 : pts1.length - 1;\n\tvar i2 = orientation2 ? 0 : pts2.length - 1;\n\tvar comp = 0;\n\twhile (true) {\n\t\tvar compPt = pts1[i1].compareTo(pts2[i2]);\n\t\tif (compPt !== 0) return compPt;\n\t\ti1 += dir1;\n\t\ti2 += dir2;\n\t\tvar done1 = i1 === limit1;\n\t\tvar done2 = i2 === limit2;\n\t\tif (done1 && !done2) return -1;\n\t\tif (!done1 && done2) return 1;\n\t\tif (done1 && done2) return 0;\n\t}\n};\n","import OrientedCoordinateArray from '../noding/OrientedCoordinateArray';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function EdgeList() {\n\tthis.edges = new ArrayList();\n\tthis.ocaMap = new TreeMap();\n}\nextend(EdgeList.prototype, {\n\tprint: function (out) {\n\t\tout.print(\"MULTILINESTRING ( \");\n\t\tfor (var j = 0; j < this.edges.size(); j++) {\n\t\t\tvar e = this.edges.get(j);\n\t\t\tif (j > 0) out.print(\",\");\n\t\t\tout.print(\"(\");\n\t\t\tvar pts = e.getCoordinates();\n\t\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\t\tif (i > 0) out.print(\",\");\n\t\t\t\tout.print(pts[i].x + \" \" + pts[i].y);\n\t\t\t}\n\t\t\tout.println(\")\");\n\t\t}\n\t\tout.print(\")  \");\n\t},\n\taddAll: function (edgeColl) {\n\t\tfor (var i = edgeColl.iterator(); i.hasNext(); ) {\n\t\t\tthis.add(i.next());\n\t\t}\n\t},\n\tfindEdgeIndex: function (e) {\n\t\tfor (var i = 0; i < this.edges.size(); i++) {\n\t\t\tif (this.edges.get(i).equals(e)) return i;\n\t\t}\n\t\treturn -1;\n\t},\n\titerator: function () {\n\t\treturn this.edges.iterator();\n\t},\n\tgetEdges: function () {\n\t\treturn this.edges;\n\t},\n\tget: function (i) {\n\t\treturn this.edges.get(i);\n\t},\n\tfindEqualEdge: function (e) {\n\t\tvar oca = new OrientedCoordinateArray(e.getCoordinates());\n\t\tvar matchEdge = this.ocaMap.get(oca);\n\t\treturn matchEdge;\n\t},\n\tadd: function (e) {\n\t\tthis.edges.add(e);\n\t\tvar oca = new OrientedCoordinateArray(e.getCoordinates());\n\t\tthis.ocaMap.put(oca, e);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeList;\n\t}\n});\n","import PointLocator from '../../algorithm/PointLocator';\nimport Location from '../../geom/Location';\nimport EdgeNodingValidator from '../../geomgraph/EdgeNodingValidator';\nimport GeometryCollectionMapper from '../../geom/util/GeometryCollectionMapper';\nimport PolygonBuilder from './PolygonBuilder';\nimport Position from '../../geomgraph/Position';\nimport LineBuilder from './LineBuilder';\nimport PointBuilder from './PointBuilder';\nimport SnapIfNeededOverlayOp from './snap/SnapIfNeededOverlayOp';\nimport extend from '../../../../../extend';\nimport Label from '../../geomgraph/Label';\nimport OverlayNodeFactory from './OverlayNodeFactory';\nimport GeometryGraphOperation from '../GeometryGraphOperation';\nimport EdgeList from '../../geomgraph/EdgeList';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport inherits from '../../../../../inherits';\nimport PlanarGraph from '../../geomgraph/PlanarGraph';\nexport default function OverlayOp() {\n\tthis.ptLocator = new PointLocator();\n\tthis.geomFact = null;\n\tthis.resultGeom = null;\n\tthis.graph = null;\n\tthis.edgeList = new EdgeList();\n\tthis.resultPolyList = new ArrayList();\n\tthis.resultLineList = new ArrayList();\n\tthis.resultPointList = new ArrayList();\n\tlet g0 = arguments[0], g1 = arguments[1];\n\tGeometryGraphOperation.call(this, g0, g1);\n\tthis.graph = new PlanarGraph(new OverlayNodeFactory());\n\tthis.geomFact = g0.getFactory();\n}\ninherits(OverlayOp, GeometryGraphOperation);\nextend(OverlayOp.prototype, {\n\tinsertUniqueEdge: function (e) {\n\t\tvar existingEdge = this.edgeList.findEqualEdge(e);\n\t\tif (existingEdge !== null) {\n\t\t\tvar existingLabel = existingEdge.getLabel();\n\t\t\tvar labelToMerge = e.getLabel();\n\t\t\tif (!existingEdge.isPointwiseEqual(e)) {\n\t\t\t\tlabelToMerge = new Label(e.getLabel());\n\t\t\t\tlabelToMerge.flip();\n\t\t\t}\n\t\t\tvar depth = existingEdge.getDepth();\n\t\t\tif (depth.isNull()) {\n\t\t\t\tdepth.add(existingLabel);\n\t\t\t}\n\t\t\tdepth.add(labelToMerge);\n\t\t\texistingLabel.merge(labelToMerge);\n\t\t} else {\n\t\t\tthis.edgeList.add(e);\n\t\t}\n\t},\n\tgetGraph: function () {\n\t\treturn this.graph;\n\t},\n\tcancelDuplicateResultEdges: function () {\n\t\tfor (var it = this.graph.getEdgeEnds().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tvar sym = de.getSym();\n\t\t\tif (de.isInResult() && sym.isInResult()) {\n\t\t\t\tde.setInResult(false);\n\t\t\t\tsym.setInResult(false);\n\t\t\t}\n\t\t}\n\t},\n\tisCoveredByLA: function (coord) {\n\t\tif (this.isCovered(coord, this.resultLineList)) return true;\n\t\tif (this.isCovered(coord, this.resultPolyList)) return true;\n\t\treturn false;\n\t},\n\tcomputeGeometry: function (resultPointList, resultLineList, resultPolyList, opcode) {\n\t\tvar geomList = new ArrayList();\n\t\tgeomList.addAll(resultPointList);\n\t\tgeomList.addAll(resultLineList);\n\t\tgeomList.addAll(resultPolyList);\n\t\tif (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this.arg[0].getGeometry(), this.arg[1].getGeometry(), this.geomFact);\n\t\treturn this.geomFact.buildGeometry(geomList);\n\t},\n\tmergeSymLabels: function () {\n\t\tfor (var nodeit = this.graph.getNodes().iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().mergeSymLabels();\n\t\t}\n\t},\n\tisCovered: function (coord, geomList) {\n\t\tfor (var it = geomList.iterator(); it.hasNext(); ) {\n\t\t\tvar geom = it.next();\n\t\t\tvar loc = this.ptLocator.locate(coord, geom);\n\t\t\tif (loc !== Location.EXTERIOR) return true;\n\t\t}\n\t\treturn false;\n\t},\n\treplaceCollapsedEdges: function () {\n\t\tvar newEdges = new ArrayList();\n\t\tfor (var it = this.edgeList.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.isCollapsed()) {\n\t\t\t\tit.remove();\n\t\t\t\tnewEdges.add(e.getCollapsedEdge());\n\t\t\t}\n\t\t}\n\t\tthis.edgeList.addAll(newEdges);\n\t},\n\tupdateNodeLabelling: function () {\n\t\tfor (var nodeit = this.graph.getNodes().iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tvar lbl = node.getEdges().getLabel();\n\t\t\tnode.getLabel().merge(lbl);\n\t\t}\n\t},\n\tgetResultGeometry: function (overlayOpCode) {\n\t\tthis.computeOverlay(overlayOpCode);\n\t\treturn this.resultGeom;\n\t},\n\tinsertUniqueEdges: function (edges) {\n\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tthis.insertUniqueEdge(e);\n\t\t}\n\t},\n\tcomputeOverlay: function (opCode) {\n\t\tthis.copyPoints(0);\n\t\tthis.copyPoints(1);\n\t\tthis.arg[0].computeSelfNodes(this.li, false);\n\t\tthis.arg[1].computeSelfNodes(this.li, false);\n\t\tthis.arg[0].computeEdgeIntersections(this.arg[1], this.li, true);\n\t\tvar baseSplitEdges = new ArrayList();\n\t\tthis.arg[0].computeSplitEdges(baseSplitEdges);\n\t\tthis.arg[1].computeSplitEdges(baseSplitEdges);\n\t\tvar splitEdges = baseSplitEdges;\n\t\tthis.insertUniqueEdges(baseSplitEdges);\n\t\tthis.computeLabelsFromDepths();\n\t\tthis.replaceCollapsedEdges();\n\t\tEdgeNodingValidator.checkValid(this.edgeList.getEdges());\n\t\tthis.graph.addEdges(this.edgeList.getEdges());\n\t\tthis.computeLabelling();\n\t\tthis.labelIncompleteNodes();\n\t\tthis.findResultAreaEdges(opCode);\n\t\tthis.cancelDuplicateResultEdges();\n\t\tvar polyBuilder = new PolygonBuilder(this.geomFact);\n\t\tpolyBuilder.add(this.graph);\n\t\tthis.resultPolyList = polyBuilder.getPolygons();\n\t\tvar lineBuilder = new LineBuilder(this, this.geomFact, this.ptLocator);\n\t\tthis.resultLineList = lineBuilder.build(opCode);\n\t\tvar pointBuilder = new PointBuilder(this, this.geomFact, this.ptLocator);\n\t\tthis.resultPointList = pointBuilder.build(opCode);\n\t\tthis.resultGeom = this.computeGeometry(this.resultPointList, this.resultLineList, this.resultPolyList, opCode);\n\t},\n\tlabelIncompleteNode: function (n, targetIndex) {\n\t\tvar loc = this.ptLocator.locate(n.getCoordinate(), this.arg[targetIndex].getGeometry());\n\t\tn.getLabel().setLocation(targetIndex, loc);\n\t},\n\tcopyPoints: function (argIndex) {\n\t\tfor (var i = this.arg[argIndex].getNodeIterator(); i.hasNext(); ) {\n\t\t\tvar graphNode = i.next();\n\t\t\tvar newNode = this.graph.addNode(graphNode.getCoordinate());\n\t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n\t\t}\n\t},\n\tfindResultAreaEdges: function (opCode) {\n\t\tfor (var it = this.graph.getEdgeEnds().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tif (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {\n\t\t\t\tde.setInResult(true);\n\t\t\t}\n\t\t}\n\t},\n\tcomputeLabelsFromDepths: function () {\n\t\tfor (var it = this.edgeList.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar lbl = e.getLabel();\n\t\t\tvar depth = e.getDepth();\n\t\t\tif (!depth.isNull()) {\n\t\t\t\tdepth.normalize();\n\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\tif (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {\n\t\t\t\t\t\tif (depth.getDelta(i) === 0) {\n\t\t\t\t\t\t\tlbl.toLine(i);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tAssert.isTrue(!depth.isNull(i, Position.LEFT), \"depth of LEFT side has not been initialized\");\n\t\t\t\t\t\t\tlbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n\t\t\t\t\t\t\tAssert.isTrue(!depth.isNull(i, Position.RIGHT), \"depth of RIGHT side has not been initialized\");\n\t\t\t\t\t\t\tlbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputeLabelling: function () {\n\t\tfor (var nodeit = this.graph.getNodes().iterator(); nodeit.hasNext(); ) {\n\t\t\tvar node = nodeit.next();\n\t\t\tnode.getEdges().computeLabelling(this.arg);\n\t\t}\n\t\tthis.mergeSymLabels();\n\t\tthis.updateNodeLabelling();\n\t},\n\tlabelIncompleteNodes: function () {\n\t\tvar nodeCount = 0;\n\t\tfor (var ni = this.graph.getNodes().iterator(); ni.hasNext(); ) {\n\t\t\tvar n = ni.next();\n\t\t\tvar label = n.getLabel();\n\t\t\tif (n.isIsolated()) {\n\t\t\t\tnodeCount++;\n\t\t\t\tif (label.isNull(0)) this.labelIncompleteNode(n, 0); else this.labelIncompleteNode(n, 1);\n\t\t\t}\n\t\t\tn.getEdges().updateLabelling(label);\n\t\t}\n\t},\n\tisCoveredByA: function (coord) {\n\t\tif (this.isCovered(coord, this.resultPolyList)) return true;\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OverlayOp;\n\t}\n});\nOverlayOp.overlayOp = function (geom0, geom1, opCode) {\n\tvar gov = new OverlayOp(geom0, geom1);\n\tvar geomOv = gov.getResultGeometry(opCode);\n\treturn geomOv;\n};\nOverlayOp.intersection = function (g, other) {\n\tif (g.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory());\n\tif (g.isGeometryCollection()) {\n\t\tvar g2 = other;\n\t\treturn GeometryCollectionMapper.map(g, {\n\t\t\tinterfaces_: function () {\n\t\t\t\treturn [MapOp];\n\t\t\t},\n\t\t\tmap: function (g) {\n\t\t\t\treturn g.intersection(g2);\n\t\t\t}\n\t\t});\n\t}\n\tg.checkNotGeometryCollection(g);\n\tg.checkNotGeometryCollection(other);\n\treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION);\n};\nOverlayOp.symDifference = function (g, other) {\n\tif (g.isEmpty() || other.isEmpty()) {\n\t\tif (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory());\n\t\tif (g.isEmpty()) return other.copy();\n\t\tif (other.isEmpty()) return g.copy();\n\t}\n\tg.checkNotGeometryCollection(g);\n\tg.checkNotGeometryCollection(other);\n\treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE);\n};\nOverlayOp.resultDimension = function (opCode, g0, g1) {\n\tvar dim0 = g0.getDimension();\n\tvar dim1 = g1.getDimension();\n\tvar resultDimension = -1;\n\tswitch (opCode) {\n\t\tcase OverlayOp.INTERSECTION:\n\t\t\tresultDimension = Math.min(dim0, dim1);\n\t\t\tbreak;\n\t\tcase OverlayOp.UNION:\n\t\t\tresultDimension = Math.max(dim0, dim1);\n\t\t\tbreak;\n\t\tcase OverlayOp.DIFFERENCE:\n\t\t\tresultDimension = dim0;\n\t\t\tbreak;\n\t\tcase OverlayOp.SYMDIFFERENCE:\n\t\t\tresultDimension = Math.max(dim0, dim1);\n\t\t\tbreak;\n\t}\n\treturn resultDimension;\n};\nOverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {\n\tvar result = null;\n\tswitch (OverlayOp.resultDimension(overlayOpCode, a, b)) {\n\t\tcase -1:\n\t\t\tresult = geomFact.createGeometryCollection(new Array(0).fill(null));\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tresult = geomFact.createPoint();\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tresult = geomFact.createLineString();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tresult = geomFact.createPolygon();\n\t\t\tbreak;\n\t}\n\treturn result;\n};\nOverlayOp.difference = function (g, other) {\n\tif (g.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory());\n\tif (other.isEmpty()) return g.copy();\n\tg.checkNotGeometryCollection(g);\n\tg.checkNotGeometryCollection(other);\n\treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE);\n};\nOverlayOp.isResultOfOp = function () {\n\tif (arguments.length === 2) {\n\t\tlet label = arguments[0], opCode = arguments[1];\n\t\tvar loc0 = label.getLocation(0);\n\t\tvar loc1 = label.getLocation(1);\n\t\treturn OverlayOp.isResultOfOp(loc0, loc1, opCode);\n\t} else if (arguments.length === 3) {\n\t\tlet loc0 = arguments[0], loc1 = arguments[1], overlayOpCode = arguments[2];\n\t\tif (loc0 === Location.BOUNDARY) loc0 = Location.INTERIOR;\n\t\tif (loc1 === Location.BOUNDARY) loc1 = Location.INTERIOR;\n\t\tswitch (overlayOpCode) {\n\t\t\tcase OverlayOp.INTERSECTION:\n\t\t\t\treturn loc0 === Location.INTERIOR && loc1 === Location.INTERIOR;\n\t\t\tcase OverlayOp.UNION:\n\t\t\t\treturn loc0 === Location.INTERIOR || loc1 === Location.INTERIOR;\n\t\t\tcase OverlayOp.DIFFERENCE:\n\t\t\t\treturn loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR;\n\t\t\tcase OverlayOp.SYMDIFFERENCE:\n\t\t\t\treturn loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR || loc0 !== Location.INTERIOR && loc1 === Location.INTERIOR;\n\t\t}\n\t\treturn false;\n\t}\n};\nOverlayOp.INTERSECTION = 1;\nOverlayOp.UNION = 2;\nOverlayOp.DIFFERENCE = 3;\nOverlayOp.SYMDIFFERENCE = 4;\n","import GeometrySnapper from './GeometrySnapper';\nimport extend from '../../../../../../extend';\nimport System from '../../../../../../java/lang/System';\nimport CommonBitsRemover from '../../../precision/CommonBitsRemover';\nimport OverlayOp from '../OverlayOp';\nexport default function SnapOverlayOp() {\n\tthis.geom = new Array(2).fill(null);\n\tthis.snapTolerance = null;\n\tthis.cbr = null;\n\tlet g1 = arguments[0], g2 = arguments[1];\n\tthis.geom[0] = g1;\n\tthis.geom[1] = g2;\n\tthis.computeSnapTolerance();\n}\nextend(SnapOverlayOp.prototype, {\n\tselfSnap: function (geom) {\n\t\tvar snapper0 = new GeometrySnapper(geom);\n\t\tvar snapGeom = snapper0.snapTo(geom, this.snapTolerance);\n\t\treturn snapGeom;\n\t},\n\tremoveCommonBits: function (geom) {\n\t\tthis.cbr = new CommonBitsRemover();\n\t\tthis.cbr.add(geom[0]);\n\t\tthis.cbr.add(geom[1]);\n\t\tvar remGeom = new Array(2).fill(null);\n\t\tremGeom[0] = this.cbr.removeCommonBits(geom[0].copy());\n\t\tremGeom[1] = this.cbr.removeCommonBits(geom[1].copy());\n\t\treturn remGeom;\n\t},\n\tprepareResult: function (geom) {\n\t\tthis.cbr.addCommonBits(geom);\n\t\treturn geom;\n\t},\n\tgetResultGeometry: function (opCode) {\n\t\tvar prepGeom = this.snap(this.geom);\n\t\tvar result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n\t\treturn this.prepareResult(result);\n\t},\n\tcheckValid: function (g) {\n\t\tif (!g.isValid()) {\n\t\t\tSystem.out.println(\"Snapped geometry is invalid\");\n\t\t}\n\t},\n\tcomputeSnapTolerance: function () {\n\t\tthis.snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this.geom[0], this.geom[1]);\n\t},\n\tsnap: function (geom) {\n\t\tvar remGeom = this.removeCommonBits(geom);\n\t\tvar snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this.snapTolerance);\n\t\treturn snapGeom;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SnapOverlayOp;\n\t}\n});\nSnapOverlayOp.overlayOp = function (g0, g1, opCode) {\n\tvar op = new SnapOverlayOp(g0, g1);\n\treturn op.getResultGeometry(opCode);\n};\nSnapOverlayOp.union = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n};\nSnapOverlayOp.intersection = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n};\nSnapOverlayOp.symDifference = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n};\nSnapOverlayOp.difference = function (g0, g1) {\n\treturn SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n};\n","import SnapOverlayOp from './SnapOverlayOp';\nimport extend from '../../../../../../extend';\nimport RuntimeException from '../../../../../../java/lang/RuntimeException';\nimport OverlayOp from '../OverlayOp';\nexport default function SnapIfNeededOverlayOp() {\n\tthis.geom = new Array(2).fill(null);\n\tlet g1 = arguments[0], g2 = arguments[1];\n\tthis.geom[0] = g1;\n\tthis.geom[1] = g2;\n}\nextend(SnapIfNeededOverlayOp.prototype, {\n\tgetResultGeometry: function (opCode) {\n\t\tvar result = null;\n\t\tvar isSuccess = false;\n\t\tvar savedException = null;\n\t\ttry {\n\t\t\tresult = OverlayOp.overlayOp(this.geom[0], this.geom[1], opCode);\n\t\t\tvar isValid = true;\n\t\t\tif (isValid) isSuccess = true;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof RuntimeException) {\n\t\t\t\tsavedException = ex;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t\tif (!isSuccess) {\n\t\t\ttry {\n\t\t\t\tresult = SnapOverlayOp.overlayOp(this.geom[0], this.geom[1], opCode);\n\t\t\t} catch (ex) {\n\t\t\t\tif (ex instanceof RuntimeException) {\n\t\t\t\t\tthrow savedException;\n\t\t\t\t} else throw ex;\n\t\t\t} finally {}\n\t\t}\n\t\treturn result;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SnapIfNeededOverlayOp;\n\t}\n});\nSnapIfNeededOverlayOp.overlayOp = function (g0, g1, opCode) {\n\tvar op = new SnapIfNeededOverlayOp(g0, g1);\n\treturn op.getResultGeometry(opCode);\n};\nSnapIfNeededOverlayOp.union = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n};\nSnapIfNeededOverlayOp.intersection = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n};\nSnapIfNeededOverlayOp.symDifference = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n};\nSnapIfNeededOverlayOp.difference = function (g0, g1) {\n\treturn SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n};\n","import Geometry from '../geom/Geometry';\nimport Coordinate from '../geom/Coordinate';\nimport Polygon from '../geom/Polygon';\nimport SnapIfNeededOverlayOp from '../operation/overlay/snap/SnapIfNeededOverlayOp';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport OverlayOp from '../operation/overlay/OverlayOp';\nexport default function InteriorPointArea() {\n\tthis.factory = null;\n\tthis.interiorPoint = null;\n\tthis.maxWidth = 0.0;\n\tlet g = arguments[0];\n\tthis.factory = g.getFactory();\n\tthis.add(g);\n}\nextend(InteriorPointArea.prototype, {\n\taddPolygon: function (geometry) {\n\t\tif (geometry.isEmpty()) return null;\n\t\tvar intPt = null;\n\t\tvar width = 0;\n\t\tvar bisector = this.horizontalBisector(geometry);\n\t\tif (bisector.getLength() === 0.0) {\n\t\t\twidth = 0;\n\t\t\tintPt = bisector.getCoordinate();\n\t\t} else {\n\t\t\tvar intersections = SnapIfNeededOverlayOp.overlayOp(bisector, geometry, OverlayOp.INTERSECTION);\n\t\t\tvar widestIntersection = this.widestGeometry(intersections);\n\t\t\twidth = widestIntersection.getEnvelopeInternal().getWidth();\n\t\t\tintPt = InteriorPointArea.centre(widestIntersection.getEnvelopeInternal());\n\t\t}\n\t\tif (this.interiorPoint === null || width > this.maxWidth) {\n\t\t\tthis.interiorPoint = intPt;\n\t\t\tthis.maxWidth = width;\n\t\t}\n\t},\n\tgetInteriorPoint: function () {\n\t\treturn this.interiorPoint;\n\t},\n\twidestGeometry: function () {\n\t\tif (arguments[0] instanceof GeometryCollection) {\n\t\t\tlet gc = arguments[0];\n\t\t\tif (gc.isEmpty()) {\n\t\t\t\treturn gc;\n\t\t\t}\n\t\t\tvar widestGeometry = gc.getGeometryN(0);\n\t\t\tfor (var i = 1; i < gc.getNumGeometries(); i++) {\n\t\t\t\tif (gc.getGeometryN(i).getEnvelopeInternal().getWidth() > widestGeometry.getEnvelopeInternal().getWidth()) {\n\t\t\t\t\twidestGeometry = gc.getGeometryN(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn widestGeometry;\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tlet geometry = arguments[0];\n\t\t\tif (!(geometry instanceof GeometryCollection)) {\n\t\t\t\treturn geometry;\n\t\t\t}\n\t\t\treturn this.widestGeometry(geometry);\n\t\t}\n\t},\n\thorizontalBisector: function (geometry) {\n\t\tvar envelope = geometry.getEnvelopeInternal();\n\t\tvar bisectY = SafeBisectorFinder.getBisectorY(geometry);\n\t\treturn this.factory.createLineString([new Coordinate(envelope.getMinX(), bisectY), new Coordinate(envelope.getMaxX(), bisectY)]);\n\t},\n\tadd: function (geom) {\n\t\tif (geom instanceof Polygon) {\n\t\t\tthis.addPolygon(geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tvar gc = geom;\n\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\tthis.add(gc.getGeometryN(i));\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn InteriorPointArea;\n\t}\n});\nInteriorPointArea.centre = function (envelope) {\n\treturn new Coordinate(InteriorPointArea.avg(envelope.getMinX(), envelope.getMaxX()), InteriorPointArea.avg(envelope.getMinY(), envelope.getMaxY()));\n};\nInteriorPointArea.avg = function (a, b) {\n\treturn (a + b) / 2.0;\n};\nfunction SafeBisectorFinder() {\n\tthis.poly = null;\n\tthis.centreY = null;\n\tthis.hiY = Double.MAX_VALUE;\n\tthis.loY = -Double.MAX_VALUE;\n\tlet poly = arguments[0];\n\tthis.poly = poly;\n\tthis.hiY = poly.getEnvelopeInternal().getMaxY();\n\tthis.loY = poly.getEnvelopeInternal().getMinY();\n\tthis.centreY = InteriorPointArea.avg(this.loY, this.hiY);\n}\nextend(SafeBisectorFinder.prototype, {\n\tupdateInterval: function (y) {\n\t\tif (y <= this.centreY) {\n\t\t\tif (y > this.loY) this.loY = y;\n\t\t} else if (y > this.centreY) {\n\t\t\tif (y < this.hiY) {\n\t\t\t\tthis.hiY = y;\n\t\t\t}\n\t\t}\n\t},\n\tgetBisectorY: function () {\n\t\tthis.process(this.poly.getExteriorRing());\n\t\tfor (var i = 0; i < this.poly.getNumInteriorRing(); i++) {\n\t\t\tthis.process(this.poly.getInteriorRingN(i));\n\t\t}\n\t\tvar bisectY = InteriorPointArea.avg(this.hiY, this.loY);\n\t\treturn bisectY;\n\t},\n\tprocess: function (line) {\n\t\tvar seq = line.getCoordinateSequence();\n\t\tfor (var i = 0; i < seq.size(); i++) {\n\t\t\tvar y = seq.getY(i);\n\t\t\tthis.updateInterval(y);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SafeBisectorFinder;\n\t}\n});\nSafeBisectorFinder.getBisectorY = function (poly) {\n\tvar finder = new SafeBisectorFinder(poly);\n\treturn finder.getBisectorY();\n};\nInteriorPointArea.SafeBisectorFinder = SafeBisectorFinder;\n","import LineString from '../geom/LineString';\nimport Geometry from '../geom/Geometry';\nimport Coordinate from '../geom/Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport GeometryCollection from '../geom/GeometryCollection';\nexport default function InteriorPointLine() {\n\tthis.centroid = null;\n\tthis.minDistance = Double.MAX_VALUE;\n\tthis.interiorPoint = null;\n\tlet g = arguments[0];\n\tthis.centroid = g.getCentroid().getCoordinate();\n\tthis.addInterior(g);\n\tif (this.interiorPoint === null) this.addEndpoints(g);\n}\nextend(InteriorPointLine.prototype, {\n\taddEndpoints: function () {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet geom = arguments[0];\n\t\t\tif (geom instanceof LineString) {\n\t\t\t\tthis.addEndpoints(geom.getCoordinates());\n\t\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\t\tvar gc = geom;\n\t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\t\tthis.addEndpoints(gc.getGeometryN(i));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Array) {\n\t\t\tlet pts = arguments[0];\n\t\t\tthis.add(pts[0]);\n\t\t\tthis.add(pts[pts.length - 1]);\n\t\t}\n\t},\n\tgetInteriorPoint: function () {\n\t\treturn this.interiorPoint;\n\t},\n\taddInterior: function () {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet geom = arguments[0];\n\t\t\tif (geom instanceof LineString) {\n\t\t\t\tthis.addInterior(geom.getCoordinates());\n\t\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\t\tvar gc = geom;\n\t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\t\tthis.addInterior(gc.getGeometryN(i));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Array) {\n\t\t\tlet pts = arguments[0];\n\t\t\tfor (var i = 1; i < pts.length - 1; i++) {\n\t\t\t\tthis.add(pts[i]);\n\t\t\t}\n\t\t}\n\t},\n\tadd: function (point) {\n\t\tvar dist = point.distance(this.centroid);\n\t\tif (dist < this.minDistance) {\n\t\t\tthis.interiorPoint = new Coordinate(point);\n\t\t\tthis.minDistance = dist;\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn InteriorPointLine;\n\t}\n});\n","import Geometry from '../geom/Geometry';\nimport Coordinate from '../geom/Coordinate';\nimport Point from '../geom/Point';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport GeometryCollection from '../geom/GeometryCollection';\nexport default function InteriorPointPoint() {\n\tthis.centroid = null;\n\tthis.minDistance = Double.MAX_VALUE;\n\tthis.interiorPoint = null;\n\tlet g = arguments[0];\n\tthis.centroid = g.getCentroid().getCoordinate();\n\tthis.add(g);\n}\nextend(InteriorPointPoint.prototype, {\n\tgetInteriorPoint: function () {\n\t\treturn this.interiorPoint;\n\t},\n\tadd: function () {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet geom = arguments[0];\n\t\t\tif (geom instanceof Point) {\n\t\t\t\tthis.add(geom.getCoordinate());\n\t\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\t\tvar gc = geom;\n\t\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\t\tthis.add(gc.getGeometryN(i));\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet point = arguments[0];\n\t\t\tvar dist = point.distance(this.centroid);\n\t\t\tif (dist < this.minDistance) {\n\t\t\t\tthis.interiorPoint = new Coordinate(point);\n\t\t\t\tthis.minDistance = dist;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn InteriorPointPoint;\n\t}\n});\n","import extend from '../../../../../extend';\nimport LineSegment from '../../geom/LineSegment';\nimport Envelope from '../../geom/Envelope';\nexport default function MonotoneChainSelectAction() {\n\tthis.tempEnv1 = new Envelope();\n\tthis.selectedSegment = new LineSegment();\n}\nextend(MonotoneChainSelectAction.prototype, {\n\tselect: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet seg = arguments[0];\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet mc = arguments[0], startIndex = arguments[1];\n\t\t\tmc.getLineSegment(startIndex, this.selectedSegment);\n\t\t\tthis.select(this.selectedSegment);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MonotoneChainSelectAction;\n\t}\n});\n","import extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function NodeBase() {\n\tthis.items = new ArrayList();\n\tthis.subnode = [null, null];\n}\nextend(NodeBase.prototype, {\n\thasChildren: function () {\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.subnode[i] !== null) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tisPrunable: function () {\n\t\treturn !(this.hasChildren() || this.hasItems());\n\t},\n\taddAllItems: function (items) {\n\t\titems.addAll(this.items);\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tthis.subnode[i].addAllItems(items);\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\tsize: function () {\n\t\tvar subSize = 0;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tsubSize += this.subnode[i].size();\n\t\t\t}\n\t\t}\n\t\treturn subSize + this.items.size();\n\t},\n\taddAllItemsFromOverlapping: function (interval, resultItems) {\n\t\tif (interval !== null && !this.isSearchMatch(interval)) return null;\n\t\tresultItems.addAll(this.items);\n\t\tif (this.subnode[0] !== null) this.subnode[0].addAllItemsFromOverlapping(interval, resultItems);\n\t\tif (this.subnode[1] !== null) this.subnode[1].addAllItemsFromOverlapping(interval, resultItems);\n\t},\n\thasItems: function () {\n\t\treturn !this.items.isEmpty();\n\t},\n\tremove: function (itemInterval, item) {\n\t\tif (!this.isSearchMatch(itemInterval)) return false;\n\t\tvar found = false;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tfound = this.subnode[i].remove(itemInterval, item);\n\t\t\t\tif (found) {\n\t\t\t\t\tif (this.subnode[i].isPrunable()) this.subnode[i] = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found) return found;\n\t\tfound = this.items.remove(item);\n\t\treturn found;\n\t},\n\tgetItems: function () {\n\t\treturn this.items;\n\t},\n\tdepth: function () {\n\t\tvar maxSubDepth = 0;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tvar sqd = this.subnode[i].depth();\n\t\t\t\tif (sqd > maxSubDepth) maxSubDepth = sqd;\n\t\t\t}\n\t\t}\n\t\treturn maxSubDepth + 1;\n\t},\n\tnodeSize: function () {\n\t\tvar subSize = 0;\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tsubSize += this.subnode[i].nodeSize();\n\t\t\t}\n\t\t}\n\t\treturn subSize + 1;\n\t},\n\tadd: function (item) {\n\t\tthis.items.add(item);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NodeBase;\n\t}\n});\nNodeBase.getSubnodeIndex = function (interval, centre) {\n\tvar subnodeIndex = -1;\n\tif (interval.min >= centre) subnodeIndex = 1;\n\tif (interval.max <= centre) subnodeIndex = 0;\n\treturn subnodeIndex;\n};\n","import extend from '../../../../../extend';\nexport default function Interval() {\n\tthis.min = null;\n\tthis.max = null;\n\tif (arguments.length === 0) {\n\t\tthis.min = 0.0;\n\t\tthis.max = 0.0;\n\t} else if (arguments.length === 1) {\n\t\tlet interval = arguments[0];\n\t\tthis.init(interval.min, interval.max);\n\t} else if (arguments.length === 2) {\n\t\tlet min = arguments[0], max = arguments[1];\n\t\tthis.init(min, max);\n\t}\n}\nextend(Interval.prototype, {\n\texpandToInclude: function (interval) {\n\t\tif (interval.max > this.max) this.max = interval.max;\n\t\tif (interval.min < this.min) this.min = interval.min;\n\t},\n\tgetWidth: function () {\n\t\treturn this.max - this.min;\n\t},\n\toverlaps: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet interval = arguments[0];\n\t\t\treturn this.overlaps(interval.min, interval.max);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet min = arguments[0], max = arguments[1];\n\t\t\tif (this.min > max || this.max < min) return false;\n\t\t\treturn true;\n\t\t}\n\t},\n\tgetMin: function () {\n\t\treturn this.min;\n\t},\n\ttoString: function () {\n\t\treturn \"[\" + this.min + \", \" + this.max + \"]\";\n\t},\n\tcontains: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Interval) {\n\t\t\t\tlet interval = arguments[0];\n\t\t\t\treturn this.contains(interval.min, interval.max);\n\t\t\t} else if (typeof arguments[0] === \"number\") {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn p >= this.min && p <= this.max;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet min = arguments[0], max = arguments[1];\n\t\t\treturn min >= this.min && max <= this.max;\n\t\t}\n\t},\n\tinit: function (min, max) {\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t\tif (min > max) {\n\t\t\tthis.min = max;\n\t\t\tthis.max = min;\n\t\t}\n\t},\n\tgetMax: function () {\n\t\treturn this.max;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Interval;\n\t}\n});\n","export default function DoubleBits () { }\nDoubleBits.exponent = function (d) {\n  return CVTFWD(64, d) - 1023\n}\nDoubleBits.powerOf2 = function (exp) {\n  return Math.pow(2, exp)\n}\n\n/**\n * Calculates the exponent of the bit-pattern for a number. Uses code from:\n * http://www.merlyn.demon.co.uk/js-exact.htm\n *\n * @param {Number}\n *          NumW 32 or 64 to denote the number of bits.\n * @param {Number}\n *          Qty the number to calculate the bit pattern for.\n * @return {Number} The integer value of the exponent.\n */\nfunction CVTFWD (NumW, Qty) {\n  var Sign\n  var Expo\n  var Mant\n  var Bin\n  var Inf = {\n    32: {\n      d: 0x7F,\n      c: 0x80,\n      b: 0,\n      a: 0\n    },\n    64: {\n      d: 0x7FF0,\n      c: 0,\n      b: 0,\n      a: 0\n    }\n  }\n  var ExW = {\n    32: 8,\n    64: 11\n  }[NumW]\n\n  if (!Bin) {\n    Sign = Qty < 0 || 1 / Qty < 0 // OK for +-0\n    if (!isFinite(Qty)) {\n      Bin = Inf[NumW]\n      if (Sign) {\n        Bin.d += 1 << (NumW / 4 - 1)\n      }\n      Expo = Math.pow(2, ExW) - 1\n      Mant = 0\n    }\n  }\n\n  if (!Bin) {\n    Expo = {\n      32: 127,\n      64: 1023\n    }[NumW]\n    Mant = Math.abs(Qty)\n    while (Mant >= 2) {\n      Expo++\n      Mant /= 2\n    }\n    while (Mant < 1 && Expo > 0) {\n      Expo--\n      Mant *= 2\n    }\n    if (Expo <= 0) {\n      Mant /= 2\n    }\n    if (NumW === 32 && Expo > 254) {\n      Bin = {\n        d: Sign ? 0xFF : 0x7F,\n        c: 0x80,\n        b: 0,\n        a: 0\n      }\n      Expo = Math.pow(2, ExW) - 1\n      Mant = 0\n    }\n  }\n\n  return Expo\n}\n","import Interval from './Interval';\nimport extend from '../../../../../extend';\nimport DoubleBits from '../quadtree/DoubleBits';\nexport default function Key() {\n\tthis.pt = 0.0;\n\tthis.level = 0;\n\tthis.interval = null;\n\tlet interval = arguments[0];\n\tthis.computeKey(interval);\n}\nextend(Key.prototype, {\n\tgetInterval: function () {\n\t\treturn this.interval;\n\t},\n\tgetLevel: function () {\n\t\treturn this.level;\n\t},\n\tcomputeKey: function (itemInterval) {\n\t\tthis.level = Key.computeLevel(itemInterval);\n\t\tthis.interval = new Interval();\n\t\tthis.computeInterval(this.level, itemInterval);\n\t\twhile (!this.interval.contains(itemInterval)) {\n\t\t\tthis.level += 1;\n\t\t\tthis.computeInterval(this.level, itemInterval);\n\t\t}\n\t},\n\tcomputeInterval: function (level, itemInterval) {\n\t\tvar size = DoubleBits.powerOf2(level);\n\t\tthis.pt = Math.floor(itemInterval.getMin() / size) * size;\n\t\tthis.interval.init(this.pt, this.pt + size);\n\t},\n\tgetPoint: function () {\n\t\treturn this.pt;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Key;\n\t}\n});\nKey.computeLevel = function (interval) {\n\tvar dx = interval.getWidth();\n\tvar level = DoubleBits.exponent(dx) + 1;\n\treturn level;\n};\n","import NodeBase from './NodeBase';\nimport Interval from './Interval';\nimport extend from '../../../../../extend';\nimport Assert from '../../util/Assert';\nimport inherits from '../../../../../inherits';\nimport Key from './Key';\nexport default function Node() {\n\tNodeBase.apply(this);\n\tthis.interval = null;\n\tthis.centre = null;\n\tthis.level = null;\n\tlet interval = arguments[0], level = arguments[1];\n\tthis.interval = interval;\n\tthis.level = level;\n\tthis.centre = (interval.getMin() + interval.getMax()) / 2;\n}\ninherits(Node, NodeBase);\nextend(Node.prototype, {\n\tgetInterval: function () {\n\t\treturn this.interval;\n\t},\n\tfind: function (searchInterval) {\n\t\tvar subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this.centre);\n\t\tif (subnodeIndex === -1) return this;\n\t\tif (this.subnode[subnodeIndex] !== null) {\n\t\t\tvar node = this.subnode[subnodeIndex];\n\t\t\treturn node.find(searchInterval);\n\t\t}\n\t\treturn this;\n\t},\n\tinsert: function (node) {\n\t\tAssert.isTrue(this.interval === null || this.interval.contains(node.interval));\n\t\tvar index = NodeBase.getSubnodeIndex(node.interval, this.centre);\n\t\tif (node.level === this.level - 1) {\n\t\t\tthis.subnode[index] = node;\n\t\t} else {\n\t\t\tvar childNode = this.createSubnode(index);\n\t\t\tchildNode.insert(node);\n\t\t\tthis.subnode[index] = childNode;\n\t\t}\n\t},\n\tisSearchMatch: function (itemInterval) {\n\t\treturn itemInterval.overlaps(this.interval);\n\t},\n\tgetSubnode: function (index) {\n\t\tif (this.subnode[index] === null) {\n\t\t\tthis.subnode[index] = this.createSubnode(index);\n\t\t}\n\t\treturn this.subnode[index];\n\t},\n\tgetNode: function (searchInterval) {\n\t\tvar subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this.centre);\n\t\tif (subnodeIndex !== -1) {\n\t\t\tvar node = this.getSubnode(subnodeIndex);\n\t\t\treturn node.getNode(searchInterval);\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t},\n\tcreateSubnode: function (index) {\n\t\tvar min = 0.0;\n\t\tvar max = 0.0;\n\t\tswitch (index) {\n\t\t\tcase 0:\n\t\t\t\tmin = this.interval.getMin();\n\t\t\t\tmax = this.centre;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tmin = this.centre;\n\t\t\t\tmax = this.interval.getMax();\n\t\t\t\tbreak;\n\t\t}\n\t\tvar subInt = new Interval(min, max);\n\t\tvar node = new Node(subInt, this.level - 1);\n\t\treturn node;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Node;\n\t}\n});\nNode.createNode = function (itemInterval) {\n\tvar key = new Key(itemInterval);\n\tvar node = new Node(key.getInterval(), key.getLevel());\n\treturn node;\n};\nNode.createExpanded = function (node, addInterval) {\n\tvar expandInt = new Interval(addInterval);\n\tif (node !== null) expandInt.expandToInclude(node.interval);\n\tvar largerNode = Node.createNode(expandInt);\n\tif (node !== null) largerNode.insert(node);\n\treturn largerNode;\n};\n","import extend from '../../../../../extend';\nimport DoubleBits from './DoubleBits';\nexport default function IntervalSize() {}\nextend(IntervalSize.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IntervalSize;\n\t}\n});\nIntervalSize.isZeroWidth = function (min, max) {\n\tvar width = max - min;\n\tif (width === 0.0) return true;\n\tvar maxAbs = Math.max(Math.abs(min), Math.abs(max));\n\tvar scaledInterval = width / maxAbs;\n\tvar level = DoubleBits.exponent(scaledInterval);\n\treturn level <= IntervalSize.MIN_BINARY_EXPONENT;\n};\nIntervalSize.MIN_BINARY_EXPONENT = -50;\n","import NodeBase from './NodeBase';\nimport Node from './Node';\nimport extend from '../../../../../extend';\nimport IntervalSize from '../quadtree/IntervalSize';\nimport Assert from '../../util/Assert';\nimport inherits from '../../../../../inherits';\nexport default function Root() {\n\tNodeBase.apply(this);\n}\ninherits(Root, NodeBase);\nextend(Root.prototype, {\n\tinsert: function (itemInterval, item) {\n\t\tvar index = NodeBase.getSubnodeIndex(itemInterval, Root.origin);\n\t\tif (index === -1) {\n\t\t\tthis.add(item);\n\t\t\treturn null;\n\t\t}\n\t\tvar node = this.subnode[index];\n\t\tif (node === null || !node.getInterval().contains(itemInterval)) {\n\t\t\tvar largerNode = Node.createExpanded(node, itemInterval);\n\t\t\tthis.subnode[index] = largerNode;\n\t\t}\n\t\tthis.insertContained(this.subnode[index], itemInterval, item);\n\t},\n\tisSearchMatch: function (interval) {\n\t\treturn true;\n\t},\n\tinsertContained: function (tree, itemInterval, item) {\n\t\tAssert.isTrue(tree.getInterval().contains(itemInterval));\n\t\tvar isZeroArea = IntervalSize.isZeroWidth(itemInterval.getMin(), itemInterval.getMax());\n\t\tvar node = null;\n\t\tif (isZeroArea) node = tree.find(itemInterval); else node = tree.getNode(itemInterval);\n\t\tnode.add(item);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Root;\n\t}\n});\nRoot.origin = 0.0;\n","import Root from './Root';\nimport Interval from './Interval';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function Bintree() {\n\tthis.root = null;\n\tthis.minExtent = 1.0;\n\tthis.root = new Root();\n}\nextend(Bintree.prototype, {\n\tsize: function () {\n\t\tif (this.root !== null) return this.root.size();\n\t\treturn 0;\n\t},\n\tinsert: function (itemInterval, item) {\n\t\tthis.collectStats(itemInterval);\n\t\tvar insertInterval = Bintree.ensureExtent(itemInterval, this.minExtent);\n\t\tthis.root.insert(insertInterval, item);\n\t},\n\tquery: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (typeof arguments[0] === \"number\") {\n\t\t\t\tlet x = arguments[0];\n\t\t\t\treturn this.query(new Interval(x, x));\n\t\t\t} else if (arguments[0] instanceof Interval) {\n\t\t\t\tlet interval = arguments[0];\n\t\t\t\tvar foundItems = new ArrayList();\n\t\t\t\tthis.query(interval, foundItems);\n\t\t\t\treturn foundItems;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet interval = arguments[0], foundItems = arguments[1];\n\t\t\tthis.root.addAllItemsFromOverlapping(interval, foundItems);\n\t\t}\n\t},\n\titerator: function () {\n\t\tvar foundItems = new ArrayList();\n\t\tthis.root.addAllItems(foundItems);\n\t\treturn foundItems.iterator();\n\t},\n\tremove: function (itemInterval, item) {\n\t\tvar insertInterval = Bintree.ensureExtent(itemInterval, this.minExtent);\n\t\treturn this.root.remove(insertInterval, item);\n\t},\n\tcollectStats: function (interval) {\n\t\tvar del = interval.getWidth();\n\t\tif (del < this.minExtent && del > 0.0) this.minExtent = del;\n\t},\n\tdepth: function () {\n\t\tif (this.root !== null) return this.root.depth();\n\t\treturn 0;\n\t},\n\tnodeSize: function () {\n\t\tif (this.root !== null) return this.root.nodeSize();\n\t\treturn 0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Bintree;\n\t}\n});\nBintree.ensureExtent = function (itemInterval, minExtent) {\n\tvar min = itemInterval.getMin();\n\tvar max = itemInterval.getMax();\n\tif (min !== max) return itemInterval;\n\tif (min === max) {\n\t\tmin = min - minExtent / 2.0;\n\t\tmax = min + minExtent / 2.0;\n\t}\n\treturn new Interval(min, max);\n};\n","import extend from '../../../../extend';\nexport default function PointInRing() {}\nextend(PointInRing.prototype, {\n\tisInside: function (pt) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PointInRing;\n\t}\n});\n","import MonotoneChainSelectAction from '../index/chain/MonotoneChainSelectAction';\nimport Bintree from '../index/bintree/Bintree';\nimport Interval from '../index/bintree/Interval';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport MonotoneChainBuilder from '../index/chain/MonotoneChainBuilder';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport RobustDeterminant from './RobustDeterminant';\nimport Envelope from '../geom/Envelope';\nimport inherits from '../../../../inherits';\nimport PointInRing from './PointInRing';\nexport default function MCPointInRing() {\n\tthis.ring = null;\n\tthis.tree = null;\n\tthis.crossings = 0;\n\tthis.interval = new Interval();\n\tlet ring = arguments[0];\n\tthis.ring = ring;\n\tthis.buildIndex();\n}\nextend(MCPointInRing.prototype, {\n\ttestLineSegment: function (p, seg) {\n\t\tvar xInt = null;\n\t\tvar x1 = null;\n\t\tvar y1 = null;\n\t\tvar x2 = null;\n\t\tvar y2 = null;\n\t\tvar p1 = seg.p0;\n\t\tvar p2 = seg.p1;\n\t\tx1 = p1.x - p.x;\n\t\ty1 = p1.y - p.y;\n\t\tx2 = p2.x - p.x;\n\t\ty2 = p2.y - p.y;\n\t\tif (y1 > 0 && y2 <= 0 || y2 > 0 && y1 <= 0) {\n\t\t\txInt = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2) / (y2 - y1);\n\t\t\tif (0.0 < xInt) {\n\t\t\t\tthis.crossings++;\n\t\t\t}\n\t\t}\n\t},\n\tbuildIndex: function () {\n\t\tthis.tree = new Bintree();\n\t\tvar pts = CoordinateArrays.removeRepeatedPoints(this.ring.getCoordinates());\n\t\tvar mcList = MonotoneChainBuilder.getChains(pts);\n\t\tfor (var i = 0; i < mcList.size(); i++) {\n\t\t\tvar mc = mcList.get(i);\n\t\t\tvar mcEnv = mc.getEnvelope();\n\t\t\tthis.interval.min = mcEnv.getMinY();\n\t\t\tthis.interval.max = mcEnv.getMaxY();\n\t\t\tthis.tree.insert(this.interval, mc);\n\t\t}\n\t},\n\ttestMonotoneChain: function (rayEnv, mcSelecter, mc) {\n\t\tmc.select(rayEnv, mcSelecter);\n\t},\n\tisInside: function (pt) {\n\t\tthis.crossings = 0;\n\t\tvar rayEnv = new Envelope(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, pt.y, pt.y);\n\t\tthis.interval.min = pt.y;\n\t\tthis.interval.max = pt.y;\n\t\tvar segs = this.tree.query(this.interval);\n\t\tvar mcSelecter = new MCSelecter(this, pt);\n\t\tfor (var i = segs.iterator(); i.hasNext(); ) {\n\t\t\tvar mc = i.next();\n\t\t\tthis.testMonotoneChain(rayEnv, mcSelecter, mc);\n\t\t}\n\t\tif (this.crossings % 2 === 1) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [PointInRing];\n\t},\n\tgetClass: function () {\n\t\treturn MCPointInRing;\n\t}\n});\nfunction MCSelecter() {\n\tMonotoneChainSelectAction.apply(this);\n\tthis.mcp = null;\n\tthis.p = null;\n\tlet mcp = arguments[0], p = arguments[1];\n\tthis.mcp = mcp;\n\tthis.p = p;\n}\ninherits(MCSelecter, MonotoneChainSelectAction);\nextend(MCSelecter.prototype, {\n\tselect: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet ls = arguments[0];\n\t\t\tthis.mcp.testLineSegment(this.p, ls);\n\t\t} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MCSelecter;\n\t}\n});\nMCPointInRing.MCSelecter = MCSelecter;\n","import CGAlgorithms from './CGAlgorithms';\nimport extend from '../../../../extend';\nexport default function Angle() {}\nextend(Angle.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Angle;\n\t}\n});\nAngle.toDegrees = function (radians) {\n\treturn radians * 180 / Math.PI;\n};\nAngle.normalize = function (angle) {\n\twhile (angle > Math.PI) angle -= Angle.PI_TIMES_2;\n\twhile (angle <= -Math.PI) angle += Angle.PI_TIMES_2;\n\treturn angle;\n};\nAngle.angle = function () {\n\tif (arguments.length === 1) {\n\t\tlet p = arguments[0];\n\t\treturn Math.atan2(p.y, p.x);\n\t} else if (arguments.length === 2) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tvar dx = p1.x - p0.x;\n\t\tvar dy = p1.y - p0.y;\n\t\treturn Math.atan2(dy, dx);\n\t}\n};\nAngle.isAcute = function (p0, p1, p2) {\n\tvar dx0 = p0.x - p1.x;\n\tvar dy0 = p0.y - p1.y;\n\tvar dx1 = p2.x - p1.x;\n\tvar dy1 = p2.y - p1.y;\n\tvar dotprod = dx0 * dx1 + dy0 * dy1;\n\treturn dotprod > 0;\n};\nAngle.isObtuse = function (p0, p1, p2) {\n\tvar dx0 = p0.x - p1.x;\n\tvar dy0 = p0.y - p1.y;\n\tvar dx1 = p2.x - p1.x;\n\tvar dy1 = p2.y - p1.y;\n\tvar dotprod = dx0 * dx1 + dy0 * dy1;\n\treturn dotprod < 0;\n};\nAngle.interiorAngle = function (p0, p1, p2) {\n\tvar anglePrev = Angle.angle(p1, p0);\n\tvar angleNext = Angle.angle(p1, p2);\n\treturn Math.abs(angleNext - anglePrev);\n};\nAngle.normalizePositive = function (angle) {\n\tif (angle < 0.0) {\n\t\twhile (angle < 0.0) angle += Angle.PI_TIMES_2;\n\t\tif (angle >= Angle.PI_TIMES_2) angle = 0.0;\n\t} else {\n\t\twhile (angle >= Angle.PI_TIMES_2) angle -= Angle.PI_TIMES_2;\n\t\tif (angle < 0.0) angle = 0.0;\n\t}\n\treturn angle;\n};\nAngle.angleBetween = function (tip1, tail, tip2) {\n\tvar a1 = Angle.angle(tail, tip1);\n\tvar a2 = Angle.angle(tail, tip2);\n\treturn Angle.diff(a1, a2);\n};\nAngle.diff = function (ang1, ang2) {\n\tvar delAngle = null;\n\tif (ang1 < ang2) {\n\t\tdelAngle = ang2 - ang1;\n\t} else {\n\t\tdelAngle = ang1 - ang2;\n\t}\n\tif (delAngle > Math.PI) {\n\t\tdelAngle = 2 * Math.PI - delAngle;\n\t}\n\treturn delAngle;\n};\nAngle.toRadians = function (angleDegrees) {\n\treturn angleDegrees * Math.PI / 180.0;\n};\nAngle.getTurn = function (ang1, ang2) {\n\tvar crossproduct = Math.sin(ang2 - ang1);\n\tif (crossproduct > 0) {\n\t\treturn Angle.COUNTERCLOCKWISE;\n\t}\n\tif (crossproduct < 0) {\n\t\treturn Angle.CLOCKWISE;\n\t}\n\treturn Angle.NONE;\n};\nAngle.angleBetweenOriented = function (tip1, tail, tip2) {\n\tvar a1 = Angle.angle(tail, tip1);\n\tvar a2 = Angle.angle(tail, tip2);\n\tvar angDel = a2 - a1;\n\tif (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;\n\tif (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;\n\treturn angDel;\n};\nAngle.PI_TIMES_2 = 2.0 * Math.PI;\nAngle.PI_OVER_2 = Math.PI / 2.0;\nAngle.PI_OVER_4 = Math.PI / 4.0;\nAngle.COUNTERCLOCKWISE = CGAlgorithms.COUNTERCLOCKWISE;\nAngle.CLOCKWISE = CGAlgorithms.CLOCKWISE;\nAngle.NONE = CGAlgorithms.COLLINEAR;\n","import Coordinate from './Coordinate';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport Angle from '../algorithm/Angle';\nimport HCoordinate from '../algorithm/HCoordinate';\nexport default function Triangle() {\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tthis.p2 = null;\n\tlet p0 = arguments[0], p1 = arguments[1], p2 = arguments[2];\n\tthis.p0 = p0;\n\tthis.p1 = p1;\n\tthis.p2 = p2;\n}\nextend(Triangle.prototype, {\n\tarea: function () {\n\t\treturn Triangle.area(this.p0, this.p1, this.p2);\n\t},\n\tsignedArea: function () {\n\t\treturn Triangle.signedArea(this.p0, this.p1, this.p2);\n\t},\n\tinterpolateZ: function (p) {\n\t\tif (p === null) throw new IllegalArgumentException(\"Supplied point is null.\");\n\t\treturn Triangle.interpolateZ(p, this.p0, this.p1, this.p2);\n\t},\n\tlongestSideLength: function () {\n\t\treturn Triangle.longestSideLength(this.p0, this.p1, this.p2);\n\t},\n\tisAcute: function () {\n\t\treturn Triangle.isAcute(this.p0, this.p1, this.p2);\n\t},\n\tcircumcentre: function () {\n\t\treturn Triangle.circumcentre(this.p0, this.p1, this.p2);\n\t},\n\tarea3D: function () {\n\t\treturn Triangle.area3D(this.p0, this.p1, this.p2);\n\t},\n\tcentroid: function () {\n\t\treturn Triangle.centroid(this.p0, this.p1, this.p2);\n\t},\n\tinCentre: function () {\n\t\treturn Triangle.inCentre(this.p0, this.p1, this.p2);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Triangle;\n\t}\n});\nTriangle.area = function (a, b, c) {\n\treturn Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);\n};\nTriangle.signedArea = function (a, b, c) {\n\treturn ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;\n};\nTriangle.det = function (m00, m01, m10, m11) {\n\treturn m00 * m11 - m01 * m10;\n};\nTriangle.interpolateZ = function (p, v0, v1, v2) {\n\tvar x0 = v0.x;\n\tvar y0 = v0.y;\n\tvar a = v1.x - x0;\n\tvar b = v2.x - x0;\n\tvar c = v1.y - y0;\n\tvar d = v2.y - y0;\n\tvar det = a * d - b * c;\n\tvar dx = p.x - x0;\n\tvar dy = p.y - y0;\n\tvar t = (d * dx - b * dy) / det;\n\tvar u = (-c * dx + a * dy) / det;\n\tvar z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n\treturn z;\n};\nTriangle.longestSideLength = function (a, b, c) {\n\tvar lenAB = a.distance(b);\n\tvar lenBC = b.distance(c);\n\tvar lenCA = c.distance(a);\n\tvar maxLen = lenAB;\n\tif (lenBC > maxLen) maxLen = lenBC;\n\tif (lenCA > maxLen) maxLen = lenCA;\n\treturn maxLen;\n};\nTriangle.isAcute = function (a, b, c) {\n\tif (!Angle.isAcute(a, b, c)) return false;\n\tif (!Angle.isAcute(b, c, a)) return false;\n\tif (!Angle.isAcute(c, a, b)) return false;\n\treturn true;\n};\nTriangle.circumcentre = function (a, b, c) {\n\tvar cx = c.x;\n\tvar cy = c.y;\n\tvar ax = a.x - cx;\n\tvar ay = a.y - cy;\n\tvar bx = b.x - cx;\n\tvar by = b.y - cy;\n\tvar denom = 2 * Triangle.det(ax, ay, bx, by);\n\tvar numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n\tvar numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n\tvar ccx = cx - numx / denom;\n\tvar ccy = cy + numy / denom;\n\treturn new Coordinate(ccx, ccy);\n};\nTriangle.perpendicularBisector = function (a, b) {\n\tvar dx = b.x - a.x;\n\tvar dy = b.y - a.y;\n\tvar l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n\tvar l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n\treturn new HCoordinate(l1, l2);\n};\nTriangle.angleBisector = function (a, b, c) {\n\tvar len0 = b.distance(a);\n\tvar len2 = b.distance(c);\n\tvar frac = len0 / (len0 + len2);\n\tvar dx = c.x - a.x;\n\tvar dy = c.y - a.y;\n\tvar splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n\treturn splitPt;\n};\nTriangle.area3D = function (a, b, c) {\n\tvar ux = b.x - a.x;\n\tvar uy = b.y - a.y;\n\tvar uz = b.z - a.z;\n\tvar vx = c.x - a.x;\n\tvar vy = c.y - a.y;\n\tvar vz = c.z - a.z;\n\tvar crossx = uy * vz - uz * vy;\n\tvar crossy = uz * vx - ux * vz;\n\tvar crossz = ux * vy - uy * vx;\n\tvar absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n\tvar area3D = Math.sqrt(absSq) / 2;\n\treturn area3D;\n};\nTriangle.centroid = function (a, b, c) {\n\tvar x = (a.x + b.x + c.x) / 3;\n\tvar y = (a.y + b.y + c.y) / 3;\n\treturn new Coordinate(x, y);\n};\nTriangle.inCentre = function (a, b, c) {\n\tvar len0 = b.distance(c);\n\tvar len1 = a.distance(c);\n\tvar len2 = a.distance(b);\n\tvar circum = len0 + len1 + len2;\n\tvar inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n\tvar inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n\treturn new Coordinate(inCentreX, inCentreY);\n};\n","import Coordinate from '../geom/Coordinate';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport Angle from './Angle';\nimport Assert from '../util/Assert';\nimport Triangle from '../geom/Triangle';\nexport default function MinimumBoundingCircle() {\n\tthis.input = null;\n\tthis.extremalPts = null;\n\tthis.centre = null;\n\tthis.radius = 0.0;\n\tlet geom = arguments[0];\n\tthis.input = geom;\n}\nextend(MinimumBoundingCircle.prototype, {\n\tgetRadius: function () {\n\t\tthis.compute();\n\t\treturn this.radius;\n\t},\n\tgetDiameter: function () {\n\t\tthis.compute();\n\t\tswitch (this.extremalPts.length) {\n\t\t\tcase 0:\n\t\t\t\treturn this.input.getFactory().createLineString();\n\t\t\tcase 1:\n\t\t\t\treturn this.input.getFactory().createPoint(this.centre);\n\t\t}\n\t\tvar p0 = this.extremalPts[0];\n\t\tvar p1 = this.extremalPts[1];\n\t\treturn this.input.getFactory().createLineString([p0, p1]);\n\t},\n\tgetExtremalPoints: function () {\n\t\tthis.compute();\n\t\treturn this.extremalPts;\n\t},\n\tcomputeCirclePoints: function () {\n\t\tif (this.input.isEmpty()) {\n\t\t\tthis.extremalPts = new Array(0).fill(null);\n\t\t\treturn null;\n\t\t}\n\t\tif (this.input.getNumPoints() === 1) {\n\t\t\tvar pts = this.input.getCoordinates();\n\t\t\tthis.extremalPts = [new Coordinate(pts[0])];\n\t\t\treturn null;\n\t\t}\n\t\tvar convexHull = this.input.convexHull();\n\t\tvar hullPts = convexHull.getCoordinates();\n\t\tvar pts = hullPts;\n\t\tif (hullPts[0].equals2D(hullPts[hullPts.length - 1])) {\n\t\t\tpts = new Array(hullPts.length - 1).fill(null);\n\t\t\tCoordinateArrays.copyDeep(hullPts, 0, pts, 0, hullPts.length - 1);\n\t\t}\n\t\tif (pts.length <= 2) {\n\t\t\tthis.extremalPts = CoordinateArrays.copyDeep(pts);\n\t\t\treturn null;\n\t\t}\n\t\tvar P = MinimumBoundingCircle.lowestPoint(pts);\n\t\tvar Q = MinimumBoundingCircle.pointWitMinAngleWithX(pts, P);\n\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\tvar R = MinimumBoundingCircle.pointWithMinAngleWithSegment(pts, P, Q);\n\t\t\tif (Angle.isObtuse(P, R, Q)) {\n\t\t\t\tthis.extremalPts = [new Coordinate(P), new Coordinate(Q)];\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (Angle.isObtuse(R, P, Q)) {\n\t\t\t\tP = R;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (Angle.isObtuse(R, Q, P)) {\n\t\t\t\tQ = R;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.extremalPts = [new Coordinate(P), new Coordinate(Q), new Coordinate(R)];\n\t\t\treturn null;\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"Logic failure in Minimum Bounding Circle algorithm!\");\n\t},\n\tcompute: function () {\n\t\tif (this.extremalPts !== null) return null;\n\t\tthis.computeCirclePoints();\n\t\tthis.computeCentre();\n\t\tif (this.centre !== null) this.radius = this.centre.distance(this.extremalPts[0]);\n\t},\n\tgetFarthestPoints: function () {\n\t\tthis.compute();\n\t\tswitch (this.extremalPts.length) {\n\t\t\tcase 0:\n\t\t\t\treturn this.input.getFactory().createLineString();\n\t\t\tcase 1:\n\t\t\t\treturn this.input.getFactory().createPoint(this.centre);\n\t\t}\n\t\tvar p0 = this.extremalPts[0];\n\t\tvar p1 = this.extremalPts[this.extremalPts.length - 1];\n\t\treturn this.input.getFactory().createLineString([p0, p1]);\n\t},\n\tgetCircle: function () {\n\t\tthis.compute();\n\t\tif (this.centre === null) return this.input.getFactory().createPolygon();\n\t\tvar centrePoint = this.input.getFactory().createPoint(this.centre);\n\t\tif (this.radius === 0.0) return centrePoint;\n\t\treturn centrePoint.buffer(this.radius);\n\t},\n\tgetCentre: function () {\n\t\tthis.compute();\n\t\treturn this.centre;\n\t},\n\tcomputeCentre: function () {\n\t\tswitch (this.extremalPts.length) {\n\t\t\tcase 0:\n\t\t\t\tthis.centre = null;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tthis.centre = this.extremalPts[0];\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.centre = new Coordinate((this.extremalPts[0].x + this.extremalPts[1].x) / 2.0, (this.extremalPts[0].y + this.extremalPts[1].y) / 2.0);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.centre = Triangle.circumcentre(this.extremalPts[0], this.extremalPts[1], this.extremalPts[2]);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MinimumBoundingCircle;\n\t}\n});\nMinimumBoundingCircle.pointWitMinAngleWithX = function (pts, P) {\n\tvar minSin = Double.MAX_VALUE;\n\tvar minAngPt = null;\n\tfor (var i = 0; i < pts.length; i++) {\n\t\tvar p = pts[i];\n\t\tif (p === P) continue;\n\t\tvar dx = p.x - P.x;\n\t\tvar dy = p.y - P.y;\n\t\tif (dy < 0) dy = -dy;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar sin = dy / len;\n\t\tif (sin < minSin) {\n\t\t\tminSin = sin;\n\t\t\tminAngPt = p;\n\t\t}\n\t}\n\treturn minAngPt;\n};\nMinimumBoundingCircle.lowestPoint = function (pts) {\n\tvar min = pts[0];\n\tfor (var i = 1; i < pts.length; i++) {\n\t\tif (pts[i].y < min.y) min = pts[i];\n\t}\n\treturn min;\n};\nMinimumBoundingCircle.pointWithMinAngleWithSegment = function (pts, P, Q) {\n\tvar minAng = Double.MAX_VALUE;\n\tvar minAngPt = null;\n\tfor (var i = 0; i < pts.length; i++) {\n\t\tvar p = pts[i];\n\t\tif (p === P) continue;\n\t\tif (p === Q) continue;\n\t\tvar ang = Angle.angleBetween(P, p, Q);\n\t\tif (ang < minAng) {\n\t\t\tminAng = ang;\n\t\t\tminAngPt = p;\n\t\t}\n\t}\n\treturn minAngPt;\n};\n","import Coordinate from '../geom/Coordinate';\nimport Polygon from '../geom/Polygon';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport LineSegment from '../geom/LineSegment';\nimport ConvexHull from './ConvexHull';\nexport default function MinimumDiameter() {\n\tthis.inputGeom = null;\n\tthis.isConvex = null;\n\tthis.convexHullPts = null;\n\tthis.minBaseSeg = new LineSegment();\n\tthis.minWidthPt = null;\n\tthis.minPtIndex = null;\n\tthis.minWidth = 0.0;\n\tif (arguments.length === 1) {\n\t\tlet inputGeom = arguments[0];\n\t\tMinimumDiameter.call(this, inputGeom, false);\n\t} else if (arguments.length === 2) {\n\t\tlet inputGeom = arguments[0], isConvex = arguments[1];\n\t\tthis.inputGeom = inputGeom;\n\t\tthis.isConvex = isConvex;\n\t}\n}\nextend(MinimumDiameter.prototype, {\n\tgetWidthCoordinate: function () {\n\t\tthis.computeMinimumDiameter();\n\t\treturn this.minWidthPt;\n\t},\n\tgetSupportingSegment: function () {\n\t\tthis.computeMinimumDiameter();\n\t\treturn this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0, this.minBaseSeg.p1]);\n\t},\n\tgetDiameter: function () {\n\t\tthis.computeMinimumDiameter();\n\t\tif (this.minWidthPt === null) return this.inputGeom.getFactory().createLineString(null);\n\t\tvar basePt = this.minBaseSeg.project(this.minWidthPt);\n\t\treturn this.inputGeom.getFactory().createLineString([basePt, this.minWidthPt]);\n\t},\n\tcomputeWidthConvex: function (convexGeom) {\n\t\tif (convexGeom instanceof Polygon) this.convexHullPts = convexGeom.getExteriorRing().getCoordinates(); else this.convexHullPts = convexGeom.getCoordinates();\n\t\tif (this.convexHullPts.length === 0) {\n\t\t\tthis.minWidth = 0.0;\n\t\t\tthis.minWidthPt = null;\n\t\t\tthis.minBaseSeg = null;\n\t\t} else if (this.convexHullPts.length === 1) {\n\t\t\tthis.minWidth = 0.0;\n\t\t\tthis.minWidthPt = this.convexHullPts[0];\n\t\t\tthis.minBaseSeg.p0 = this.convexHullPts[0];\n\t\t\tthis.minBaseSeg.p1 = this.convexHullPts[0];\n\t\t} else if (this.convexHullPts.length === 2 || this.convexHullPts.length === 3) {\n\t\t\tthis.minWidth = 0.0;\n\t\t\tthis.minWidthPt = this.convexHullPts[0];\n\t\t\tthis.minBaseSeg.p0 = this.convexHullPts[0];\n\t\t\tthis.minBaseSeg.p1 = this.convexHullPts[1];\n\t\t} else this.computeConvexRingMinDiameter(this.convexHullPts);\n\t},\n\tcomputeConvexRingMinDiameter: function (pts) {\n\t\tthis.minWidth = Double.MAX_VALUE;\n\t\tvar currMaxIndex = 1;\n\t\tvar seg = new LineSegment();\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tseg.p0 = pts[i];\n\t\t\tseg.p1 = pts[i + 1];\n\t\t\tcurrMaxIndex = this.findMaxPerpDistance(pts, seg, currMaxIndex);\n\t\t}\n\t},\n\tcomputeMinimumDiameter: function () {\n\t\tif (this.minWidthPt !== null) return null;\n\t\tif (this.isConvex) this.computeWidthConvex(this.inputGeom); else {\n\t\t\tvar convexGeom = new ConvexHull(this.inputGeom).getConvexHull();\n\t\t\tthis.computeWidthConvex(convexGeom);\n\t\t}\n\t},\n\tgetLength: function () {\n\t\tthis.computeMinimumDiameter();\n\t\treturn this.minWidth;\n\t},\n\tfindMaxPerpDistance: function (pts, seg, startIndex) {\n\t\tvar maxPerpDistance = seg.distancePerpendicular(pts[startIndex]);\n\t\tvar nextPerpDistance = maxPerpDistance;\n\t\tvar maxIndex = startIndex;\n\t\tvar nextIndex = maxIndex;\n\t\twhile (nextPerpDistance >= maxPerpDistance) {\n\t\t\tmaxPerpDistance = nextPerpDistance;\n\t\t\tmaxIndex = nextIndex;\n\t\t\tnextIndex = MinimumDiameter.nextIndex(pts, maxIndex);\n\t\t\tnextPerpDistance = seg.distancePerpendicular(pts[nextIndex]);\n\t\t}\n\t\tif (maxPerpDistance < this.minWidth) {\n\t\t\tthis.minPtIndex = maxIndex;\n\t\t\tthis.minWidth = maxPerpDistance;\n\t\t\tthis.minWidthPt = pts[this.minPtIndex];\n\t\t\tthis.minBaseSeg = new LineSegment(seg);\n\t\t}\n\t\treturn maxIndex;\n\t},\n\tgetMinimumRectangle: function () {\n\t\tthis.computeMinimumDiameter();\n\t\tif (this.minWidth === 0.0) {\n\t\t\tif (this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1)) {\n\t\t\t\treturn this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0);\n\t\t\t}\n\t\t\treturn this.minBaseSeg.toGeometry(this.inputGeom.getFactory());\n\t\t}\n\t\tvar dx = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x;\n\t\tvar dy = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y;\n\t\tvar minPara = Double.MAX_VALUE;\n\t\tvar maxPara = -Double.MAX_VALUE;\n\t\tvar minPerp = Double.MAX_VALUE;\n\t\tvar maxPerp = -Double.MAX_VALUE;\n\t\tfor (var i = 0; i < this.convexHullPts.length; i++) {\n\t\t\tvar paraC = MinimumDiameter.computeC(dx, dy, this.convexHullPts[i]);\n\t\t\tif (paraC > maxPara) maxPara = paraC;\n\t\t\tif (paraC < minPara) minPara = paraC;\n\t\t\tvar perpC = MinimumDiameter.computeC(-dy, dx, this.convexHullPts[i]);\n\t\t\tif (perpC > maxPerp) maxPerp = perpC;\n\t\t\tif (perpC < minPerp) minPerp = perpC;\n\t\t}\n\t\tvar maxPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, maxPerp);\n\t\tvar minPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, minPerp);\n\t\tvar maxParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, maxPara);\n\t\tvar minParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, minPara);\n\t\tvar p0 = maxParaLine.lineIntersection(maxPerpLine);\n\t\tvar p1 = minParaLine.lineIntersection(maxPerpLine);\n\t\tvar p2 = minParaLine.lineIntersection(minPerpLine);\n\t\tvar p3 = maxParaLine.lineIntersection(minPerpLine);\n\t\tvar shell = this.inputGeom.getFactory().createLinearRing([p0, p1, p2, p3, p0]);\n\t\treturn this.inputGeom.getFactory().createPolygon(shell, null);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MinimumDiameter;\n\t}\n});\nMinimumDiameter.nextIndex = function (pts, index) {\n\tindex++;\n\tif (index >= pts.length) index = 0;\n\treturn index;\n};\nMinimumDiameter.computeC = function (a, b, p) {\n\treturn a * p.y - b * p.x;\n};\nMinimumDiameter.getMinimumDiameter = function (geom) {\n\treturn new MinimumDiameter(geom).getDiameter();\n};\nMinimumDiameter.getMinimumRectangle = function (geom) {\n\treturn new MinimumDiameter(geom).getMinimumRectangle();\n};\nMinimumDiameter.computeSegmentForLine = function (a, b, c) {\n\tvar p0 = null;\n\tvar p1 = null;\n\tif (Math.abs(b) > Math.abs(a)) {\n\t\tp0 = new Coordinate(0.0, c / b);\n\t\tp1 = new Coordinate(1.0, c / b - a / b);\n\t} else {\n\t\tp0 = new Coordinate(c / a, 0.0);\n\t\tp1 = new Coordinate(c / a - b / a, 1.0);\n\t}\n\treturn new LineSegment(p0, p1);\n};\n","import LineString from '../geom/LineString';\nimport CoordinateList from '../geom/CoordinateList';\nimport GeometryTransformer from '../geom/util/GeometryTransformer';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport LineSegment from '../geom/LineSegment';\nimport inherits from '../../../../inherits';\nexport default function Densifier() {\n\tthis.inputGeom = null;\n\tthis.distanceTolerance = null;\n\tlet inputGeom = arguments[0];\n\tthis.inputGeom = inputGeom;\n}\nextend(Densifier.prototype, {\n\tgetResultGeometry: function () {\n\t\treturn new DensifyTransformer(this.distanceTolerance).transform(this.inputGeom);\n\t},\n\tsetDistanceTolerance: function (distanceTolerance) {\n\t\tif (distanceTolerance <= 0.0) throw new IllegalArgumentException(\"Tolerance must be positive\");\n\t\tthis.distanceTolerance = distanceTolerance;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Densifier;\n\t}\n});\nDensifier.densifyPoints = function (pts, distanceTolerance, precModel) {\n\tvar seg = new LineSegment();\n\tvar coordList = new CoordinateList();\n\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\tseg.p0 = pts[i];\n\t\tseg.p1 = pts[i + 1];\n\t\tcoordList.add(seg.p0, false);\n\t\tvar len = seg.getLength();\n\t\tvar densifiedSegCount = Math.trunc(len / distanceTolerance) + 1;\n\t\tif (densifiedSegCount > 1) {\n\t\t\tvar densifiedSegLen = len / densifiedSegCount;\n\t\t\tfor (var j = 1; j < densifiedSegCount; j++) {\n\t\t\t\tvar segFract = j * densifiedSegLen / len;\n\t\t\t\tvar p = seg.pointAlong(segFract);\n\t\t\t\tprecModel.makePrecise(p);\n\t\t\t\tcoordList.add(p, false);\n\t\t\t}\n\t\t}\n\t}\n\tcoordList.add(pts[pts.length - 1], false);\n\treturn coordList.toCoordinateArray();\n};\nDensifier.densify = function (geom, distanceTolerance) {\n\tvar densifier = new Densifier(geom);\n\tdensifier.setDistanceTolerance(distanceTolerance);\n\treturn densifier.getResultGeometry();\n};\nfunction DensifyTransformer() {\n\tGeometryTransformer.apply(this);\n\tthis.distanceTolerance = null;\n\tlet distanceTolerance = arguments[0];\n\tthis.distanceTolerance = distanceTolerance;\n}\ninherits(DensifyTransformer, GeometryTransformer);\nextend(DensifyTransformer.prototype, {\n\ttransformMultiPolygon: function (geom, parent) {\n\t\tvar roughGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);\n\t\treturn this.createValidArea(roughGeom);\n\t},\n\ttransformPolygon: function (geom, parent) {\n\t\tvar roughGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);\n\t\tif (parent instanceof MultiPolygon) {\n\t\t\treturn roughGeom;\n\t\t}\n\t\treturn this.createValidArea(roughGeom);\n\t},\n\ttransformCoordinates: function (coords, parent) {\n\t\tvar inputPts = coords.toCoordinateArray();\n\t\tvar newPts = Densifier.densifyPoints(inputPts, this.distanceTolerance, parent.getPrecisionModel());\n\t\tif (parent instanceof LineString && newPts.length === 1) {\n\t\t\tnewPts = new Array(0).fill(null);\n\t\t}\n\t\treturn this.factory.getCoordinateSequenceFactory().create(newPts);\n\t},\n\tcreateValidArea: function (roughAreaGeom) {\n\t\treturn roughAreaGeom.buffer(0.0);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DensifyTransformer;\n\t}\n});\nDensifier.DensifyTransformer = DensifyTransformer;\n","import CGAlgorithms from '../algorithm/CGAlgorithms';\nimport extend from '../../../../extend';\nimport Quadrant from '../geomgraph/Quadrant';\nimport Assert from '../util/Assert';\nexport default function HalfEdge() {\n\tthis._orig = null;\n\tthis._sym = null;\n\tthis._next = null;\n\tlet orig = arguments[0];\n\tthis._orig = orig;\n}\nextend(HalfEdge.prototype, {\n\tfind: function (dest) {\n\t\tvar oNext = this;\n\t\tdo {\n\t\t\tif (oNext === null) return null;\n\t\t\tif (oNext.dest().equals2D(dest)) return oNext;\n\t\t\toNext = oNext.oNext();\n\t\t} while (oNext !== this);\n\t\treturn null;\n\t},\n\tdest: function () {\n\t\treturn this._sym._orig;\n\t},\n\toNext: function () {\n\t\treturn this._sym._next;\n\t},\n\tinsert: function (e) {\n\t\tif (this.oNext() === this) {\n\t\t\tthis.insertAfter(e);\n\t\t\treturn null;\n\t\t}\n\t\tvar ecmp = this.compareTo(e);\n\t\tvar ePrev = this;\n\t\tdo {\n\t\t\tvar oNext = ePrev.oNext();\n\t\t\tvar cmp = oNext.compareTo(e);\n\t\t\tif (cmp !== ecmp || oNext === this) {\n\t\t\t\tePrev.insertAfter(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tePrev = oNext;\n\t\t} while (ePrev !== this);\n\t\tAssert.shouldNeverReachHere();\n\t},\n\tinsertAfter: function (e) {\n\t\tAssert.equals(this._orig, e.orig());\n\t\tvar save = this.oNext();\n\t\tthis._sym.setNext(e);\n\t\te.sym().setNext(save);\n\t},\n\tdegree: function () {\n\t\tvar degree = 0;\n\t\tvar e = this;\n\t\tdo {\n\t\t\tdegree++;\n\t\t\te = e.oNext();\n\t\t} while (e !== this);\n\t\treturn degree;\n\t},\n\tequals: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\t\treturn this._orig.equals2D(p0) && this._sym._orig.equals(p1);\n\t\t}\n\t},\n\tdeltaY: function () {\n\t\treturn this._sym._orig.y - this._orig.y;\n\t},\n\tsym: function () {\n\t\treturn this._sym;\n\t},\n\tprev: function () {\n\t\treturn this._sym.next()._sym;\n\t},\n\tcompareAngularDirection: function (e) {\n\t\tvar dx = this.deltaX();\n\t\tvar dy = this.deltaY();\n\t\tvar dx2 = e.deltaX();\n\t\tvar dy2 = e.deltaY();\n\t\tif (dx === dx2 && dy === dy2) return 0;\n\t\tvar quadrant = Quadrant.quadrant(dx, dy);\n\t\tvar quadrant2 = Quadrant.quadrant(dx2, dy2);\n\t\tif (quadrant > quadrant2) return 1;\n\t\tif (quadrant < quadrant2) return -1;\n\t\treturn CGAlgorithms.computeOrientation(e._orig, e.dest(), this.dest());\n\t},\n\tprevNode: function () {\n\t\tvar e = this;\n\t\twhile (e.degree() === 2) {\n\t\t\te = e.prev();\n\t\t\tif (e === this) return null;\n\t\t}\n\t\treturn e;\n\t},\n\tcompareTo: function (obj) {\n\t\tvar e = obj;\n\t\tvar comp = this.compareAngularDirection(e);\n\t\treturn comp;\n\t},\n\tnext: function () {\n\t\treturn this._next;\n\t},\n\tsetSym: function (e) {\n\t\tthis._sym = e;\n\t},\n\torig: function () {\n\t\treturn this._orig;\n\t},\n\ttoString: function () {\n\t\treturn \"HE(\" + this._orig.x + \" \" + this._orig.y + \", \" + this._sym._orig.x + \" \" + this._sym._orig.y + \")\";\n\t},\n\tsetNext: function (e) {\n\t\tthis._next = e;\n\t},\n\tinit: function (e) {\n\t\tthis.setSym(e);\n\t\te.setSym(this);\n\t\tthis.setNext(e);\n\t\te.setNext(this);\n\t},\n\tdeltaX: function () {\n\t\treturn this._sym._orig.x - this._orig.x;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn HalfEdge;\n\t}\n});\nHalfEdge.init = function (e0, e1) {\n\tif (e0._sym !== null || e1._sym !== null || e0._next !== null || e1._next !== null) throw new IllegalStateException(\"Edges are already initialized\");\n\te0.init(e1);\n\treturn e0;\n};\nHalfEdge.create = function (p0, p1) {\n\tvar e0 = new HalfEdge(p0);\n\tvar e1 = new HalfEdge(p1);\n\te0.init(e1);\n\treturn e0;\n};\n","import extend from '../../../../extend';\nimport HalfEdge from './HalfEdge';\nimport inherits from '../../../../inherits';\nexport default function MarkHalfEdge() {\n\tthis._isMarked = false;\n\tlet orig = arguments[0];\n\tHalfEdge.call(this, orig);\n}\ninherits(MarkHalfEdge, HalfEdge);\nextend(MarkHalfEdge.prototype, {\n\tmark: function () {\n\t\tthis._isMarked = true;\n\t},\n\tsetMark: function (isMarked) {\n\t\tthis._isMarked = isMarked;\n\t},\n\tisMarked: function () {\n\t\treturn this._isMarked;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MarkHalfEdge;\n\t}\n});\nMarkHalfEdge.setMarkBoth = function (e, isMarked) {\n\te.setMark(isMarked);\n\te.sym().setMark(isMarked);\n};\nMarkHalfEdge.isMarked = function (e) {\n\treturn e.isMarked();\n};\nMarkHalfEdge.setMark = function (e, isMarked) {\n\te.setMark(isMarked);\n};\nMarkHalfEdge.markBoth = function (e) {\n\te.mark();\n\te.sym().mark();\n};\nMarkHalfEdge.mark = function (e) {\n\te.mark();\n};\n","import HashMap from '../../../../java/util/HashMap';\nimport extend from '../../../../extend';\nimport HalfEdge from './HalfEdge';\nexport default function EdgeGraph() {\n\tthis.vertexMap = new HashMap();\n}\nextend(EdgeGraph.prototype, {\n\tinsert: function (orig, dest, eAdj) {\n\t\tvar e = this.create(orig, dest);\n\t\tif (eAdj !== null) {\n\t\t\teAdj.insert(e);\n\t\t} else {\n\t\t\tthis.vertexMap.put(orig, e);\n\t\t}\n\t\tvar eAdjDest = this.vertexMap.get(dest);\n\t\tif (eAdjDest !== null) {\n\t\t\teAdjDest.insert(e.sym());\n\t\t} else {\n\t\t\tthis.vertexMap.put(dest, e.sym());\n\t\t}\n\t\treturn e;\n\t},\n\tcreate: function (p0, p1) {\n\t\tvar e0 = this.createEdge(p0);\n\t\tvar e1 = this.createEdge(p1);\n\t\tHalfEdge.init(e0, e1);\n\t\treturn e0;\n\t},\n\tcreateEdge: function (orig) {\n\t\treturn new HalfEdge(orig);\n\t},\n\taddEdge: function (orig, dest) {\n\t\tif (!EdgeGraph.isValidEdge(orig, dest)) return null;\n\t\tvar eAdj = this.vertexMap.get(orig);\n\t\tvar eSame = null;\n\t\tif (eAdj !== null) {\n\t\t\teSame = eAdj.find(dest);\n\t\t}\n\t\tif (eSame !== null) {\n\t\t\treturn eSame;\n\t\t}\n\t\tvar e = this.insert(orig, dest, eAdj);\n\t\treturn e;\n\t},\n\tgetVertexEdges: function () {\n\t\treturn this.vertexMap.values();\n\t},\n\tfindEdge: function (orig, dest) {\n\t\tvar e = this.vertexMap.get(orig);\n\t\tif (e === null) return null;\n\t\treturn e.find(dest);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeGraph;\n\t}\n});\nEdgeGraph.isValidEdge = function (orig, dest) {\n\tvar cmp = dest.compareTo(orig);\n\treturn cmp !== 0;\n};\n","import extend from '../../../../extend';\nimport MarkHalfEdge from '../edgegraph/MarkHalfEdge';\nimport inherits from '../../../../inherits';\nexport default function DissolveHalfEdge() {\n\tthis._isStart = false;\n\tlet orig = arguments[0];\n\tMarkHalfEdge.call(this, orig);\n}\ninherits(DissolveHalfEdge, MarkHalfEdge);\nextend(DissolveHalfEdge.prototype, {\n\tsetStart: function () {\n\t\tthis._isStart = true;\n\t},\n\tisStart: function () {\n\t\treturn this._isStart;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DissolveHalfEdge;\n\t}\n});\n","import EdgeGraph from '../edgegraph/EdgeGraph';\nimport extend from '../../../../extend';\nimport DissolveHalfEdge from './DissolveHalfEdge';\nimport inherits from '../../../../inherits';\nexport default function DissolveEdgeGraph() {\n\tEdgeGraph.apply(this);\n}\ninherits(DissolveEdgeGraph, EdgeGraph);\nextend(DissolveEdgeGraph.prototype, {\n\tcreateEdge: function (p0) {\n\t\treturn new DissolveHalfEdge(p0);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DissolveEdgeGraph;\n\t}\n});\n","import LineString from '../geom/LineString';\nimport CoordinateList from '../geom/CoordinateList';\nimport Geometry from '../geom/Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport Collection from '../../../../java/util/Collection';\nimport Stack from '../../../../java/util/Stack';\nimport extend from '../../../../extend';\nimport MarkHalfEdge from '../edgegraph/MarkHalfEdge';\nimport DissolveEdgeGraph from './DissolveEdgeGraph';\nimport GeometryComponentFilter from '../geom/GeometryComponentFilter';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function LineDissolver() {\n\tthis.result = null;\n\tthis.factory = null;\n\tthis.graph = null;\n\tthis.lines = new ArrayList();\n\tthis.nodeEdgeStack = new Stack();\n\tthis.ringStartEdge = null;\n\tthis.graph = new DissolveEdgeGraph();\n}\nextend(LineDissolver.prototype, {\n\taddLine: function (line) {\n\t\tthis.lines.add(this.factory.createLineString(line.toCoordinateArray()));\n\t},\n\tupdateRingStartEdge: function (e) {\n\t\tif (!e.isStart()) {\n\t\t\te = e.sym();\n\t\t\tif (!e.isStart()) return null;\n\t\t}\n\t\tif (this.ringStartEdge === null) {\n\t\t\tthis.ringStartEdge = e;\n\t\t\treturn null;\n\t\t}\n\t\tif (e.orig().compareTo(this.ringStartEdge.orig()) < 0) {\n\t\t\tthis.ringStartEdge = e;\n\t\t}\n\t},\n\tgetResult: function () {\n\t\tif (this.result === null) this.computeResult();\n\t\treturn this.result;\n\t},\n\tprocess: function (e) {\n\t\tvar eNode = e.prevNode();\n\t\tif (eNode === null) eNode = e;\n\t\tthis.stackEdges(eNode);\n\t\tthis.buildLines();\n\t},\n\tbuildRing: function (eStartRing) {\n\t\tvar line = new CoordinateList();\n\t\tvar e = eStartRing;\n\t\tline.add(e.orig().copy(), false);\n\t\twhile (e.sym().degree() === 2) {\n\t\t\tvar eNext = e.next();\n\t\t\tif (eNext === eStartRing) break;\n\t\t\tline.add(eNext.orig().copy(), false);\n\t\t\te = eNext;\n\t\t}\n\t\tline.add(e.dest().copy(), false);\n\t\tthis.addLine(line);\n\t},\n\tbuildLine: function (eStart) {\n\t\tvar line = new CoordinateList();\n\t\tvar e = eStart;\n\t\tthis.ringStartEdge = null;\n\t\tMarkHalfEdge.markBoth(e);\n\t\tline.add(e.orig().copy(), false);\n\t\twhile (e.sym().degree() === 2) {\n\t\t\tthis.updateRingStartEdge(e);\n\t\t\tvar eNext = e.next();\n\t\t\tif (eNext === eStart) {\n\t\t\t\tthis.buildRing(this.ringStartEdge);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tline.add(eNext.orig().copy(), false);\n\t\t\te = eNext;\n\t\t\tMarkHalfEdge.markBoth(e);\n\t\t}\n\t\tline.add(e.dest().copy(), false);\n\t\tthis.stackEdges(e.sym());\n\t\tthis.addLine(line);\n\t},\n\tstackEdges: function (node) {\n\t\tvar e = node;\n\t\tdo {\n\t\t\tif (!MarkHalfEdge.isMarked(e)) this.nodeEdgeStack.add(e);\n\t\t\te = e.oNext();\n\t\t} while (e !== node);\n\t},\n\tcomputeResult: function () {\n\t\tvar edges = this.graph.getVertexEdges();\n\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tif (MarkHalfEdge.isMarked(e)) continue;\n\t\t\tthis.process(e);\n\t\t}\n\t\tthis.result = this.factory.buildGeometry(this.lines);\n\t},\n\tbuildLines: function () {\n\t\twhile (!this.nodeEdgeStack.empty()) {\n\t\t\tvar e = this.nodeEdgeStack.pop();\n\t\t\tif (MarkHalfEdge.isMarked(e)) continue;\n\t\t\tthis.buildLine(e);\n\t\t}\n\t},\n\tadd: function () {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet geometry = arguments[0];\n\t\t\tgeometry.apply({\n\t\t\t\tinterfaces_: function () {\n\t\t\t\t\treturn [GeometryComponentFilter];\n\t\t\t\t},\n\t\t\t\tfilter: function (component) {\n\t\t\t\t\tif (component instanceof LineString) {\n\t\t\t\t\t\tthis.add(component);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (hasInterface(arguments[0], Collection)) {\n\t\t\tlet geometries = arguments[0];\n\t\t\tfor (var i = geometries.iterator(); i.hasNext(); ) {\n\t\t\t\tvar geometry = i.next();\n\t\t\t\tthis.add(geometry);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof LineString) {\n\t\t\tlet lineString = arguments[0];\n\t\t\tif (this.factory === null) {\n\t\t\t\tthis.factory = lineString.getFactory();\n\t\t\t}\n\t\t\tvar seq = lineString.getCoordinateSequence();\n\t\t\tvar doneStart = false;\n\t\t\tfor (var i = 1; i < seq.size(); i++) {\n\t\t\t\tvar e = this.graph.addEdge(seq.getCoordinate(i - 1), seq.getCoordinate(i));\n\t\t\t\tif (e === null) continue;\n\t\t\t\tif (!doneStart) {\n\t\t\t\t\te.setStart();\n\t\t\t\t\tdoneStart = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineDissolver;\n\t}\n});\nLineDissolver.dissolve = function (g) {\n\tvar d = new LineDissolver();\n\td.add(g);\n\treturn d.getResult();\n};\n","import extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Serializable from '../../../../../java/io/Serializable';\nexport default function NodeBase() {\n\tthis.items = new ArrayList();\n\tthis.subnode = new Array(4).fill(null);\n}\nextend(NodeBase.prototype, {\n\thasChildren: function () {\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this.subnode[i] !== null) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tisPrunable: function () {\n\t\treturn !(this.hasChildren() || this.hasItems());\n\t},\n\taddAllItems: function (resultItems) {\n\t\tresultItems.addAll(this.items);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tthis.subnode[i].addAllItems(resultItems);\n\t\t\t}\n\t\t}\n\t\treturn resultItems;\n\t},\n\tgetNodeCount: function () {\n\t\tvar subSize = 0;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tsubSize += this.subnode[i].size();\n\t\t\t}\n\t\t}\n\t\treturn subSize + 1;\n\t},\n\tsize: function () {\n\t\tvar subSize = 0;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tsubSize += this.subnode[i].size();\n\t\t\t}\n\t\t}\n\t\treturn subSize + this.items.size();\n\t},\n\taddAllItemsFromOverlapping: function (searchEnv, resultItems) {\n\t\tif (!this.isSearchMatch(searchEnv)) return null;\n\t\tresultItems.addAll(this.items);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tthis.subnode[i].addAllItemsFromOverlapping(searchEnv, resultItems);\n\t\t\t}\n\t\t}\n\t},\n\tvisitItems: function (searchEnv, visitor) {\n\t\tfor (var i = this.items.iterator(); i.hasNext(); ) {\n\t\t\tvisitor.visitItem(i.next());\n\t\t}\n\t},\n\thasItems: function () {\n\t\treturn !this.items.isEmpty();\n\t},\n\tremove: function (itemEnv, item) {\n\t\tif (!this.isSearchMatch(itemEnv)) return false;\n\t\tvar found = false;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tfound = this.subnode[i].remove(itemEnv, item);\n\t\t\t\tif (found) {\n\t\t\t\t\tif (this.subnode[i].isPrunable()) this.subnode[i] = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (found) return found;\n\t\tfound = this.items.remove(item);\n\t\treturn found;\n\t},\n\tvisit: function (searchEnv, visitor) {\n\t\tif (!this.isSearchMatch(searchEnv)) return null;\n\t\tthis.visitItems(searchEnv, visitor);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tthis.subnode[i].visit(searchEnv, visitor);\n\t\t\t}\n\t\t}\n\t},\n\tgetItems: function () {\n\t\treturn this.items;\n\t},\n\tdepth: function () {\n\t\tvar maxSubDepth = 0;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tvar sqd = this.subnode[i].depth();\n\t\t\t\tif (sqd > maxSubDepth) maxSubDepth = sqd;\n\t\t\t}\n\t\t}\n\t\treturn maxSubDepth + 1;\n\t},\n\tisEmpty: function () {\n\t\tvar isEmpty = true;\n\t\tif (!this.items.isEmpty()) isEmpty = false;\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tif (this.subnode[i] !== null) {\n\t\t\t\tif (!this.subnode[i].isEmpty()) isEmpty = false;\n\t\t\t}\n\t\t}\n\t\treturn isEmpty;\n\t},\n\tadd: function (item) {\n\t\tthis.items.add(item);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn NodeBase;\n\t}\n});\nNodeBase.getSubnodeIndex = function (env, centrex, centrey) {\n\tvar subnodeIndex = -1;\n\tif (env.getMinX() >= centrex) {\n\t\tif (env.getMinY() >= centrey) subnodeIndex = 3;\n\t\tif (env.getMaxY() <= centrey) subnodeIndex = 1;\n\t}\n\tif (env.getMaxX() <= centrex) {\n\t\tif (env.getMinY() >= centrey) subnodeIndex = 2;\n\t\tif (env.getMaxY() <= centrey) subnodeIndex = 0;\n\t}\n\treturn subnodeIndex;\n};\n","import Coordinate from '../../geom/Coordinate';\nimport extend from '../../../../../extend';\nimport DoubleBits from './DoubleBits';\nimport Envelope from '../../geom/Envelope';\nexport default function Key() {\n\tthis.pt = new Coordinate();\n\tthis.level = 0;\n\tthis.env = null;\n\tlet itemEnv = arguments[0];\n\tthis.computeKey(itemEnv);\n}\nextend(Key.prototype, {\n\tgetLevel: function () {\n\t\treturn this.level;\n\t},\n\tcomputeKey: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet itemEnv = arguments[0];\n\t\t\tthis.level = Key.computeQuadLevel(itemEnv);\n\t\t\tthis.env = new Envelope();\n\t\t\tthis.computeKey(this.level, itemEnv);\n\t\t\twhile (!this.env.contains(itemEnv)) {\n\t\t\t\tthis.level += 1;\n\t\t\t\tthis.computeKey(this.level, itemEnv);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet level = arguments[0], itemEnv = arguments[1];\n\t\t\tvar quadSize = DoubleBits.powerOf2(level);\n\t\t\tthis.pt.x = Math.floor(itemEnv.getMinX() / quadSize) * quadSize;\n\t\t\tthis.pt.y = Math.floor(itemEnv.getMinY() / quadSize) * quadSize;\n\t\t\tthis.env.init(this.pt.x, this.pt.x + quadSize, this.pt.y, this.pt.y + quadSize);\n\t\t}\n\t},\n\tgetEnvelope: function () {\n\t\treturn this.env;\n\t},\n\tgetCentre: function () {\n\t\treturn new Coordinate((this.env.getMinX() + this.env.getMaxX()) / 2, (this.env.getMinY() + this.env.getMaxY()) / 2);\n\t},\n\tgetPoint: function () {\n\t\treturn this.pt;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Key;\n\t}\n});\nKey.computeQuadLevel = function (env) {\n\tvar dx = env.getWidth();\n\tvar dy = env.getHeight();\n\tvar dMax = dx > dy ? dx : dy;\n\tvar level = DoubleBits.exponent(dMax) + 1;\n\treturn level;\n};\n","import NodeBase from './NodeBase';\nimport extend from '../../../../../extend';\nimport Envelope from '../../geom/Envelope';\nimport Assert from '../../util/Assert';\nimport inherits from '../../../../../inherits';\nimport Key from './Key';\nexport default function Node() {\n\tNodeBase.apply(this);\n\tthis.env = null;\n\tthis.centrex = null;\n\tthis.centrey = null;\n\tthis.level = null;\n\tlet env = arguments[0], level = arguments[1];\n\tthis.env = env;\n\tthis.level = level;\n\tthis.centrex = (env.getMinX() + env.getMaxX()) / 2;\n\tthis.centrey = (env.getMinY() + env.getMaxY()) / 2;\n}\ninherits(Node, NodeBase);\nextend(Node.prototype, {\n\tfind: function (searchEnv) {\n\t\tvar subnodeIndex = NodeBase.getSubnodeIndex(searchEnv, this.centrex, this.centrey);\n\t\tif (subnodeIndex === -1) return this;\n\t\tif (this.subnode[subnodeIndex] !== null) {\n\t\t\tvar node = this.subnode[subnodeIndex];\n\t\t\treturn node.find(searchEnv);\n\t\t}\n\t\treturn this;\n\t},\n\tisSearchMatch: function (searchEnv) {\n\t\treturn this.env.intersects(searchEnv);\n\t},\n\tgetSubnode: function (index) {\n\t\tif (this.subnode[index] === null) {\n\t\t\tthis.subnode[index] = this.createSubnode(index);\n\t\t}\n\t\treturn this.subnode[index];\n\t},\n\tgetEnvelope: function () {\n\t\treturn this.env;\n\t},\n\tgetNode: function (searchEnv) {\n\t\tvar subnodeIndex = NodeBase.getSubnodeIndex(searchEnv, this.centrex, this.centrey);\n\t\tif (subnodeIndex !== -1) {\n\t\t\tvar node = this.getSubnode(subnodeIndex);\n\t\t\treturn node.getNode(searchEnv);\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t},\n\tcreateSubnode: function (index) {\n\t\tvar minx = 0.0;\n\t\tvar maxx = 0.0;\n\t\tvar miny = 0.0;\n\t\tvar maxy = 0.0;\n\t\tswitch (index) {\n\t\t\tcase 0:\n\t\t\t\tminx = this.env.getMinX();\n\t\t\t\tmaxx = this.centrex;\n\t\t\t\tminy = this.env.getMinY();\n\t\t\t\tmaxy = this.centrey;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tminx = this.centrex;\n\t\t\t\tmaxx = this.env.getMaxX();\n\t\t\t\tminy = this.env.getMinY();\n\t\t\t\tmaxy = this.centrey;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tminx = this.env.getMinX();\n\t\t\t\tmaxx = this.centrex;\n\t\t\t\tminy = this.centrey;\n\t\t\t\tmaxy = this.env.getMaxY();\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tminx = this.centrex;\n\t\t\t\tmaxx = this.env.getMaxX();\n\t\t\t\tminy = this.centrey;\n\t\t\t\tmaxy = this.env.getMaxY();\n\t\t\t\tbreak;\n\t\t}\n\t\tvar sqEnv = new Envelope(minx, maxx, miny, maxy);\n\t\tvar node = new Node(sqEnv, this.level - 1);\n\t\treturn node;\n\t},\n\tinsertNode: function (node) {\n\t\tAssert.isTrue(this.env === null || this.env.contains(node.env));\n\t\tvar index = NodeBase.getSubnodeIndex(node.env, this.centrex, this.centrey);\n\t\tif (node.level === this.level - 1) {\n\t\t\tthis.subnode[index] = node;\n\t\t} else {\n\t\t\tvar childNode = this.createSubnode(index);\n\t\t\tchildNode.insertNode(node);\n\t\t\tthis.subnode[index] = childNode;\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Node;\n\t}\n});\nNode.createNode = function (env) {\n\tvar key = new Key(env);\n\tvar node = new Node(key.getEnvelope(), key.getLevel());\n\treturn node;\n};\nNode.createExpanded = function (node, addEnv) {\n\tvar expandEnv = new Envelope(addEnv);\n\tif (node !== null) expandEnv.expandToInclude(node.env);\n\tvar largerNode = Node.createNode(expandEnv);\n\tif (node !== null) largerNode.insertNode(node);\n\treturn largerNode;\n};\n","import Coordinate from '../../geom/Coordinate';\nimport NodeBase from './NodeBase';\nimport Node from './Node';\nimport extend from '../../../../../extend';\nimport IntervalSize from './IntervalSize';\nimport Assert from '../../util/Assert';\nimport inherits from '../../../../../inherits';\nexport default function Root() {\n\tNodeBase.apply(this);\n}\ninherits(Root, NodeBase);\nextend(Root.prototype, {\n\tinsert: function (itemEnv, item) {\n\t\tvar index = NodeBase.getSubnodeIndex(itemEnv, Root.origin.x, Root.origin.y);\n\t\tif (index === -1) {\n\t\t\tthis.add(item);\n\t\t\treturn null;\n\t\t}\n\t\tvar node = this.subnode[index];\n\t\tif (node === null || !node.getEnvelope().contains(itemEnv)) {\n\t\t\tvar largerNode = Node.createExpanded(node, itemEnv);\n\t\t\tthis.subnode[index] = largerNode;\n\t\t}\n\t\tthis.insertContained(this.subnode[index], itemEnv, item);\n\t},\n\tisSearchMatch: function (searchEnv) {\n\t\treturn true;\n\t},\n\tinsertContained: function (tree, itemEnv, item) {\n\t\tAssert.isTrue(tree.getEnvelope().contains(itemEnv));\n\t\tvar isZeroX = IntervalSize.isZeroWidth(itemEnv.getMinX(), itemEnv.getMaxX());\n\t\tvar isZeroY = IntervalSize.isZeroWidth(itemEnv.getMinY(), itemEnv.getMaxY());\n\t\tvar node = null;\n\t\tif (isZeroX || isZeroY) node = tree.find(itemEnv); else node = tree.getNode(itemEnv);\n\t\tnode.add(item);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Root;\n\t}\n});\nRoot.origin = new Coordinate(0.0, 0.0);\n","import Root from './Root';\nimport SpatialIndex from '../SpatialIndex';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport ArrayListVisitor from '../ArrayListVisitor';\nimport Serializable from '../../../../../java/io/Serializable';\nimport Envelope from '../../geom/Envelope';\nexport default function Quadtree() {\n\tthis.root = null;\n\tthis.minExtent = 1.0;\n\tthis.root = new Root();\n}\nextend(Quadtree.prototype, {\n\tsize: function () {\n\t\tif (this.root !== null) return this.root.size();\n\t\treturn 0;\n\t},\n\tinsert: function (itemEnv, item) {\n\t\tthis.collectStats(itemEnv);\n\t\tvar insertEnv = Quadtree.ensureExtent(itemEnv, this.minExtent);\n\t\tthis.root.insert(insertEnv, item);\n\t},\n\tquery: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet searchEnv = arguments[0];\n\t\t\tvar visitor = new ArrayListVisitor();\n\t\t\tthis.query(searchEnv, visitor);\n\t\t\treturn visitor.getItems();\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet searchEnv = arguments[0], visitor = arguments[1];\n\t\t\tthis.root.visit(searchEnv, visitor);\n\t\t}\n\t},\n\tqueryAll: function () {\n\t\tvar foundItems = new ArrayList();\n\t\tthis.root.addAllItems(foundItems);\n\t\treturn foundItems;\n\t},\n\tremove: function (itemEnv, item) {\n\t\tvar posEnv = Quadtree.ensureExtent(itemEnv, this.minExtent);\n\t\treturn this.root.remove(posEnv, item);\n\t},\n\tcollectStats: function (itemEnv) {\n\t\tvar delX = itemEnv.getWidth();\n\t\tif (delX < this.minExtent && delX > 0.0) this.minExtent = delX;\n\t\tvar delY = itemEnv.getHeight();\n\t\tif (delY < this.minExtent && delY > 0.0) this.minExtent = delY;\n\t},\n\tdepth: function () {\n\t\tif (this.root !== null) return this.root.depth();\n\t\treturn 0;\n\t},\n\tisEmpty: function () {\n\t\tif (this.root === null) return true;\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [SpatialIndex, Serializable];\n\t},\n\tgetClass: function () {\n\t\treturn Quadtree;\n\t}\n});\nQuadtree.ensureExtent = function (itemEnv, minExtent) {\n\tvar minx = itemEnv.getMinX();\n\tvar maxx = itemEnv.getMaxX();\n\tvar miny = itemEnv.getMinY();\n\tvar maxy = itemEnv.getMaxY();\n\tif (minx !== maxx && miny !== maxy) return itemEnv;\n\tif (minx === maxx) {\n\t\tminx = minx - minExtent / 2.0;\n\t\tmaxx = minx + minExtent / 2.0;\n\t}\n\tif (miny === maxy) {\n\t\tminy = miny - minExtent / 2.0;\n\t\tmaxy = miny + minExtent / 2.0;\n\t}\n\treturn new Envelope(minx, maxx, miny, maxy);\n};\nQuadtree.serialVersionUID = -7461163625812743604;\n","import Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\nimport extend from '../../../../extend'\n\nconst geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon']\n\n/**\n * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/**\n * Create a new parser for GeoJSON\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of GeoJsonParser.\n * @constructor\n * @private\n */\nexport default function GeoJSONParser (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory()\n}\n\nextend(GeoJSONParser.prototype, {\n  /**\n   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n   *\n   * @param {}\n   *          A GeoJSON object.\n   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n   * @private\n   */\n  read (json) {\n    let obj\n    if (typeof json === 'string') {\n      obj = JSON.parse(json)\n    } else {\n      obj = json\n    }\n\n    const type = obj.type\n\n    if (!parse[type]) {\n      throw new Error('Unknown GeoJSON type: ' + obj.type)\n    }\n\n    if (geometryTypes.indexOf(type) !== -1) {\n      return parse[type].apply(this, [obj.coordinates])\n    } else if (type === 'GeometryCollection') {\n      return parse[type].apply(this, [obj.geometries])\n    }\n\n    // feature or feature collection\n    return parse[type].apply(this, [obj])\n  },\n\n  /**\n   * Serialize a Geometry object into GeoJSON\n   *\n   * @param {Geometry}\n   *          geometry A Geometry or array of Geometries.\n   * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n   * @private\n   */\n  write (geometry) {\n    const type = geometry.getGeometryType()\n\n    if (!extract[type]) {\n      throw new Error('Geometry is not supported')\n    }\n\n    return extract[type].apply(this, [geometry])\n  }\n})\n\nconst parse = {\n  /**\n   * Parse a GeoJSON Feature object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n   */\n  Feature: function (obj) {\n    const feature = {}\n\n    // copy features\n    for (let key in obj) {\n      feature[key] = obj[key]\n    }\n\n    // parse geometry\n    if (obj.geometry) {\n      const type = obj.geometry.type\n      if (!parse[type]) {\n        throw new Error('Unknown GeoJSON type: ' + obj.type)\n      }\n      feature.geometry = this.read(obj.geometry)\n    }\n\n    // bbox\n    if (obj.bbox) {\n      feature.bbox = parse.bbox.apply(this, [obj.bbox])\n    }\n\n    return feature\n  },\n\n  /**\n   * Parse a GeoJSON FeatureCollection object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n   */\n  FeatureCollection: function (obj) {\n    const featureCollection = {}\n\n    if (obj.features) {\n      featureCollection.features = []\n\n      for (let i = 0; i < obj.features.length; ++i) {\n        featureCollection.features.push(this.read(obj.features[i]))\n      }\n    }\n\n    if (obj.bbox) {\n      featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox])\n    }\n\n    return featureCollection\n  },\n\n  /**\n   * Convert the ordinates in an array to an array of Coordinates\n   *\n   * @param {Array}\n   *          array Array with {Number}s.\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  coordinates: function (array) {\n    const coordinates = []\n    for (let i = 0; i < array.length; ++i) {\n      const sub = array[i]\n      coordinates.push(new Coordinate(sub[0], sub[1]))\n    }\n    return coordinates\n  },\n\n  /**\n   * Convert the bbox to a LinearRing\n   *\n   * @param {Array}\n   *          array Array with [xMin, yMin, xMax, yMax].\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  bbox: function (array) {\n    return this.geometryFactory.createLinearRing([\n      new Coordinate(array[0], array[1]),\n      new Coordinate(array[2], array[1]),\n      new Coordinate(array[2], array[3]),\n      new Coordinate(array[0], array[3]),\n      new Coordinate(array[0], array[1])\n    ])\n  },\n\n  /**\n   * Convert an Array with ordinates to a Point\n   *\n   * @param {Array}\n   *          array Array with ordinates.\n   *\n   * @return {Point} Point.\n   */\n  Point: function (array) {\n    const coordinate = new Coordinate(array[0], array[1])\n    return this.geometryFactory.createPoint(coordinate)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiPoint\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiPoint} MultiPoint.\n   */\n  MultiPoint: function (array) {\n    const points = []\n    for (let i = 0; i < array.length; ++i) {\n      points.push(parse.Point.apply(this, [array[i]]))\n    }\n    return this.geometryFactory.createMultiPoint(points)\n  },\n\n  /**\n   * Convert an Array with coordinates to a LineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {LineString} LineString.\n   */\n  LineString: function (array) {\n    const coordinates = parse.coordinates.apply(this, [array])\n    return this.geometryFactory.createLineString(coordinates)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiLineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiLineString} MultiLineString.\n   */\n  MultiLineString: function (array) {\n    const lineStrings = []\n    for (let i = 0; i < array.length; ++i) {\n      lineStrings.push(parse.LineString.apply(this, [array[i]]))\n    }\n    return this.geometryFactory.createMultiLineString(lineStrings)\n  },\n\n  /**\n   * Convert an Array to a Polygon\n   *\n   * @param {Array}\n   *          array Array with shell and holes.\n   *\n   * @return {Polygon} Polygon.\n   */\n  Polygon: function (array) {\n    const shellCoordinates = parse.coordinates.apply(this, [array[0]])\n    const shell = this.geometryFactory.createLinearRing(shellCoordinates)\n    const holes = []\n    for (let i = 1; i < array.length; ++i) {\n      var hole = array[i]\n      var coordinates = parse.coordinates.apply(this, [hole])\n      var linearRing = this.geometryFactory.createLinearRing(coordinates)\n      holes.push(linearRing)\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Convert an Array to a MultiPolygon\n   *\n   * @param {Array}\n   *          array Array of arrays with shell and rings.\n   *\n   * @return {MultiPolygon} MultiPolygon.\n   */\n  MultiPolygon: function (array) {\n    const polygons = []\n    for (let i = 0; i < array.length; ++i) {\n      const polygon = array[i]\n      polygons.push(parse.Polygon.apply(this, [polygon]))\n    }\n    return this.geometryFactory.createMultiPolygon(polygons)\n  },\n\n  /**\n   * Convert an Array to a GeometryCollection\n   *\n   * @param {Array}\n   *          array Array of GeoJSON geometries.\n   *\n   * @return {GeometryCollection} GeometryCollection.\n   */\n  GeometryCollection: function (array) {\n    const geometries = []\n    for (let i = 0; i < array.length; ++i) {\n      const geometry = array[i]\n      geometries.push(this.read(geometry))\n    }\n    return this.geometryFactory.createGeometryCollection(geometries)\n  }\n}\n\nconst extract = {\n  /**\n   * Convert a Coordinate to an Array\n   *\n   * @param {Coordinate}\n   *          coordinate Coordinate to convert.\n   *\n   * @return {Array} Array of ordinates.\n   */\n  coordinate: function (coordinate) {\n    return [coordinate.x, coordinate.y]\n  },\n\n  /**\n   * Convert a Point to a GeoJSON object\n   *\n   * @param {Point}\n   *          point Point to convert.\n   *\n   * @return {Array} Array of 2 ordinates (paired to a coordinate).\n   */\n  Point: function (point) {\n    const array = extract.coordinate.apply(this, [point.getCoordinate()])\n    return {\n      type: 'Point',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPoint to a GeoJSON object\n   *\n   * @param {MultiPoint}\n   *          multipoint MultiPoint to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  MultiPoint: function (multipoint) {\n    const array = []\n    for (let i = 0; i < multipoint.geometries.length; ++i) {\n      const point = multipoint.geometries[i]\n      const geoJson = extract.Point.apply(this, [point])\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiPoint',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a LineString to a GeoJSON object\n   *\n   * @param {LineString}\n   *          linestring LineString to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  LineString: function (linestring) {\n    const array = []\n    const coordinates = linestring.getCoordinates()\n    for (let i = 0; i < coordinates.length; ++i) {\n      const coordinate = coordinates[i]\n      array.push(extract.coordinate.apply(this, [coordinate]))\n    }\n    return {\n      type: 'LineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiLineString to a GeoJSON object\n   *\n   * @param {MultiLineString}\n   *          multilinestring MultiLineString to convert.\n   *\n   * @return {Array} Array of Array of coordinates.\n   */\n  MultiLineString: function (multilinestring) {\n    const array = []\n    for (let i = 0; i < multilinestring.geometries.length; ++i) {\n      const linestring = multilinestring.geometries[i]\n      const geoJson = extract.LineString.apply(this, [linestring])\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiLineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a Polygon to a GeoJSON object\n   *\n   * @param {Polygon}\n   *          polygon Polygon to convert.\n   *\n   * @return {Array} Array with shell, holes.\n   */\n  Polygon: function (polygon) {\n    const array = []\n    const shellGeoJson = extract.LineString.apply(this, [polygon.shell])\n    array.push(shellGeoJson.coordinates)\n    for (let i = 0; i < polygon.holes.length; ++i) {\n      const hole = polygon.holes[i]\n      const holeGeoJson = extract.LineString.apply(this, [hole])\n      array.push(holeGeoJson.coordinates)\n    }\n    return {\n      type: 'Polygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPolygon to a GeoJSON object\n   *\n   * @param {MultiPolygon}\n   *          multipolygon MultiPolygon to convert.\n   *\n   * @return {Array} Array of polygons.\n   */\n  MultiPolygon: function (multipolygon) {\n    const array = []\n    for (let i = 0; i < multipolygon.geometries.length; ++i) {\n      const polygon = multipolygon.geometries[i]\n      const geoJson = extract.Polygon.apply(this, [polygon])\n      array.push(geoJson.coordinates)\n    }\n    return {\n      type: 'MultiPolygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a GeometryCollection to a GeoJSON object\n   *\n   * @param {GeometryCollection}\n   *          collection GeometryCollection to convert.\n   *\n   * @return {Array} Array of geometries.\n   */\n  GeometryCollection: function (collection) {\n    const array = []\n    for (let i = 0; i < collection.geometries.length; ++i) {\n      const geometry = collection.geometries[i]\n      const type = geometry.getGeometryType()\n      array.push(extract[type].apply(this, [geometry]))\n    }\n    return {\n      type: 'GeometryCollection',\n      geometries: array\n    }\n  }\n}\n","import GeometryFactory from '../geom/GeometryFactory'\nimport PrecisionModel from '../geom/PrecisionModel'\nimport GeoJSONParser from './GeoJSONParser'\nimport extend from '../../../../extend'\n\n/**\n * Converts a geometry in GeoJSON to a {@link Geometry}.\n */\n\n/**\n * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n * to allow it to create <code>Geometry</code> objects of the appropriate\n * implementation. In particular, the <code>GeometryFactory</code> determines\n * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nexport default function GeoJSONReader (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory()\n  this.precisionModel = this.geometryFactory.getPrecisionModel()\n  this.parser = new GeoJSONParser(this.geometryFactory)\n}\n\nextend(GeoJSONReader.prototype, {\n  /**\n   * Reads a GeoJSON representation of a {@link Geometry}\n   *\n   * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n   *\n   * @param {Object|String} geoJson a GeoJSON Object or String.\n   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n   * @memberof GeoJSONReader\n   */\n  read (geoJson) {\n    var geometry = this.parser.read(geoJson)\n\n    if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n      this.reducePrecision(geometry)\n    }\n\n    return geometry\n  },\n\n  // NOTE: this is a hack\n  reducePrecision (geometry) {\n    var i, len\n\n    if (geometry.coordinate) {\n      this.precisionModel.makePrecise(geometry.coordinate)\n    } else if (geometry.points) {\n      for (i = 0, len = geometry.points.length; i < len; i++) {\n        this.precisionModel.makePrecise(geometry.points[i])\n      }\n    } else if (geometry.geometries) {\n      for (i = 0, len = geometry.geometries.length; i < len; i++) {\n        this.reducePrecision(geometry.geometries[i])\n      }\n    }\n  }\n})\n","/**\n * @module GeoJSONWriter\n */\n\nimport GeoJSONParser from './GeoJSONParser'\nimport extend from '../../../../extend'\n\n/**\n * Writes the GeoJSON representation of a {@link Geometry}. The\n * The GeoJSON format is defined <A\n * HREF=\"http://geojson.org/geojson-spec.html\">here</A>.\n */\n\n/**\n * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nexport default function GeoJSONWriter () {\n  this.parser = new GeoJSONParser(this.geometryFactory)\n}\n\nextend(GeoJSONWriter.prototype, {\n  /**\n   * Converts a <code>Geometry</code> to its GeoJSON representation.\n   *\n   * @param {Geometry}\n   *          geometry a <code>Geometry</code> to process.\n   * @return {Object} The GeoJSON representation of the Geometry.\n   * @memberof GeoJSONWriter\n   */\n  write (geometry) {\n    return this.parser.write(geometry)\n  }\n})\n","import GeometryFactory from '../geom/GeometryFactory'\nimport PrecisionModel from '../geom/PrecisionModel'\nimport WKTParser from './WKTParser'\nimport extend from '../../../../extend'\n\n/**\n * Converts a geometry in Well-Known Text format to a {@link Geometry}.\n * <p>\n * <code>WKTReader</code> supports extracting <code>Geometry</code> objects\n * from either {@link Reader}s or {@link String}s. This allows it to function\n * as a parser to read <code>Geometry</code> objects from text blocks embedded\n * in other data formats (e.g. XML).\n */\n\n/**\n * A <code>WKTReader</code> is parameterized by a <code>GeometryFactory</code>,\n * to allow it to create <code>Geometry</code> objects of the appropriate\n * implementation. In particular, the <code>GeometryFactory</code> determines\n * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nexport default function WKTReader (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory()\n  this.precisionModel = this.geometryFactory.getPrecisionModel()\n  this.parser = new WKTParser(this.geometryFactory)\n}\n\nextend(WKTReader.prototype, {\n  /**\n   * Reads a Well-Known Text representation of a {@link Geometry}\n   *\n   * @param {string}\n   *          wkt a <Geometry Tagged Text> string (see the OpenGIS Simple Features\n   *          Specification).\n   * @return {Geometry} a <code>Geometry</code> read from\n   *         <code>string.</code>\n   * @memberof WKTReader\n   */\n  read (wkt) {\n    var geometry = this.parser.read(wkt)\n\n    // TODO: port and use GeometryPrecisionReducer, this is a hack\n    if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n      this.reducePrecision(geometry)\n    }\n\n    return geometry\n  },\n\n  reducePrecision (geometry) {\n    if (geometry.coordinate) {\n      this.precisionModel.makePrecise(geometry.coordinate)\n    } else if (geometry.points) {\n      for (let i = 0, len = geometry.points.coordinates.length; i < len; i++) {\n        this.precisionModel.makePrecise(geometry.points.coordinates[i])\n      }\n    } else if (geometry.geometries) {\n      for (let i = 0, len = geometry.geometries.length; i < len; i++) {\n        this.reducePrecision(geometry.geometries[i])\n      }\n    }\n  }\n})\n","/*eslint-disable no-undef */\n\nimport Coordinate from '../geom/Coordinate'\nimport GeometryFactory from '../geom/GeometryFactory'\nimport extend from '../../../../extend'\n\nfunction p2c (p) { return [p.x, p.y] }\n\n/**\n * OpenLayers 3 Geometry parser and writer\n * @param {GeometryFactory} geometryFactory\n * @param {ol} olReference\n * @constructor\n */\nexport default function OL3Parser (geometryFactory, olReference) {\n  this.geometryFactory = geometryFactory || new GeometryFactory()\n  this.ol = olReference || (typeof ol !== 'undefined' && ol)\n}\n\nextend(OL3Parser.prototype, {\n  /**\n   * @param geometry {ol.geom.Geometry}\n   * @return {Geometry}\n   * @memberof OL3Parser\n   */\n  read (geometry) {\n    const ol = this.ol\n    if (geometry instanceof ol.geom.Point) {\n      return this.convertFromPoint(geometry)\n    } else if (geometry instanceof ol.geom.LineString) {\n      return this.convertFromLineString(geometry)\n    } else if (geometry instanceof ol.geom.LinearRing) {\n      return this.convertFromLinearRing(geometry)\n    } else if (geometry instanceof ol.geom.Polygon) {\n      return this.convertFromPolygon(geometry)\n    } else if (geometry instanceof ol.geom.MultiPoint) {\n      return this.convertFromMultiPoint(geometry)\n    } else if (geometry instanceof ol.geom.MultiLineString) {\n      return this.convertFromMultiLineString(geometry)\n    } else if (geometry instanceof ol.geom.MultiPolygon) {\n      return this.convertFromMultiPolygon(geometry)\n    } else if (geometry instanceof ol.geom.GeometryCollection) {\n      return this.convertFromCollection(geometry)\n    }\n  },\n\n  convertFromPoint (point) {\n    const coordinates = point.getCoordinates()\n    return this.geometryFactory.createPoint(new Coordinate(coordinates[0], coordinates[1]))\n  },\n\n  convertFromLineString (lineString) {\n    return this.geometryFactory.createLineString(lineString.getCoordinates().map(function (coordinates) {\n      return new Coordinate(coordinates[0], coordinates[1])\n    }))\n  },\n\n  convertFromLinearRing (linearRing) {\n    return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function (coordinates) {\n      return new Coordinate(coordinates[0], coordinates[1])\n    }))\n  },\n\n  convertFromPolygon (polygon) {\n    const linearRings = polygon.getLinearRings()\n    var shell = null\n    var holes = []\n    for (let i = 0; i < linearRings.length; i++) {\n      const linearRing = this.convertFromLinearRing(linearRings[i])\n      if (i === 0) {\n        shell = linearRing\n      } else {\n        holes.push(linearRing)\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  convertFromMultiPoint (multiPoint) {\n    const points = multiPoint.getPoints().map(function (point) {\n      return this.convertFromPoint(point)\n    }, this)\n    return this.geometryFactory.createMultiPoint(points)\n  },\n\n  convertFromMultiLineString (multiLineString) {\n    const lineStrings = multiLineString.getLineStrings().map(function (lineString) {\n      return this.convertFromLineString(lineString)\n    }, this)\n    return this.geometryFactory.createMultiLineString(lineStrings)\n  },\n\n  convertFromMultiPolygon (multiPolygon) {\n    const polygons = multiPolygon.getPolygons().map(function (polygon) {\n      return this.convertFromPolygon(polygon)\n    }, this)\n    return this.geometryFactory.createMultiPolygon(polygons)\n  },\n\n  convertFromCollection (collection) {\n    const geometries = collection.getGeometries().map(function (geometry) {\n      return this.read(geometry)\n    }, this)\n    return this.geometryFactory.createGeometryCollection(geometries)\n  },\n\n  /**\n   * @param geometry\n   *          {Geometry}\n   * @return {ol.geom.Geometry}\n   * @memberof! OL3Parser\n   */\n  write (geometry) {\n    if (geometry.getGeometryType() === 'Point') {\n      return this.convertToPoint(geometry.getCoordinate())\n    } else if (geometry.getGeometryType() === 'LineString') {\n      return this.convertToLineString(geometry)\n    } else if (geometry.getGeometryType() === 'LinearRing') {\n      return this.convertToLinearRing(geometry)\n    } else if (geometry.getGeometryType() === 'Polygon') {\n      return this.convertToPolygon(geometry)\n    } else if (geometry.getGeometryType() === 'MultiPoint') {\n      return this.convertToMultiPoint(geometry)\n    } else if (geometry.getGeometryType() === 'MultiLineString') {\n      return this.convertToMultiLineString(geometry)\n    } else if (geometry.getGeometryType() === 'MultiPolygon') {\n      return this.convertToMultiPolygon(geometry)\n    } else if (geometry.getGeometryType() === 'GeometryCollection') {\n      return this.convertToCollection(geometry)\n    }\n  },\n\n  convertToPoint (coordinate) {\n    return new this.ol.geom.Point([coordinate.x, coordinate.y])\n  },\n\n  convertToLineString (lineString) {\n    var points = lineString.points.coordinates.map(p2c)\n    return new this.ol.geom.LineString(points)\n  },\n\n  convertToLinearRing (linearRing) {\n    var points = linearRing.points.coordinates.map(p2c)\n    return new this.ol.geom.LinearRing(points)\n  },\n\n  convertToPolygon (polygon) {\n    var rings = [polygon.shell.points.coordinates.map(p2c)]\n    for (let i = 0; i < polygon.holes.length; i++) {\n      rings.push(polygon.holes[i].points.coordinates.map(p2c))\n    }\n    return new this.ol.geom.Polygon(rings)\n  },\n\n  convertToMultiPoint (multiPoint) {\n    return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c))\n  },\n\n  convertToMultiLineString (multiLineString) {\n    var lineStrings = []\n    for (let i = 0; i < multiLineString.geometries.length; i++) {\n      lineStrings.push(this.convertToLineString(multiLineString.geometries[i]).getCoordinates())\n    }\n    return new this.ol.geom.MultiLineString(lineStrings)\n  },\n\n  convertToMultiPolygon (multiPolygon) {\n    var polygons = []\n    for (let i = 0; i < multiPolygon.geometries.length; i++) {\n      polygons.push(this.convertToPolygon(multiPolygon.geometries[i]).getCoordinates())\n    }\n    return new this.ol.geom.MultiPolygon(polygons)\n  },\n\n  convertToCollection (geometryCollection) {\n    var geometries = []\n    for (let i = 0; i < geometryCollection.geometries.length; i++) {\n      var geometry = geometryCollection.geometries[i]\n      geometries.push(this.write(geometry))\n    }\n    return new this.ol.geom.GeometryCollection(geometries)\n  }\n})\n","import hasInterface from '../../../../hasInterface';\nimport Collection from '../../../../java/util/Collection';\nimport Noder from './Noder';\nimport Coordinate from '../geom/Coordinate';\nimport NodedSegmentString from './NodedSegmentString';\nimport extend from '../../../../extend';\nimport System from '../../../../java/lang/System';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function ScaledNoder() {\n\tthis.noder = null;\n\tthis.scaleFactor = null;\n\tthis.offsetX = null;\n\tthis.offsetY = null;\n\tthis.isScaled = false;\n\tif (arguments.length === 2) {\n\t\tlet noder = arguments[0], scaleFactor = arguments[1];\n\t\tScaledNoder.call(this, noder, scaleFactor, 0, 0);\n\t} else if (arguments.length === 4) {\n\t\tlet noder = arguments[0], scaleFactor = arguments[1], offsetX = arguments[2], offsetY = arguments[3];\n\t\tthis.noder = noder;\n\t\tthis.scaleFactor = scaleFactor;\n\t\tthis.isScaled = !this.isIntegerPrecision();\n\t}\n}\nextend(ScaledNoder.prototype, {\n\trescale: function () {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tlet segStrings = arguments[0];\n\t\t\tfor (var i = segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tthis.rescale(ss.getCoordinates());\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Array) {\n\t\t\tlet pts = arguments[0];\n\t\t\tvar p0 = null;\n\t\t\tvar p1 = null;\n\t\t\tif (pts.length === 2) {\n\t\t\t\tp0 = new Coordinate(pts[0]);\n\t\t\t\tp1 = new Coordinate(pts[1]);\n\t\t\t}\n\t\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\t\tpts[i].x = pts[i].x / this.scaleFactor + this.offsetX;\n\t\t\t\tpts[i].y = pts[i].y / this.scaleFactor + this.offsetY;\n\t\t\t}\n\t\t\tif (pts.length === 2 && pts[0].equals2D(pts[1])) {\n\t\t\t\tSystem.out.println(pts);\n\t\t\t}\n\t\t}\n\t},\n\tscale: function () {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tlet segStrings = arguments[0];\n\t\t\tvar nodedSegmentStrings = new ArrayList();\n\t\t\tfor (var i = segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tnodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));\n\t\t\t}\n\t\t\treturn nodedSegmentStrings;\n\t\t} else if (arguments[0] instanceof Array) {\n\t\t\tlet pts = arguments[0];\n\t\t\tvar roundPts = new Array(pts.length).fill(null);\n\t\t\tfor (var i = 0; i < pts.length; i++) {\n\t\t\t\troundPts[i] = new Coordinate(Math.round((pts[i].x - this.offsetX) * this.scaleFactor), Math.round((pts[i].y - this.offsetY) * this.scaleFactor), pts[i].z);\n\t\t\t}\n\t\t\tvar roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n\t\t\treturn roundPtsNoDup;\n\t\t}\n\t},\n\tisIntegerPrecision: function () {\n\t\treturn this.scaleFactor === 1.0;\n\t},\n\tgetNodedSubstrings: function () {\n\t\tvar splitSS = this.noder.getNodedSubstrings();\n\t\tif (this.isScaled) this.rescale(splitSS);\n\t\treturn splitSS;\n\t},\n\tcomputeNodes: function (inputSegStrings) {\n\t\tvar intSegStrings = inputSegStrings;\n\t\tif (this.isScaled) intSegStrings = this.scale(inputSegStrings);\n\t\tthis.noder.computeNodes(intSegStrings);\n\t},\n\tinterfaces_: function () {\n\t\treturn [Noder];\n\t},\n\tgetClass: function () {\n\t\treturn ScaledNoder;\n\t}\n});\n","import TreeSet from '../../../../java/util/TreeSet';\nimport LineString from '../geom/LineString';\nimport hasInterface from '../../../../hasInterface';\nimport MultiPoint from '../geom/MultiPoint';\nimport extend from '../../../../extend';\nimport GeometryGraph from '../geomgraph/GeometryGraph';\nimport GeometryCollection from '../geom/GeometryCollection';\nimport Polygonal from '../geom/Polygonal';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nimport LinearComponentExtracter from '../geom/util/LinearComponentExtracter';\nimport TreeMap from '../../../../java/util/TreeMap';\nimport MultiLineString from '../geom/MultiLineString';\nexport default function IsSimpleOp() {\n\tthis.inputGeom = null;\n\tthis.isClosedEndpointsInInterior = true;\n\tthis.nonSimpleLocation = null;\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\tthis.inputGeom = geom;\n\t} else if (arguments.length === 2) {\n\t\tlet geom = arguments[0], boundaryNodeRule = arguments[1];\n\t\tthis.inputGeom = geom;\n\t\tthis.isClosedEndpointsInInterior = !boundaryNodeRule.isInBoundary(2);\n\t}\n}\nextend(IsSimpleOp.prototype, {\n\tisSimpleMultiPoint: function (mp) {\n\t\tif (mp.isEmpty()) return true;\n\t\tvar points = new TreeSet();\n\t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n\t\t\tvar pt = mp.getGeometryN(i);\n\t\t\tvar p = pt.getCoordinate();\n\t\t\tif (points.contains(p)) {\n\t\t\t\tthis.nonSimpleLocation = p;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpoints.add(p);\n\t\t}\n\t\treturn true;\n\t},\n\tisSimplePolygonal: function (geom) {\n\t\tvar rings = LinearComponentExtracter.getLines(geom);\n\t\tfor (var i = rings.iterator(); i.hasNext(); ) {\n\t\t\tvar ring = i.next();\n\t\t\tif (!this.isSimpleLinearGeometry(ring)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\thasClosedEndpointIntersection: function (graph) {\n\t\tvar endPoints = new TreeMap();\n\t\tfor (var i = graph.getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar maxSegmentIndex = e.getMaximumSegmentIndex();\n\t\t\tvar isClosed = e.isClosed();\n\t\t\tvar p0 = e.getCoordinate(0);\n\t\t\tthis.addEndpoint(endPoints, p0, isClosed);\n\t\t\tvar p1 = e.getCoordinate(e.getNumPoints() - 1);\n\t\t\tthis.addEndpoint(endPoints, p1, isClosed);\n\t\t}\n\t\tfor (var i = endPoints.values().iterator(); i.hasNext(); ) {\n\t\t\tvar eiInfo = i.next();\n\t\t\tif (eiInfo.isClosed && eiInfo.degree !== 2) {\n\t\t\t\tthis.nonSimpleLocation = eiInfo.getCoordinate();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetNonSimpleLocation: function () {\n\t\treturn this.nonSimpleLocation;\n\t},\n\tisSimpleLinearGeometry: function (geom) {\n\t\tif (geom.isEmpty()) return true;\n\t\tvar graph = new GeometryGraph(0, geom);\n\t\tvar li = new RobustLineIntersector();\n\t\tvar si = graph.computeSelfNodes(li, true);\n\t\tif (!si.hasIntersection()) return true;\n\t\tif (si.hasProperIntersection()) {\n\t\t\tthis.nonSimpleLocation = si.getProperIntersectionPoint();\n\t\t\treturn false;\n\t\t}\n\t\tif (this.hasNonEndpointIntersection(graph)) return false;\n\t\tif (this.isClosedEndpointsInInterior) {\n\t\t\tif (this.hasClosedEndpointIntersection(graph)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\thasNonEndpointIntersection: function (graph) {\n\t\tfor (var i = graph.getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar maxSegmentIndex = e.getMaximumSegmentIndex();\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tif (!ei.isEndPoint(maxSegmentIndex)) {\n\t\t\t\t\tthis.nonSimpleLocation = ei.getCoordinate();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\taddEndpoint: function (endPoints, p, isClosed) {\n\t\tvar eiInfo = endPoints.get(p);\n\t\tif (eiInfo === null) {\n\t\t\teiInfo = new EndpointInfo(p);\n\t\t\tendPoints.put(p, eiInfo);\n\t\t}\n\t\teiInfo.addEndpoint(isClosed);\n\t},\n\tcomputeSimple: function (geom) {\n\t\tthis.nonSimpleLocation = null;\n\t\tif (geom.isEmpty()) return true;\n\t\tif (geom instanceof LineString) return this.isSimpleLinearGeometry(geom);\n\t\tif (geom instanceof MultiLineString) return this.isSimpleLinearGeometry(geom);\n\t\tif (geom instanceof MultiPoint) return this.isSimpleMultiPoint(geom);\n\t\tif (hasInterface(geom, Polygonal)) return this.isSimplePolygonal(geom);\n\t\tif (geom instanceof GeometryCollection) return this.isSimpleGeometryCollection(geom);\n\t\treturn true;\n\t},\n\tisSimple: function () {\n\t\tthis.nonSimpleLocation = null;\n\t\treturn this.computeSimple(this.inputGeom);\n\t},\n\tisSimpleGeometryCollection: function (geom) {\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar comp = geom.getGeometryN(i);\n\t\t\tif (!this.computeSimple(comp)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IsSimpleOp;\n\t}\n});\nfunction EndpointInfo() {\n\tthis.pt = null;\n\tthis.isClosed = null;\n\tthis.degree = null;\n\tlet pt = arguments[0];\n\tthis.pt = pt;\n\tthis.isClosed = false;\n\tthis.degree = 0;\n}\nextend(EndpointInfo.prototype, {\n\taddEndpoint: function (isClosed) {\n\t\tthis.degree++;\n\t\tthis.isClosed |= isClosed;\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.pt;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EndpointInfo;\n\t}\n});\nIsSimpleOp.EndpointInfo = EndpointInfo;\n","import extend from '../../../../../extend';\nexport default function BufferParameters() {\n\tthis.quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n\tthis.endCapStyle = BufferParameters.CAP_ROUND;\n\tthis.joinStyle = BufferParameters.JOIN_ROUND;\n\tthis.mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n\tthis._isSingleSided = false;\n\tthis.simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet quadrantSegments = arguments[0];\n\t\tthis.setQuadrantSegments(quadrantSegments);\n\t} else if (arguments.length === 2) {\n\t\tlet quadrantSegments = arguments[0], endCapStyle = arguments[1];\n\t\tthis.setQuadrantSegments(quadrantSegments);\n\t\tthis.setEndCapStyle(endCapStyle);\n\t} else if (arguments.length === 4) {\n\t\tlet quadrantSegments = arguments[0], endCapStyle = arguments[1], joinStyle = arguments[2], mitreLimit = arguments[3];\n\t\tthis.setQuadrantSegments(quadrantSegments);\n\t\tthis.setEndCapStyle(endCapStyle);\n\t\tthis.setJoinStyle(joinStyle);\n\t\tthis.setMitreLimit(mitreLimit);\n\t}\n}\nextend(BufferParameters.prototype, {\n\tgetEndCapStyle: function () {\n\t\treturn this.endCapStyle;\n\t},\n\tisSingleSided: function () {\n\t\treturn this._isSingleSided;\n\t},\n\tsetQuadrantSegments: function (quadSegs) {\n\t\tthis.quadrantSegments = quadSegs;\n\t\tif (this.quadrantSegments === 0) this.joinStyle = BufferParameters.JOIN_BEVEL;\n\t\tif (this.quadrantSegments < 0) {\n\t\t\tthis.joinStyle = BufferParameters.JOIN_MITRE;\n\t\t\tthis.mitreLimit = Math.abs(this.quadrantSegments);\n\t\t}\n\t\tif (quadSegs <= 0) {\n\t\t\tthis.quadrantSegments = 1;\n\t\t}\n\t\tif (this.joinStyle !== BufferParameters.JOIN_ROUND) {\n\t\t\tthis.quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n\t\t}\n\t},\n\tgetJoinStyle: function () {\n\t\treturn this.joinStyle;\n\t},\n\tsetJoinStyle: function (joinStyle) {\n\t\tthis.joinStyle = joinStyle;\n\t},\n\tsetSimplifyFactor: function (simplifyFactor) {\n\t\tthis.simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n\t},\n\tgetSimplifyFactor: function () {\n\t\treturn this.simplifyFactor;\n\t},\n\tgetQuadrantSegments: function () {\n\t\treturn this.quadrantSegments;\n\t},\n\tsetEndCapStyle: function (endCapStyle) {\n\t\tthis.endCapStyle = endCapStyle;\n\t},\n\tgetMitreLimit: function () {\n\t\treturn this.mitreLimit;\n\t},\n\tsetMitreLimit: function (mitreLimit) {\n\t\tthis.mitreLimit = mitreLimit;\n\t},\n\tsetSingleSided: function (isSingleSided) {\n\t\tthis._isSingleSided = isSingleSided;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BufferParameters;\n\t}\n});\nBufferParameters.bufferDistanceError = function (quadSegs) {\n\tvar alpha = Math.PI / 2.0 / quadSegs;\n\treturn 1 - Math.cos(alpha / 2.0);\n};\nBufferParameters.CAP_ROUND = 1;\nBufferParameters.CAP_FLAT = 2;\nBufferParameters.CAP_SQUARE = 3;\nBufferParameters.JOIN_ROUND = 1;\nBufferParameters.JOIN_MITRE = 2;\nBufferParameters.JOIN_BEVEL = 3;\nBufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;\nBufferParameters.DEFAULT_MITRE_LIMIT = 5.0;\nBufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;\n","import CGAlgorithms from '../../algorithm/CGAlgorithms';\nimport Position from '../../geomgraph/Position';\nimport extend from '../../../../../extend';\nimport Assert from '../../util/Assert';\nexport default function RightmostEdgeFinder() {\n\tthis.minIndex = -1;\n\tthis.minCoord = null;\n\tthis.minDe = null;\n\tthis.orientedDe = null;\n}\nextend(RightmostEdgeFinder.prototype, {\n\tgetCoordinate: function () {\n\t\treturn this.minCoord;\n\t},\n\tgetRightmostSide: function (de, index) {\n\t\tvar side = this.getRightmostSideOfSegment(de, index);\n\t\tif (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);\n\t\tif (side < 0) {\n\t\t\tthis.minCoord = null;\n\t\t\tthis.checkForRightmostCoordinate(de);\n\t\t}\n\t\treturn side;\n\t},\n\tfindRightmostEdgeAtVertex: function () {\n\t\tvar pts = this.minDe.getEdge().getCoordinates();\n\t\tAssert.isTrue(this.minIndex > 0 && this.minIndex < pts.length, \"rightmost point expected to be interior vertex of edge\");\n\t\tvar pPrev = pts[this.minIndex - 1];\n\t\tvar pNext = pts[this.minIndex + 1];\n\t\tvar orientation = CGAlgorithms.computeOrientation(this.minCoord, pNext, pPrev);\n\t\tvar usePrev = false;\n\t\tif (pPrev.y < this.minCoord.y && pNext.y < this.minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {\n\t\t\tusePrev = true;\n\t\t} else if (pPrev.y > this.minCoord.y && pNext.y > this.minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {\n\t\t\tusePrev = true;\n\t\t}\n\t\tif (usePrev) {\n\t\t\tthis.minIndex = this.minIndex - 1;\n\t\t}\n\t},\n\tgetRightmostSideOfSegment: function (de, i) {\n\t\tvar e = de.getEdge();\n\t\tvar coord = e.getCoordinates();\n\t\tif (i < 0 || i + 1 >= coord.length) return -1;\n\t\tif (coord[i].y === coord[i + 1].y) return -1;\n\t\tvar pos = Position.LEFT;\n\t\tif (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;\n\t\treturn pos;\n\t},\n\tgetEdge: function () {\n\t\treturn this.orientedDe;\n\t},\n\tcheckForRightmostCoordinate: function (de) {\n\t\tvar coord = de.getEdge().getCoordinates();\n\t\tfor (var i = 0; i < coord.length - 1; i++) {\n\t\t\tif (this.minCoord === null || coord[i].x > this.minCoord.x) {\n\t\t\t\tthis.minDe = de;\n\t\t\t\tthis.minIndex = i;\n\t\t\t\tthis.minCoord = coord[i];\n\t\t\t}\n\t\t}\n\t},\n\tfindRightmostEdgeAtNode: function () {\n\t\tvar node = this.minDe.getNode();\n\t\tvar star = node.getEdges();\n\t\tthis.minDe = star.getRightmostEdge();\n\t\tif (!this.minDe.isForward()) {\n\t\t\tthis.minDe = this.minDe.getSym();\n\t\t\tthis.minIndex = this.minDe.getEdge().getCoordinates().length - 1;\n\t\t}\n\t},\n\tfindEdge: function (dirEdgeList) {\n\t\tfor (var i = dirEdgeList.iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tif (!de.isForward()) continue;\n\t\t\tthis.checkForRightmostCoordinate(de);\n\t\t}\n\t\tAssert.isTrue(this.minIndex !== 0 || this.minCoord.equals(this.minDe.getCoordinate()), \"inconsistency in rightmost processing\");\n\t\tif (this.minIndex === 0) {\n\t\t\tthis.findRightmostEdgeAtNode();\n\t\t} else {\n\t\t\tthis.findRightmostEdgeAtVertex();\n\t\t}\n\t\tthis.orientedDe = this.minDe;\n\t\tvar rightmostSide = this.getRightmostSide(this.minDe, this.minIndex);\n\t\tif (rightmostSide === Position.LEFT) {\n\t\t\tthis.orientedDe = this.minDe.getSym();\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RightmostEdgeFinder;\n\t}\n});\n","export default function LinkedList () {\n  this.array_ = []\n}\nLinkedList.prototype.addLast = function (e) {\n  this.array_.push(e)\n}\nLinkedList.prototype.removeFirst = function () {\n  return this.array_.shift()\n}\nLinkedList.prototype.isEmpty = function () {\n  return this.array_.length === 0\n}\n","import HashSet from '../../../../../java/util/HashSet';\nimport Position from '../../geomgraph/Position';\nimport Stack from '../../../../../java/util/Stack';\nimport RightmostEdgeFinder from './RightmostEdgeFinder';\nimport TopologyException from '../../geom/TopologyException';\nimport extend from '../../../../../extend';\nimport LinkedList from '../../../../../java/util/LinkedList';\nimport Comparable from '../../../../../java/lang/Comparable';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Envelope from '../../geom/Envelope';\nexport default function BufferSubgraph() {\n\tthis.finder = null;\n\tthis.dirEdgeList = new ArrayList();\n\tthis.nodes = new ArrayList();\n\tthis.rightMostCoord = null;\n\tthis.env = null;\n\tthis.finder = new RightmostEdgeFinder();\n}\nextend(BufferSubgraph.prototype, {\n\tclearVisitedEdges: function () {\n\t\tfor (var it = this.dirEdgeList.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tde.setVisited(false);\n\t\t}\n\t},\n\tgetRightmostCoordinate: function () {\n\t\treturn this.rightMostCoord;\n\t},\n\tcomputeNodeDepth: function (n) {\n\t\tvar startEdge = null;\n\t\tfor (var i = n.getEdges().iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tif (de.isVisited() || de.getSym().isVisited()) {\n\t\t\t\tstartEdge = de;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (startEdge === null) throw new TopologyException(\"unable to find edge to compute depths at \" + n.getCoordinate());\n\t\tn.getEdges().computeDepths(startEdge);\n\t\tfor (var i = n.getEdges().iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tde.setVisited(true);\n\t\t\tthis.copySymDepths(de);\n\t\t}\n\t},\n\tcomputeDepth: function (outsideDepth) {\n\t\tthis.clearVisitedEdges();\n\t\tvar de = this.finder.getEdge();\n\t\tvar n = de.getNode();\n\t\tvar label = de.getLabel();\n\t\tde.setEdgeDepths(Position.RIGHT, outsideDepth);\n\t\tthis.copySymDepths(de);\n\t\tthis.computeDepths(de);\n\t},\n\tcreate: function (node) {\n\t\tthis.addReachable(node);\n\t\tthis.finder.findEdge(this.dirEdgeList);\n\t\tthis.rightMostCoord = this.finder.getCoordinate();\n\t},\n\tfindResultEdges: function () {\n\t\tfor (var it = this.dirEdgeList.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {\n\t\t\t\tde.setInResult(true);\n\t\t\t}\n\t\t}\n\t},\n\tcomputeDepths: function (startEdge) {\n\t\tvar nodesVisited = new HashSet();\n\t\tvar nodeQueue = new LinkedList();\n\t\tvar startNode = startEdge.getNode();\n\t\tnodeQueue.addLast(startNode);\n\t\tnodesVisited.add(startNode);\n\t\tstartEdge.setVisited(true);\n\t\twhile (!nodeQueue.isEmpty()) {\n\t\t\tvar n = nodeQueue.removeFirst();\n\t\t\tnodesVisited.add(n);\n\t\t\tthis.computeNodeDepth(n);\n\t\t\tfor (var i = n.getEdges().iterator(); i.hasNext(); ) {\n\t\t\t\tvar de = i.next();\n\t\t\t\tvar sym = de.getSym();\n\t\t\t\tif (sym.isVisited()) continue;\n\t\t\t\tvar adjNode = sym.getNode();\n\t\t\t\tif (!nodesVisited.contains(adjNode)) {\n\t\t\t\t\tnodeQueue.addLast(adjNode);\n\t\t\t\t\tnodesVisited.add(adjNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcompareTo: function (o) {\n\t\tvar graph = o;\n\t\tif (this.rightMostCoord.x < graph.rightMostCoord.x) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.rightMostCoord.x > graph.rightMostCoord.x) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t},\n\tgetEnvelope: function () {\n\t\tif (this.env === null) {\n\t\t\tvar edgeEnv = new Envelope();\n\t\t\tfor (var it = this.dirEdgeList.iterator(); it.hasNext(); ) {\n\t\t\t\tvar dirEdge = it.next();\n\t\t\t\tvar pts = dirEdge.getEdge().getCoordinates();\n\t\t\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\t\t\tedgeEnv.expandToInclude(pts[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.env = edgeEnv;\n\t\t}\n\t\treturn this.env;\n\t},\n\taddReachable: function (startNode) {\n\t\tvar nodeStack = new Stack();\n\t\tnodeStack.add(startNode);\n\t\twhile (!nodeStack.empty()) {\n\t\t\tvar node = nodeStack.pop();\n\t\t\tthis.add(node, nodeStack);\n\t\t}\n\t},\n\tcopySymDepths: function (de) {\n\t\tvar sym = de.getSym();\n\t\tsym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n\t\tsym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n\t},\n\tadd: function (node, nodeStack) {\n\t\tnode.setVisited(true);\n\t\tthis.nodes.add(node);\n\t\tfor (var i = node.getEdges().iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tthis.dirEdgeList.add(de);\n\t\t\tvar sym = de.getSym();\n\t\t\tvar symNode = sym.getNode();\n\t\t\tif (!symNode.isVisited()) nodeStack.push(symNode);\n\t\t}\n\t},\n\tgetNodes: function () {\n\t\treturn this.nodes;\n\t},\n\tgetDirectedEdges: function () {\n\t\treturn this.dirEdgeList;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn BufferSubgraph;\n\t}\n});\n","import CGAlgorithms from '../../algorithm/CGAlgorithms';\nimport CoordinateList from '../../geom/CoordinateList';\nimport extend from '../../../../../extend';\nexport default function BufferInputLineSimplifier() {\n\tthis.inputLine = null;\n\tthis.distanceTol = null;\n\tthis.isDeleted = null;\n\tthis.angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;\n\tlet inputLine = arguments[0];\n\tthis.inputLine = inputLine;\n}\nextend(BufferInputLineSimplifier.prototype, {\n\tisDeletable: function (i0, i1, i2, distanceTol) {\n\t\tvar p0 = this.inputLine[i0];\n\t\tvar p1 = this.inputLine[i1];\n\t\tvar p2 = this.inputLine[i2];\n\t\tif (!this.isConcave(p0, p1, p2)) return false;\n\t\tif (!this.isShallow(p0, p1, p2, distanceTol)) return false;\n\t\treturn this.isShallowSampled(p0, p1, i0, i2, distanceTol);\n\t},\n\tdeleteShallowConcavities: function () {\n\t\tvar index = 1;\n\t\tvar maxIndex = this.inputLine.length - 1;\n\t\tvar midIndex = this.findNextNonDeletedIndex(index);\n\t\tvar lastIndex = this.findNextNonDeletedIndex(midIndex);\n\t\tvar isChanged = false;\n\t\twhile (lastIndex < this.inputLine.length) {\n\t\t\tvar isMiddleVertexDeleted = false;\n\t\t\tif (this.isDeletable(index, midIndex, lastIndex, this.distanceTol)) {\n\t\t\t\tthis.isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n\t\t\t\tisMiddleVertexDeleted = true;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\t\t\tif (isMiddleVertexDeleted) index = lastIndex; else index = midIndex;\n\t\t\tmidIndex = this.findNextNonDeletedIndex(index);\n\t\t\tlastIndex = this.findNextNonDeletedIndex(midIndex);\n\t\t}\n\t\treturn isChanged;\n\t},\n\tisShallowConcavity: function (p0, p1, p2, distanceTol) {\n\t\tvar orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n\t\tvar isAngleToSimplify = orientation === this.angleOrientation;\n\t\tif (!isAngleToSimplify) return false;\n\t\tvar dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n\t\treturn dist < distanceTol;\n\t},\n\tisShallowSampled: function (p0, p2, i0, i2, distanceTol) {\n\t\tvar inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n\t\tif (inc <= 0) inc = 1;\n\t\tfor (var i = i0; i < i2; i += inc) {\n\t\t\tif (!this.isShallow(p0, p2, this.inputLine[i], distanceTol)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tisConcave: function (p0, p1, p2) {\n\t\tvar orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n\t\tvar isConcave = orientation === this.angleOrientation;\n\t\treturn isConcave;\n\t},\n\tsimplify: function (distanceTol) {\n\t\tthis.distanceTol = Math.abs(distanceTol);\n\t\tif (distanceTol < 0) this.angleOrientation = CGAlgorithms.CLOCKWISE;\n\t\tthis.isDeleted = new Array(this.inputLine.length).fill(null);\n\t\tvar isChanged = false;\n\t\tdo {\n\t\t\tisChanged = this.deleteShallowConcavities();\n\t\t} while (isChanged);\n\t\treturn this.collapseLine();\n\t},\n\tfindNextNonDeletedIndex: function (index) {\n\t\tvar next = index + 1;\n\t\twhile (next < this.inputLine.length && this.isDeleted[next] === BufferInputLineSimplifier.DELETE) next++;\n\t\treturn next;\n\t},\n\tisShallow: function (p0, p1, p2, distanceTol) {\n\t\tvar dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n\t\treturn dist < distanceTol;\n\t},\n\tcollapseLine: function () {\n\t\tvar coordList = new CoordinateList();\n\t\tfor (var i = 0; i < this.inputLine.length; i++) {\n\t\t\tif (this.isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this.inputLine[i]);\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BufferInputLineSimplifier;\n\t}\n});\nBufferInputLineSimplifier.simplify = function (inputLine, distanceTol) {\n\tvar simp = new BufferInputLineSimplifier(inputLine);\n\treturn simp.simplify(distanceTol);\n};\nBufferInputLineSimplifier.INIT = 0;\nBufferInputLineSimplifier.DELETE = 1;\nBufferInputLineSimplifier.KEEP = 1;\nBufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;\n","import GeometryFactory from '../../geom/GeometryFactory';\nimport Coordinate from '../../geom/Coordinate';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function OffsetSegmentString() {\n\tthis.ptList = null;\n\tthis.precisionModel = null;\n\tthis.minimimVertexDistance = 0.0;\n\tthis.ptList = new ArrayList();\n}\nextend(OffsetSegmentString.prototype, {\n\tgetCoordinates: function () {\n\t\tvar coord = this.ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n\t\treturn coord;\n\t},\n\tsetPrecisionModel: function (precisionModel) {\n\t\tthis.precisionModel = precisionModel;\n\t},\n\taddPt: function (pt) {\n\t\tvar bufPt = new Coordinate(pt);\n\t\tthis.precisionModel.makePrecise(bufPt);\n\t\tif (this.isRedundant(bufPt)) return null;\n\t\tthis.ptList.add(bufPt);\n\t},\n\treverse: function () {},\n\taddPts: function (pt, isForward) {\n\t\tif (isForward) {\n\t\t\tfor (var i = 0; i < pt.length; i++) {\n\t\t\t\tthis.addPt(pt[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = pt.length - 1; i >= 0; i--) {\n\t\t\t\tthis.addPt(pt[i]);\n\t\t\t}\n\t\t}\n\t},\n\tisRedundant: function (pt) {\n\t\tif (this.ptList.size() < 1) return false;\n\t\tvar lastPt = this.ptList.get(this.ptList.size() - 1);\n\t\tvar ptDist = pt.distance(lastPt);\n\t\tif (ptDist < this.minimimVertexDistance) return true;\n\t\treturn false;\n\t},\n\ttoString: function () {\n\t\tvar fact = new GeometryFactory();\n\t\tvar line = fact.createLineString(this.getCoordinates());\n\t\treturn line.toString();\n\t},\n\tcloseRing: function () {\n\t\tif (this.ptList.size() < 1) return null;\n\t\tvar startPt = new Coordinate(this.ptList.get(0));\n\t\tvar lastPt = this.ptList.get(this.ptList.size() - 1);\n\t\tvar last2Pt = null;\n\t\tif (this.ptList.size() >= 2) last2Pt = this.ptList.get(this.ptList.size() - 2);\n\t\tif (startPt.equals(lastPt)) return null;\n\t\tthis.ptList.add(startPt);\n\t},\n\tsetMinimumVertexDistance: function (minimimVertexDistance) {\n\t\tthis.minimimVertexDistance = minimimVertexDistance;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OffsetSegmentString;\n\t}\n});\nOffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);\n","import BufferParameters from './BufferParameters';\nimport NotRepresentableException from '../../algorithm/NotRepresentableException';\nimport CGAlgorithms from '../../algorithm/CGAlgorithms';\nimport Position from '../../geomgraph/Position';\nimport Coordinate from '../../geom/Coordinate';\nimport extend from '../../../../../extend';\nimport OffsetSegmentString from './OffsetSegmentString';\nimport LineSegment from '../../geom/LineSegment';\nimport Angle from '../../algorithm/Angle';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport HCoordinate from '../../algorithm/HCoordinate';\nexport default function OffsetSegmentGenerator() {\n\tthis.maxCurveSegmentError = 0.0;\n\tthis.filletAngleQuantum = null;\n\tthis.closingSegLengthFactor = 1;\n\tthis.segList = null;\n\tthis.distance = 0.0;\n\tthis.precisionModel = null;\n\tthis.bufParams = null;\n\tthis.li = null;\n\tthis.s0 = null;\n\tthis.s1 = null;\n\tthis.s2 = null;\n\tthis.seg0 = new LineSegment();\n\tthis.seg1 = new LineSegment();\n\tthis.offset0 = new LineSegment();\n\tthis.offset1 = new LineSegment();\n\tthis.side = 0;\n\tthis._hasNarrowConcaveAngle = false;\n\tlet precisionModel = arguments[0], bufParams = arguments[1], distance = arguments[2];\n\tthis.precisionModel = precisionModel;\n\tthis.bufParams = bufParams;\n\tthis.li = new RobustLineIntersector();\n\tthis.filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n\tif (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this.closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;\n\tthis.init(distance);\n}\nextend(OffsetSegmentGenerator.prototype, {\n\taddNextSegment: function (p, addStartPoint) {\n\t\tthis.s0 = this.s1;\n\t\tthis.s1 = this.s2;\n\t\tthis.s2 = p;\n\t\tthis.seg0.setCoordinates(this.s0, this.s1);\n\t\tthis.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0);\n\t\tthis.seg1.setCoordinates(this.s1, this.s2);\n\t\tthis.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1);\n\t\tif (this.s1.equals(this.s2)) return null;\n\t\tvar orientation = CGAlgorithms.computeOrientation(this.s0, this.s1, this.s2);\n\t\tvar outsideTurn = orientation === CGAlgorithms.CLOCKWISE && this.side === Position.LEFT || orientation === CGAlgorithms.COUNTERCLOCKWISE && this.side === Position.RIGHT;\n\t\tif (orientation === 0) {\n\t\t\tthis.addCollinear(addStartPoint);\n\t\t} else if (outsideTurn) {\n\t\t\tthis.addOutsideTurn(orientation, addStartPoint);\n\t\t} else {\n\t\t\tthis.addInsideTurn(orientation, addStartPoint);\n\t\t}\n\t},\n\taddLineEndCap: function (p0, p1) {\n\t\tvar seg = new LineSegment(p0, p1);\n\t\tvar offsetL = new LineSegment();\n\t\tthis.computeOffsetSegment(seg, Position.LEFT, this.distance, offsetL);\n\t\tvar offsetR = new LineSegment();\n\t\tthis.computeOffsetSegment(seg, Position.RIGHT, this.distance, offsetR);\n\t\tvar dx = p1.x - p0.x;\n\t\tvar dy = p1.y - p0.y;\n\t\tvar angle = Math.atan2(dy, dx);\n\t\tswitch (this.bufParams.getEndCapStyle()) {\n\t\t\tcase BufferParameters.CAP_ROUND:\n\t\t\t\tthis.segList.addPt(offsetL.p1);\n\t\t\t\tthis.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this.distance);\n\t\t\t\tthis.segList.addPt(offsetR.p1);\n\t\t\t\tbreak;\n\t\t\tcase BufferParameters.CAP_FLAT:\n\t\t\t\tthis.segList.addPt(offsetL.p1);\n\t\t\t\tthis.segList.addPt(offsetR.p1);\n\t\t\t\tbreak;\n\t\t\tcase BufferParameters.CAP_SQUARE:\n\t\t\t\tvar squareCapSideOffset = new Coordinate();\n\t\t\t\tsquareCapSideOffset.x = Math.abs(this.distance) * Math.cos(angle);\n\t\t\t\tsquareCapSideOffset.y = Math.abs(this.distance) * Math.sin(angle);\n\t\t\t\tvar squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n\t\t\t\tvar squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n\t\t\t\tthis.segList.addPt(squareCapLOffset);\n\t\t\t\tthis.segList.addPt(squareCapROffset);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\tgetCoordinates: function () {\n\t\tvar pts = this.segList.getCoordinates();\n\t\treturn pts;\n\t},\n\taddMitreJoin: function (p, offset0, offset1, distance) {\n\t\tvar isMitreWithinLimit = true;\n\t\tvar intPt = null;\n\t\ttry {\n\t\t\tintPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n\t\t\tvar mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n\t\t\tif (mitreRatio > this.bufParams.getMitreLimit()) isMitreWithinLimit = false;\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof NotRepresentableException) {\n\t\t\t\tintPt = new Coordinate(0, 0);\n\t\t\t\tisMitreWithinLimit = false;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t\tif (isMitreWithinLimit) {\n\t\t\tthis.segList.addPt(intPt);\n\t\t} else {\n\t\t\tthis.addLimitedMitreJoin(offset0, offset1, distance, this.bufParams.getMitreLimit());\n\t\t}\n\t},\n\taddFilletCorner: function (p, p0, p1, direction, radius) {\n\t\tvar dx0 = p0.x - p.x;\n\t\tvar dy0 = p0.y - p.y;\n\t\tvar startAngle = Math.atan2(dy0, dx0);\n\t\tvar dx1 = p1.x - p.x;\n\t\tvar dy1 = p1.y - p.y;\n\t\tvar endAngle = Math.atan2(dy1, dx1);\n\t\tif (direction === CGAlgorithms.CLOCKWISE) {\n\t\t\tif (startAngle <= endAngle) startAngle += 2.0 * Math.PI;\n\t\t} else {\n\t\t\tif (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;\n\t\t}\n\t\tthis.segList.addPt(p0);\n\t\tthis.addFilletArc(p, startAngle, endAngle, direction, radius);\n\t\tthis.segList.addPt(p1);\n\t},\n\taddOutsideTurn: function (orientation, addStartPoint) {\n\t\tif (this.offset0.p1.distance(this.offset1.p0) < this.distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n\t\t\tthis.segList.addPt(this.offset0.p1);\n\t\t\treturn null;\n\t\t}\n\t\tif (this.bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n\t\t\tthis.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance);\n\t\t} else if (this.bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n\t\t\tthis.addBevelJoin(this.offset0, this.offset1);\n\t\t} else {\n\t\t\tif (addStartPoint) this.segList.addPt(this.offset0.p1);\n\t\t\tthis.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, orientation, this.distance);\n\t\t\tthis.segList.addPt(this.offset1.p0);\n\t\t}\n\t},\n\tcreateSquare: function (p) {\n\t\tthis.segList.addPt(new Coordinate(p.x + this.distance, p.y + this.distance));\n\t\tthis.segList.addPt(new Coordinate(p.x + this.distance, p.y - this.distance));\n\t\tthis.segList.addPt(new Coordinate(p.x - this.distance, p.y - this.distance));\n\t\tthis.segList.addPt(new Coordinate(p.x - this.distance, p.y + this.distance));\n\t\tthis.segList.closeRing();\n\t},\n\taddSegments: function (pt, isForward) {\n\t\tthis.segList.addPts(pt, isForward);\n\t},\n\taddFirstSegment: function () {\n\t\tthis.segList.addPt(this.offset1.p0);\n\t},\n\taddLastSegment: function () {\n\t\tthis.segList.addPt(this.offset1.p1);\n\t},\n\tinitSideSegments: function (s1, s2, side) {\n\t\tthis.s1 = s1;\n\t\tthis.s2 = s2;\n\t\tthis.side = side;\n\t\tthis.seg1.setCoordinates(s1, s2);\n\t\tthis.computeOffsetSegment(this.seg1, side, this.distance, this.offset1);\n\t},\n\taddLimitedMitreJoin: function (offset0, offset1, distance, mitreLimit) {\n\t\tvar basePt = this.seg0.p1;\n\t\tvar ang0 = Angle.angle(basePt, this.seg0.p0);\n\t\tvar ang1 = Angle.angle(basePt, this.seg1.p1);\n\t\tvar angDiff = Angle.angleBetweenOriented(this.seg0.p0, basePt, this.seg1.p1);\n\t\tvar angDiffHalf = angDiff / 2;\n\t\tvar midAng = Angle.normalize(ang0 + angDiffHalf);\n\t\tvar mitreMidAng = Angle.normalize(midAng + Math.PI);\n\t\tvar mitreDist = mitreLimit * distance;\n\t\tvar bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n\t\tvar bevelHalfLen = distance - bevelDelta;\n\t\tvar bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n\t\tvar bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n\t\tvar bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n\t\tvar mitreMidLine = new LineSegment(basePt, bevelMidPt);\n\t\tvar bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n\t\tvar bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n\t\tif (this.side === Position.LEFT) {\n\t\t\tthis.segList.addPt(bevelEndLeft);\n\t\t\tthis.segList.addPt(bevelEndRight);\n\t\t} else {\n\t\t\tthis.segList.addPt(bevelEndRight);\n\t\t\tthis.segList.addPt(bevelEndLeft);\n\t\t}\n\t},\n\tcomputeOffsetSegment: function (seg, side, distance, offset) {\n\t\tvar sideSign = side === Position.LEFT ? 1 : -1;\n\t\tvar dx = seg.p1.x - seg.p0.x;\n\t\tvar dy = seg.p1.y - seg.p0.y;\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\t\tvar ux = sideSign * distance * dx / len;\n\t\tvar uy = sideSign * distance * dy / len;\n\t\toffset.p0.x = seg.p0.x - uy;\n\t\toffset.p0.y = seg.p0.y + ux;\n\t\toffset.p1.x = seg.p1.x - uy;\n\t\toffset.p1.y = seg.p1.y + ux;\n\t},\n\taddFilletArc: function (p, startAngle, endAngle, direction, radius) {\n\t\tvar directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;\n\t\tvar totalAngle = Math.abs(startAngle - endAngle);\n\t\tvar nSegs = Math.trunc(totalAngle / this.filletAngleQuantum + 0.5);\n\t\tif (nSegs < 1) return null;\n\t\tvar initAngle = null, currAngleInc = null;\n\t\tinitAngle = 0.0;\n\t\tcurrAngleInc = totalAngle / nSegs;\n\t\tvar currAngle = initAngle;\n\t\tvar pt = new Coordinate();\n\t\twhile (currAngle < totalAngle) {\n\t\t\tvar angle = startAngle + directionFactor * currAngle;\n\t\t\tpt.x = p.x + radius * Math.cos(angle);\n\t\t\tpt.y = p.y + radius * Math.sin(angle);\n\t\t\tthis.segList.addPt(pt);\n\t\t\tcurrAngle += currAngleInc;\n\t\t}\n\t},\n\taddInsideTurn: function (orientation, addStartPoint) {\n\t\tthis.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1);\n\t\tif (this.li.hasIntersection()) {\n\t\t\tthis.segList.addPt(this.li.getIntersection(0));\n\t\t} else {\n\t\t\tthis._hasNarrowConcaveAngle = true;\n\t\t\tif (this.offset0.p1.distance(this.offset1.p0) < this.distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n\t\t\t\tthis.segList.addPt(this.offset0.p1);\n\t\t\t} else {\n\t\t\t\tthis.segList.addPt(this.offset0.p1);\n\t\t\t\tif (this.closingSegLengthFactor > 0) {\n\t\t\t\t\tvar mid0 = new Coordinate((this.closingSegLengthFactor * this.offset0.p1.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset0.p1.y + this.s1.y) / (this.closingSegLengthFactor + 1));\n\t\t\t\t\tthis.segList.addPt(mid0);\n\t\t\t\t\tvar mid1 = new Coordinate((this.closingSegLengthFactor * this.offset1.p0.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset1.p0.y + this.s1.y) / (this.closingSegLengthFactor + 1));\n\t\t\t\t\tthis.segList.addPt(mid1);\n\t\t\t\t} else {\n\t\t\t\t\tthis.segList.addPt(this.s1);\n\t\t\t\t}\n\t\t\t\tthis.segList.addPt(this.offset1.p0);\n\t\t\t}\n\t\t}\n\t},\n\tcreateCircle: function (p) {\n\t\tvar pt = new Coordinate(p.x + this.distance, p.y);\n\t\tthis.segList.addPt(pt);\n\t\tthis.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this.distance);\n\t\tthis.segList.closeRing();\n\t},\n\taddBevelJoin: function (offset0, offset1) {\n\t\tthis.segList.addPt(offset0.p1);\n\t\tthis.segList.addPt(offset1.p0);\n\t},\n\tinit: function (distance) {\n\t\tthis.distance = distance;\n\t\tthis.maxCurveSegmentError = distance * (1 - Math.cos(this.filletAngleQuantum / 2.0));\n\t\tthis.segList = new OffsetSegmentString();\n\t\tthis.segList.setPrecisionModel(this.precisionModel);\n\t\tthis.segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n\t},\n\taddCollinear: function (addStartPoint) {\n\t\tthis.li.computeIntersection(this.s0, this.s1, this.s1, this.s2);\n\t\tvar numInt = this.li.getIntersectionNum();\n\t\tif (numInt >= 2) {\n\t\t\tif (this.bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this.bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n\t\t\t\tif (addStartPoint) this.segList.addPt(this.offset0.p1);\n\t\t\t\tthis.segList.addPt(this.offset1.p0);\n\t\t\t} else {\n\t\t\t\tthis.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, CGAlgorithms.CLOCKWISE, this.distance);\n\t\t\t}\n\t\t}\n\t},\n\tcloseRing: function () {\n\t\tthis.segList.closeRing();\n\t},\n\thasNarrowConcaveAngle: function () {\n\t\treturn this._hasNarrowConcaveAngle;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OffsetSegmentGenerator;\n\t}\n});\nOffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;\nOffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;\nOffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;\nOffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;\n","import BufferParameters from './BufferParameters';\nimport Position from '../../geomgraph/Position';\nimport Coordinate from '../../geom/Coordinate';\nimport extend from '../../../../../extend';\nimport BufferInputLineSimplifier from './BufferInputLineSimplifier';\nimport CoordinateArrays from '../../geom/CoordinateArrays';\nimport OffsetSegmentGenerator from './OffsetSegmentGenerator';\nexport default function OffsetCurveBuilder() {\n\tthis.distance = 0.0;\n\tthis.precisionModel = null;\n\tthis.bufParams = null;\n\tlet precisionModel = arguments[0], bufParams = arguments[1];\n\tthis.precisionModel = precisionModel;\n\tthis.bufParams = bufParams;\n}\nextend(OffsetCurveBuilder.prototype, {\n\tgetOffsetCurve: function (inputPts, distance) {\n\t\tthis.distance = distance;\n\t\tif (distance === 0.0) return null;\n\t\tvar isRightSide = distance < 0.0;\n\t\tvar posDistance = Math.abs(distance);\n\t\tvar segGen = this.getSegGen(posDistance);\n\t\tif (inputPts.length <= 1) {\n\t\t\tthis.computePointCurve(inputPts[0], segGen);\n\t\t} else {\n\t\t\tthis.computeOffsetCurve(inputPts, isRightSide, segGen);\n\t\t}\n\t\tvar curvePts = segGen.getCoordinates();\n\t\tif (isRightSide) CoordinateArrays.reverse(curvePts);\n\t\treturn curvePts;\n\t},\n\tcomputeSingleSidedBufferCurve: function (inputPts, isRightSide, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this.distance);\n\t\tif (isRightSide) {\n\t\t\tsegGen.addSegments(inputPts, true);\n\t\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n\t\t\tvar n2 = simp2.length - 1;\n\t\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = n2 - 2; i >= 0; i--) {\n\t\t\t\tsegGen.addNextSegment(simp2[i], true);\n\t\t\t}\n\t\t} else {\n\t\t\tsegGen.addSegments(inputPts, false);\n\t\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\t\tvar n1 = simp1.length - 1;\n\t\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = 2; i <= n1; i++) {\n\t\t\t\tsegGen.addNextSegment(simp1[i], true);\n\t\t\t}\n\t\t}\n\t\tsegGen.addLastSegment();\n\t\tsegGen.closeRing();\n\t},\n\tcomputeRingBufferCurve: function (inputPts, side, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this.distance);\n\t\tif (side === Position.RIGHT) distTol = -distTol;\n\t\tvar simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\tvar n = simp.length - 1;\n\t\tsegGen.initSideSegments(simp[n - 1], simp[0], side);\n\t\tfor (var i = 1; i <= n; i++) {\n\t\t\tvar addStartPoint = i !== 1;\n\t\t\tsegGen.addNextSegment(simp[i], addStartPoint);\n\t\t}\n\t\tsegGen.closeRing();\n\t},\n\tcomputeLineBufferCurve: function (inputPts, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this.distance);\n\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\tvar n1 = simp1.length - 1;\n\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\t\tfor (var i = 2; i <= n1; i++) {\n\t\t\tsegGen.addNextSegment(simp1[i], true);\n\t\t}\n\t\tsegGen.addLastSegment();\n\t\tsegGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n\t\tvar n2 = simp2.length - 1;\n\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\t\tfor (var i = n2 - 2; i >= 0; i--) {\n\t\t\tsegGen.addNextSegment(simp2[i], true);\n\t\t}\n\t\tsegGen.addLastSegment();\n\t\tsegGen.addLineEndCap(simp2[1], simp2[0]);\n\t\tsegGen.closeRing();\n\t},\n\tcomputePointCurve: function (pt, segGen) {\n\t\tswitch (this.bufParams.getEndCapStyle()) {\n\t\t\tcase BufferParameters.CAP_ROUND:\n\t\t\t\tsegGen.createCircle(pt);\n\t\t\t\tbreak;\n\t\t\tcase BufferParameters.CAP_SQUARE:\n\t\t\t\tsegGen.createSquare(pt);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\tgetLineCurve: function (inputPts, distance) {\n\t\tthis.distance = distance;\n\t\tif (distance < 0.0 && !this.bufParams.isSingleSided()) return null;\n\t\tif (distance === 0.0) return null;\n\t\tvar posDistance = Math.abs(distance);\n\t\tvar segGen = this.getSegGen(posDistance);\n\t\tif (inputPts.length <= 1) {\n\t\t\tthis.computePointCurve(inputPts[0], segGen);\n\t\t} else {\n\t\t\tif (this.bufParams.isSingleSided()) {\n\t\t\t\tvar isRightSide = distance < 0.0;\n\t\t\t\tthis.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n\t\t\t} else this.computeLineBufferCurve(inputPts, segGen);\n\t\t}\n\t\tvar lineCoord = segGen.getCoordinates();\n\t\treturn lineCoord;\n\t},\n\tgetBufferParameters: function () {\n\t\treturn this.bufParams;\n\t},\n\tsimplifyTolerance: function (bufDistance) {\n\t\treturn bufDistance * this.bufParams.getSimplifyFactor();\n\t},\n\tgetRingCurve: function (inputPts, side, distance) {\n\t\tthis.distance = distance;\n\t\tif (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);\n\t\tif (distance === 0.0) {\n\t\t\treturn OffsetCurveBuilder.copyCoordinates(inputPts);\n\t\t}\n\t\tvar segGen = this.getSegGen(distance);\n\t\tthis.computeRingBufferCurve(inputPts, side, segGen);\n\t\treturn segGen.getCoordinates();\n\t},\n\tcomputeOffsetCurve: function (inputPts, isRightSide, segGen) {\n\t\tvar distTol = this.simplifyTolerance(this.distance);\n\t\tif (isRightSide) {\n\t\t\tvar simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n\t\t\tvar n2 = simp2.length - 1;\n\t\t\tsegGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = n2 - 2; i >= 0; i--) {\n\t\t\t\tsegGen.addNextSegment(simp2[i], true);\n\t\t\t}\n\t\t} else {\n\t\t\tvar simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n\t\t\tvar n1 = simp1.length - 1;\n\t\t\tsegGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\t\t\tsegGen.addFirstSegment();\n\t\t\tfor (var i = 2; i <= n1; i++) {\n\t\t\t\tsegGen.addNextSegment(simp1[i], true);\n\t\t\t}\n\t\t}\n\t\tsegGen.addLastSegment();\n\t},\n\tgetSegGen: function (distance) {\n\t\treturn new OffsetSegmentGenerator(this.precisionModel, this.bufParams, distance);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OffsetCurveBuilder;\n\t}\n});\nOffsetCurveBuilder.copyCoordinates = function (pts) {\n\tvar copy = new Array(pts.length).fill(null);\n\tfor (var i = 0; i < copy.length; i++) {\n\t\tcopy[i] = new Coordinate(pts[i]);\n\t}\n\treturn copy;\n};\n","import CGAlgorithms from '../../algorithm/CGAlgorithms';\nimport hasInterface from '../../../../../hasInterface';\nimport Position from '../../geomgraph/Position';\nimport Coordinate from '../../geom/Coordinate';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport DirectedEdge from '../../geomgraph/DirectedEdge';\nimport LineSegment from '../../geom/LineSegment';\nimport Comparable from '../../../../../java/lang/Comparable';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport List from '../../../../../java/util/List';\nexport default function SubgraphDepthLocater() {\n\tthis.subgraphs = null;\n\tthis.seg = new LineSegment();\n\tthis.cga = new CGAlgorithms();\n\tlet subgraphs = arguments[0];\n\tthis.subgraphs = subgraphs;\n}\nextend(SubgraphDepthLocater.prototype, {\n\tfindStabbedSegments: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet stabbingRayLeftPt = arguments[0];\n\t\t\tvar stabbedSegments = new ArrayList();\n\t\t\tfor (var i = this.subgraphs.iterator(); i.hasNext(); ) {\n\t\t\t\tvar bsg = i.next();\n\t\t\t\tvar env = bsg.getEnvelope();\n\t\t\t\tif (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;\n\t\t\t\tthis.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n\t\t\t}\n\t\t\treturn stabbedSegments;\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {\n\t\t\t\tlet stabbingRayLeftPt = arguments[0], dirEdge = arguments[1], stabbedSegments = arguments[2];\n\t\t\t\tvar pts = dirEdge.getEdge().getCoordinates();\n\t\t\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\t\t\tthis.seg.p0 = pts[i];\n\t\t\t\t\tthis.seg.p1 = pts[i + 1];\n\t\t\t\t\tif (this.seg.p0.y > this.seg.p1.y) this.seg.reverse();\n\t\t\t\t\tvar maxx = Math.max(this.seg.p0.x, this.seg.p1.x);\n\t\t\t\t\tif (maxx < stabbingRayLeftPt.x) continue;\n\t\t\t\t\tif (this.seg.isHorizontal()) continue;\n\t\t\t\t\tif (stabbingRayLeftPt.y < this.seg.p0.y || stabbingRayLeftPt.y > this.seg.p1.y) continue;\n\t\t\t\t\tif (CGAlgorithms.computeOrientation(this.seg.p0, this.seg.p1, stabbingRayLeftPt) === CGAlgorithms.RIGHT) continue;\n\t\t\t\t\tvar depth = dirEdge.getDepth(Position.LEFT);\n\t\t\t\t\tif (!this.seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT);\n\t\t\t\t\tvar ds = new DepthSegment(this.seg, depth);\n\t\t\t\t\tstabbedSegments.add(ds);\n\t\t\t\t}\n\t\t\t} else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {\n\t\t\t\tlet stabbingRayLeftPt = arguments[0], dirEdges = arguments[1], stabbedSegments = arguments[2];\n\t\t\t\tfor (var i = dirEdges.iterator(); i.hasNext(); ) {\n\t\t\t\t\tvar de = i.next();\n\t\t\t\t\tif (!de.isForward()) continue;\n\t\t\t\t\tthis.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetDepth: function (p) {\n\t\tvar stabbedSegments = this.findStabbedSegments(p);\n\t\tif (stabbedSegments.size() === 0) return 0;\n\t\tvar ds = Collections.min(stabbedSegments);\n\t\treturn ds.leftDepth;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SubgraphDepthLocater;\n\t}\n});\nfunction DepthSegment() {\n\tthis.upwardSeg = null;\n\tthis.leftDepth = null;\n\tlet seg = arguments[0], depth = arguments[1];\n\tthis.upwardSeg = new LineSegment(seg);\n\tthis.leftDepth = depth;\n}\nextend(DepthSegment.prototype, {\n\tcompareTo: function (obj) {\n\t\tvar other = obj;\n\t\tif (this.upwardSeg.minX() >= other.upwardSeg.maxX()) return 1;\n\t\tif (this.upwardSeg.maxX() <= other.upwardSeg.minX()) return -1;\n\t\tvar orientIndex = this.upwardSeg.orientationIndex(other.upwardSeg);\n\t\tif (orientIndex !== 0) return orientIndex;\n\t\torientIndex = -1 * other.upwardSeg.orientationIndex(this.upwardSeg);\n\t\tif (orientIndex !== 0) return orientIndex;\n\t\treturn this.upwardSeg.compareTo(other.upwardSeg);\n\t},\n\tcompareX: function (seg0, seg1) {\n\t\tvar compare0 = seg0.p0.compareTo(seg1.p0);\n\t\tif (compare0 !== 0) return compare0;\n\t\treturn seg0.p1.compareTo(seg1.p1);\n\t},\n\ttoString: function () {\n\t\treturn this.upwardSeg.toString();\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn DepthSegment;\n\t}\n});\nSubgraphDepthLocater.DepthSegment = DepthSegment;\n","import Location from '../../geom/Location';\nimport LineString from '../../geom/LineString';\nimport CGAlgorithms from '../../algorithm/CGAlgorithms';\nimport Position from '../../geomgraph/Position';\nimport Point from '../../geom/Point';\nimport NodedSegmentString from '../../noding/NodedSegmentString';\nimport Polygon from '../../geom/Polygon';\nimport MultiPoint from '../../geom/MultiPoint';\nimport LinearRing from '../../geom/LinearRing';\nimport extend from '../../../../../extend';\nimport MultiPolygon from '../../geom/MultiPolygon';\nimport Label from '../../geomgraph/Label';\nimport GeometryCollection from '../../geom/GeometryCollection';\nimport CoordinateArrays from '../../geom/CoordinateArrays';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport MultiLineString from '../../geom/MultiLineString';\nimport Triangle from '../../geom/Triangle';\nexport default function OffsetCurveSetBuilder() {\n\tthis.inputGeom = null;\n\tthis.distance = null;\n\tthis.curveBuilder = null;\n\tthis.curveList = new ArrayList();\n\tlet inputGeom = arguments[0], distance = arguments[1], curveBuilder = arguments[2];\n\tthis.inputGeom = inputGeom;\n\tthis.distance = distance;\n\tthis.curveBuilder = curveBuilder;\n}\nextend(OffsetCurveSetBuilder.prototype, {\n\taddPoint: function (p) {\n\t\tif (this.distance <= 0.0) return null;\n\t\tvar coord = p.getCoordinates();\n\t\tvar curve = this.curveBuilder.getLineCurve(coord, this.distance);\n\t\tthis.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n\t},\n\taddPolygon: function (p) {\n\t\tvar offsetDistance = this.distance;\n\t\tvar offsetSide = Position.LEFT;\n\t\tif (this.distance < 0.0) {\n\t\t\toffsetDistance = -this.distance;\n\t\t\toffsetSide = Position.RIGHT;\n\t\t}\n\t\tvar shell = p.getExteriorRing();\n\t\tvar shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n\t\tif (this.distance < 0.0 && this.isErodedCompletely(shell, this.distance)) return null;\n\t\tif (this.distance <= 0.0 && shellCoord.length < 3) return null;\n\t\tthis.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tvar holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n\t\t\tif (this.distance > 0.0 && this.isErodedCompletely(hole, -this.distance)) continue;\n\t\t\tthis.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n\t\t}\n\t},\n\tisTriangleErodedCompletely: function (triangleCoord, bufferDistance) {\n\t\tvar tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n\t\tvar inCentre = tri.inCentre();\n\t\tvar distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);\n\t\treturn distToCentre < Math.abs(bufferDistance);\n\t},\n\taddLineString: function (line) {\n\t\tif (this.distance <= 0.0 && !this.curveBuilder.getBufferParameters().isSingleSided()) return null;\n\t\tvar coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tvar curve = this.curveBuilder.getLineCurve(coord, this.distance);\n\t\tthis.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n\t},\n\taddCurve: function (coord, leftLoc, rightLoc) {\n\t\tif (coord === null || coord.length < 2) return null;\n\t\tvar e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n\t\tthis.curveList.add(e);\n\t},\n\tgetCurves: function () {\n\t\tthis.add(this.inputGeom);\n\t\treturn this.curveList;\n\t},\n\taddPolygonRing: function (coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n\t\tif (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null;\n\t\tvar leftLoc = cwLeftLoc;\n\t\tvar rightLoc = cwRightLoc;\n\t\tif (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {\n\t\t\tleftLoc = cwRightLoc;\n\t\t\trightLoc = cwLeftLoc;\n\t\t\tside = Position.opposite(side);\n\t\t}\n\t\tvar curve = this.curveBuilder.getRingCurve(coord, side, offsetDistance);\n\t\tthis.addCurve(curve, leftLoc, rightLoc);\n\t},\n\tadd: function (g) {\n\t\tif (g.isEmpty()) return null;\n\t\tif (g instanceof Polygon) this.addPolygon(g); else if (g instanceof LineString) this.addLineString(g); else if (g instanceof Point) this.addPoint(g); else if (g instanceof MultiPoint) this.addCollection(g); else if (g instanceof MultiLineString) this.addCollection(g); else if (g instanceof MultiPolygon) this.addCollection(g); else if (g instanceof GeometryCollection) this.addCollection(g); else throw new UnsupportedOperationException(g.getClass().getName());\n\t},\n\tisErodedCompletely: function (ring, bufferDistance) {\n\t\tvar ringCoord = ring.getCoordinates();\n\t\tvar minDiam = 0.0;\n\t\tif (ringCoord.length < 4) return bufferDistance < 0;\n\t\tif (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);\n\t\tvar env = ring.getEnvelopeInternal();\n\t\tvar envMinDimension = Math.min(env.getHeight(), env.getWidth());\n\t\tif (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;\n\t\treturn false;\n\t},\n\taddCollection: function (gc) {\n\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\tvar g = gc.getGeometryN(i);\n\t\t\tthis.add(g);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn OffsetCurveSetBuilder;\n\t}\n});\n","import extend from '../../../../extend';\nimport SegmentIntersector from './SegmentIntersector';\nexport default function IntersectionAdder() {\n\tthis._hasIntersection = false;\n\tthis.hasProper = false;\n\tthis.hasProperInterior = false;\n\tthis.hasInterior = false;\n\tthis.properIntersectionPoint = null;\n\tthis.li = null;\n\tthis.isSelfIntersection = null;\n\tthis.numIntersections = 0;\n\tthis.numInteriorIntersections = 0;\n\tthis.numProperIntersections = 0;\n\tthis.numTests = 0;\n\tlet li = arguments[0];\n\tthis.li = li;\n}\nextend(IntersectionAdder.prototype, {\n\tisTrivialIntersection: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1) {\n\t\t\tif (this.li.getIntersectionNum() === 1) {\n\t\t\t\tif (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\t\t\t\tif (e0.isClosed()) {\n\t\t\t\t\tvar maxSegIndex = e0.size() - 1;\n\t\t\t\t\tif (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetProperIntersectionPoint: function () {\n\t\treturn this.properIntersectionPoint;\n\t},\n\thasProperInteriorIntersection: function () {\n\t\treturn this.hasProperInterior;\n\t},\n\tgetLineIntersector: function () {\n\t\treturn this.li;\n\t},\n\thasProperIntersection: function () {\n\t\treturn this.hasProper;\n\t},\n\tprocessIntersections: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tthis.numTests++;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis.li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this.li.hasIntersection()) {\n\t\t\tthis.numIntersections++;\n\t\t\tif (this.li.isInteriorIntersection()) {\n\t\t\t\tthis.numInteriorIntersections++;\n\t\t\t\tthis.hasInterior = true;\n\t\t\t}\n\t\t\tif (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n\t\t\t\tthis._hasIntersection = true;\n\t\t\t\te0.addIntersections(this.li, segIndex0, 0);\n\t\t\t\te1.addIntersections(this.li, segIndex1, 1);\n\t\t\t\tif (this.li.isProper()) {\n\t\t\t\t\tthis.numProperIntersections++;\n\t\t\t\t\tthis.hasProper = true;\n\t\t\t\t\tthis.hasProperInterior = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\thasIntersection: function () {\n\t\treturn this._hasIntersection;\n\t},\n\tisDone: function () {\n\t\treturn false;\n\t},\n\thasInteriorIntersection: function () {\n\t\treturn this.hasInterior;\n\t},\n\tinterfaces_: function () {\n\t\treturn [SegmentIntersector];\n\t},\n\tgetClass: function () {\n\t\treturn IntersectionAdder;\n\t}\n});\nIntersectionAdder.isAdjacentSegments = function (i1, i2) {\n\treturn Math.abs(i1 - i2) === 1;\n};\n","import Location from '../../geom/Location';\nimport BufferSubgraph from './BufferSubgraph';\nimport PolygonBuilder from '../overlay/PolygonBuilder';\nimport GeometryFactory from '../../geom/GeometryFactory';\nimport Position from '../../geomgraph/Position';\nimport MCIndexNoder from '../../noding/MCIndexNoder';\nimport OffsetCurveBuilder from './OffsetCurveBuilder';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport SubgraphDepthLocater from './SubgraphDepthLocater';\nimport OffsetCurveSetBuilder from './OffsetCurveSetBuilder';\nimport Label from '../../geomgraph/Label';\nimport OverlayNodeFactory from '../overlay/OverlayNodeFactory';\nimport EdgeList from '../../geomgraph/EdgeList';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport IntersectionAdder from '../../noding/IntersectionAdder';\nimport Edge from '../../geomgraph/Edge';\nimport PlanarGraph from '../../geomgraph/PlanarGraph';\nexport default function BufferBuilder() {\n\tthis.bufParams = null;\n\tthis.workingPrecisionModel = null;\n\tthis.workingNoder = null;\n\tthis.geomFact = null;\n\tthis.graph = null;\n\tthis.edgeList = new EdgeList();\n\tlet bufParams = arguments[0];\n\tthis.bufParams = bufParams;\n}\nextend(BufferBuilder.prototype, {\n\tsetWorkingPrecisionModel: function (pm) {\n\t\tthis.workingPrecisionModel = pm;\n\t},\n\tinsertUniqueEdge: function (e) {\n\t\tvar existingEdge = this.edgeList.findEqualEdge(e);\n\t\tif (existingEdge !== null) {\n\t\t\tvar existingLabel = existingEdge.getLabel();\n\t\t\tvar labelToMerge = e.getLabel();\n\t\t\tif (!existingEdge.isPointwiseEqual(e)) {\n\t\t\t\tlabelToMerge = new Label(e.getLabel());\n\t\t\t\tlabelToMerge.flip();\n\t\t\t}\n\t\t\texistingLabel.merge(labelToMerge);\n\t\t\tvar mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n\t\t\tvar existingDelta = existingEdge.getDepthDelta();\n\t\t\tvar newDelta = existingDelta + mergeDelta;\n\t\t\texistingEdge.setDepthDelta(newDelta);\n\t\t} else {\n\t\t\tthis.edgeList.add(e);\n\t\t\te.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n\t\t}\n\t},\n\tbuildSubgraphs: function (subgraphList, polyBuilder) {\n\t\tvar processedGraphs = new ArrayList();\n\t\tfor (var i = subgraphList.iterator(); i.hasNext(); ) {\n\t\t\tvar subgraph = i.next();\n\t\t\tvar p = subgraph.getRightmostCoordinate();\n\t\t\tvar locater = new SubgraphDepthLocater(processedGraphs);\n\t\t\tvar outsideDepth = locater.getDepth(p);\n\t\t\tsubgraph.computeDepth(outsideDepth);\n\t\t\tsubgraph.findResultEdges();\n\t\t\tprocessedGraphs.add(subgraph);\n\t\t\tpolyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n\t\t}\n\t},\n\tcreateSubgraphs: function (graph) {\n\t\tvar subgraphList = new ArrayList();\n\t\tfor (var i = graph.getNodes().iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tif (!node.isVisited()) {\n\t\t\t\tvar subgraph = new BufferSubgraph();\n\t\t\t\tsubgraph.create(node);\n\t\t\t\tsubgraphList.add(subgraph);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(subgraphList, Collections.reverseOrder());\n\t\treturn subgraphList;\n\t},\n\tcreateEmptyResultGeometry: function () {\n\t\tvar emptyGeom = this.geomFact.createPolygon();\n\t\treturn emptyGeom;\n\t},\n\tgetNoder: function (precisionModel) {\n\t\tif (this.workingNoder !== null) return this.workingNoder;\n\t\tvar noder = new MCIndexNoder();\n\t\tvar li = new RobustLineIntersector();\n\t\tli.setPrecisionModel(precisionModel);\n\t\tnoder.setSegmentIntersector(new IntersectionAdder(li));\n\t\treturn noder;\n\t},\n\tbuffer: function (g, distance) {\n\t\tvar precisionModel = this.workingPrecisionModel;\n\t\tif (precisionModel === null) precisionModel = g.getPrecisionModel();\n\t\tthis.geomFact = g.getFactory();\n\t\tvar curveBuilder = new OffsetCurveBuilder(precisionModel, this.bufParams);\n\t\tvar curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n\t\tvar bufferSegStrList = curveSetBuilder.getCurves();\n\t\tif (bufferSegStrList.size() <= 0) {\n\t\t\treturn this.createEmptyResultGeometry();\n\t\t}\n\t\tthis.computeNodedEdges(bufferSegStrList, precisionModel);\n\t\tthis.graph = new PlanarGraph(new OverlayNodeFactory());\n\t\tthis.graph.addEdges(this.edgeList.getEdges());\n\t\tvar subgraphList = this.createSubgraphs(this.graph);\n\t\tvar polyBuilder = new PolygonBuilder(this.geomFact);\n\t\tthis.buildSubgraphs(subgraphList, polyBuilder);\n\t\tvar resultPolyList = polyBuilder.getPolygons();\n\t\tif (resultPolyList.size() <= 0) {\n\t\t\treturn this.createEmptyResultGeometry();\n\t\t}\n\t\tvar resultGeom = this.geomFact.buildGeometry(resultPolyList);\n\t\treturn resultGeom;\n\t},\n\tcomputeNodedEdges: function (bufferSegStrList, precisionModel) {\n\t\tvar noder = this.getNoder(precisionModel);\n\t\tnoder.computeNodes(bufferSegStrList);\n\t\tvar nodedSegStrings = noder.getNodedSubstrings();\n\t\tfor (var i = nodedSegStrings.iterator(); i.hasNext(); ) {\n\t\t\tvar segStr = i.next();\n\t\t\tvar pts = segStr.getCoordinates();\n\t\t\tif (pts.length === 2 && pts[0].equals2D(pts[1])) continue;\n\t\t\tvar oldLabel = segStr.getData();\n\t\t\tvar edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n\t\t\tthis.insertUniqueEdge(edge);\n\t\t}\n\t},\n\tsetNoder: function (noder) {\n\t\tthis.workingNoder = noder;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BufferBuilder;\n\t}\n});\nBufferBuilder.depthDelta = function (label) {\n\tvar lLoc = label.getLocation(0, Position.LEFT);\n\tvar rLoc = label.getLocation(0, Position.RIGHT);\n\tif (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1; else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1;\n\treturn 0;\n};\nBufferBuilder.convertSegStrings = function (it) {\n\tvar fact = new GeometryFactory();\n\tvar lines = new ArrayList();\n\twhile (it.hasNext()) {\n\t\tvar ss = it.next();\n\t\tvar line = fact.createLineString(ss.getCoordinates());\n\t\tlines.add(line);\n\t}\n\treturn fact.buildGeometry(lines);\n};\n","import GeometryFactory from '../geom/GeometryFactory';\nimport extend from '../../../../extend';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nimport RuntimeException from '../../../../java/lang/RuntimeException';\nexport default function NodingValidator() {\n\tthis.li = new RobustLineIntersector();\n\tthis.segStrings = null;\n\tlet segStrings = arguments[0];\n\tthis.segStrings = segStrings;\n}\nextend(NodingValidator.prototype, {\n\tcheckEndPtVertexIntersections: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = this.segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tvar pts = ss.getCoordinates();\n\t\t\t\tthis.checkEndPtVertexIntersections(pts[0], this.segStrings);\n\t\t\t\tthis.checkEndPtVertexIntersections(pts[pts.length - 1], this.segStrings);\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet testPt = arguments[0], segStrings = arguments[1];\n\t\t\tfor (var i = segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tvar pts = ss.getCoordinates();\n\t\t\t\tfor (var j = 1; j < pts.length - 1; j++) {\n\t\t\t\t\tif (pts[j].equals(testPt)) throw new RuntimeException(\"found endpt/interior pt intersection at index \" + j + \" :pt \" + testPt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcheckInteriorIntersections: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = this.segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss0 = i.next();\n\t\t\t\tfor (var j = this.segStrings.iterator(); j.hasNext(); ) {\n\t\t\t\t\tvar ss1 = j.next();\n\t\t\t\t\tthis.checkInteriorIntersections(ss0, ss1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet ss0 = arguments[0], ss1 = arguments[1];\n\t\t\tvar pts0 = ss0.getCoordinates();\n\t\t\tvar pts1 = ss1.getCoordinates();\n\t\t\tfor (var i0 = 0; i0 < pts0.length - 1; i0++) {\n\t\t\t\tfor (var i1 = 0; i1 < pts1.length - 1; i1++) {\n\t\t\t\t\tthis.checkInteriorIntersections(ss0, i0, ss1, i1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 4) {\n\t\t\tlet e0 = arguments[0], segIndex0 = arguments[1], e1 = arguments[2], segIndex1 = arguments[3];\n\t\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\t\tthis.li.computeIntersection(p00, p01, p10, p11);\n\t\t\tif (this.li.hasIntersection()) {\n\t\t\t\tif (this.li.isProper() || this.hasInteriorIntersection(this.li, p00, p01) || this.hasInteriorIntersection(this.li, p10, p11)) {\n\t\t\t\t\tthrow new RuntimeException(\"found non-noded intersection at \" + p00 + \"-\" + p01 + \" and \" + p10 + \"-\" + p11);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcheckValid: function () {\n\t\tthis.checkEndPtVertexIntersections();\n\t\tthis.checkInteriorIntersections();\n\t\tthis.checkCollapses();\n\t},\n\tcheckCollapses: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var i = this.segStrings.iterator(); i.hasNext(); ) {\n\t\t\t\tvar ss = i.next();\n\t\t\t\tthis.checkCollapses(ss);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet ss = arguments[0];\n\t\t\tvar pts = ss.getCoordinates();\n\t\t\tfor (var i = 0; i < pts.length - 2; i++) {\n\t\t\t\tthis.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);\n\t\t\t}\n\t\t}\n\t},\n\thasInteriorIntersection: function (li, p0, p1) {\n\t\tfor (var i = 0; i < li.getIntersectionNum(); i++) {\n\t\t\tvar intPt = li.getIntersection(i);\n\t\t\tif (!(intPt.equals(p0) || intPt.equals(p1))) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tcheckCollapse: function (p0, p1, p2) {\n\t\tif (p0.equals(p2)) throw new RuntimeException(\"found non-noded collapse at \" + NodingValidator.fact.createLineString([p0, p1, p2]));\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NodingValidator;\n\t}\n});\nNodingValidator.fact = new GeometryFactory();\n","import Coordinate from '../../geom/Coordinate';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../../extend';\nimport Envelope from '../../geom/Envelope';\nimport Assert from '../../util/Assert';\nexport default function HotPixel() {\n\tthis.li = null;\n\tthis.pt = null;\n\tthis.originalPt = null;\n\tthis.ptScaled = null;\n\tthis.p0Scaled = null;\n\tthis.p1Scaled = null;\n\tthis.scaleFactor = null;\n\tthis.minx = null;\n\tthis.maxx = null;\n\tthis.miny = null;\n\tthis.maxy = null;\n\tthis.corner = new Array(4).fill(null);\n\tthis.safeEnv = null;\n\tlet pt = arguments[0], scaleFactor = arguments[1], li = arguments[2];\n\tthis.originalPt = pt;\n\tthis.pt = pt;\n\tthis.scaleFactor = scaleFactor;\n\tthis.li = li;\n\tif (scaleFactor <= 0) throw new IllegalArgumentException(\"Scale factor must be non-zero\");\n\tif (scaleFactor !== 1.0) {\n\t\tthis.pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n\t\tthis.p0Scaled = new Coordinate();\n\t\tthis.p1Scaled = new Coordinate();\n\t}\n\tthis.initCorners(this.pt);\n}\nextend(HotPixel.prototype, {\n\tintersectsScaled: function (p0, p1) {\n\t\tvar segMinx = Math.min(p0.x, p1.x);\n\t\tvar segMaxx = Math.max(p0.x, p1.x);\n\t\tvar segMiny = Math.min(p0.y, p1.y);\n\t\tvar segMaxy = Math.max(p0.y, p1.y);\n\t\tvar isOutsidePixelEnv = this.maxx < segMinx || this.minx > segMaxx || this.maxy < segMiny || this.miny > segMaxy;\n\t\tif (isOutsidePixelEnv) return false;\n\t\tvar intersects = this.intersectsToleranceSquare(p0, p1);\n\t\tAssert.isTrue(!(isOutsidePixelEnv && intersects), \"Found bad envelope test\");\n\t\treturn intersects;\n\t},\n\tinitCorners: function (pt) {\n\t\tvar tolerance = 0.5;\n\t\tthis.minx = pt.x - tolerance;\n\t\tthis.maxx = pt.x + tolerance;\n\t\tthis.miny = pt.y - tolerance;\n\t\tthis.maxy = pt.y + tolerance;\n\t\tthis.corner[0] = new Coordinate(this.maxx, this.maxy);\n\t\tthis.corner[1] = new Coordinate(this.minx, this.maxy);\n\t\tthis.corner[2] = new Coordinate(this.minx, this.miny);\n\t\tthis.corner[3] = new Coordinate(this.maxx, this.miny);\n\t},\n\tintersects: function (p0, p1) {\n\t\tif (this.scaleFactor === 1.0) return this.intersectsScaled(p0, p1);\n\t\tthis.copyScaled(p0, this.p0Scaled);\n\t\tthis.copyScaled(p1, this.p1Scaled);\n\t\treturn this.intersectsScaled(this.p0Scaled, this.p1Scaled);\n\t},\n\tscale: function (val) {\n\t\treturn Math.round(val * this.scaleFactor);\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.originalPt;\n\t},\n\tcopyScaled: function (p, pScaled) {\n\t\tpScaled.x = this.scale(p.x);\n\t\tpScaled.y = this.scale(p.y);\n\t},\n\tgetSafeEnvelope: function () {\n\t\tif (this.safeEnv === null) {\n\t\t\tvar safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this.scaleFactor;\n\t\t\tthis.safeEnv = new Envelope(this.originalPt.x - safeTolerance, this.originalPt.x + safeTolerance, this.originalPt.y - safeTolerance, this.originalPt.y + safeTolerance);\n\t\t}\n\t\treturn this.safeEnv;\n\t},\n\tintersectsPixelClosure: function (p0, p1) {\n\t\tthis.li.computeIntersection(p0, p1, this.corner[0], this.corner[1]);\n\t\tif (this.li.hasIntersection()) return true;\n\t\tthis.li.computeIntersection(p0, p1, this.corner[1], this.corner[2]);\n\t\tif (this.li.hasIntersection()) return true;\n\t\tthis.li.computeIntersection(p0, p1, this.corner[2], this.corner[3]);\n\t\tif (this.li.hasIntersection()) return true;\n\t\tthis.li.computeIntersection(p0, p1, this.corner[3], this.corner[0]);\n\t\tif (this.li.hasIntersection()) return true;\n\t\treturn false;\n\t},\n\tintersectsToleranceSquare: function (p0, p1) {\n\t\tvar intersectsLeft = false;\n\t\tvar intersectsBottom = false;\n\t\tthis.li.computeIntersection(p0, p1, this.corner[0], this.corner[1]);\n\t\tif (this.li.isProper()) return true;\n\t\tthis.li.computeIntersection(p0, p1, this.corner[1], this.corner[2]);\n\t\tif (this.li.isProper()) return true;\n\t\tif (this.li.hasIntersection()) intersectsLeft = true;\n\t\tthis.li.computeIntersection(p0, p1, this.corner[2], this.corner[3]);\n\t\tif (this.li.isProper()) return true;\n\t\tif (this.li.hasIntersection()) intersectsBottom = true;\n\t\tthis.li.computeIntersection(p0, p1, this.corner[3], this.corner[0]);\n\t\tif (this.li.isProper()) return true;\n\t\tif (intersectsLeft && intersectsBottom) return true;\n\t\tif (p0.equals(this.pt)) return true;\n\t\tif (p1.equals(this.pt)) return true;\n\t\treturn false;\n\t},\n\taddSnappedNode: function (segStr, segIndex) {\n\t\tvar p0 = segStr.getCoordinate(segIndex);\n\t\tvar p1 = segStr.getCoordinate(segIndex + 1);\n\t\tif (this.intersects(p0, p1)) {\n\t\t\tsegStr.addIntersection(this.getCoordinate(), segIndex);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn HotPixel;\n\t}\n});\nHotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;\n","import MonotoneChainSelectAction from '../../index/chain/MonotoneChainSelectAction';\nimport ItemVisitor from '../../index/ItemVisitor';\nimport extend from '../../../../../extend';\nimport inherits from '../../../../../inherits';\nexport default function MCIndexPointSnapper() {\n\tthis.index = null;\n\tlet index = arguments[0];\n\tthis.index = index;\n}\nextend(MCIndexPointSnapper.prototype, {\n\tsnap: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet hotPixel = arguments[0];\n\t\t\treturn this.snap(hotPixel, null, -1);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2];\n\t\t\tvar pixelEnv = hotPixel.getSafeEnvelope();\n\t\t\tvar hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);\n\t\t\tthis.index.query(pixelEnv, {\n\t\t\t\tinterfaces_: function () {\n\t\t\t\t\treturn [ItemVisitor];\n\t\t\t\t},\n\t\t\t\tvisitItem: function (item) {\n\t\t\t\t\tvar testChain = item;\n\t\t\t\t\ttestChain.select(pixelEnv, hotPixelSnapAction);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn hotPixelSnapAction.isNodeAdded();\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn MCIndexPointSnapper;\n\t}\n});\nfunction HotPixelSnapAction() {\n\tMonotoneChainSelectAction.apply(this);\n\tthis.hotPixel = null;\n\tthis.parentEdge = null;\n\tthis.hotPixelVertexIndex = null;\n\tthis._isNodeAdded = false;\n\tlet hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2];\n\tthis.hotPixel = hotPixel;\n\tthis.parentEdge = parentEdge;\n\tthis.hotPixelVertexIndex = hotPixelVertexIndex;\n}\ninherits(HotPixelSnapAction, MonotoneChainSelectAction);\nextend(HotPixelSnapAction.prototype, {\n\tisNodeAdded: function () {\n\t\treturn this._isNodeAdded;\n\t},\n\tselect: function () {\n\t\tif (arguments.length === 2) {\n\t\t\tlet mc = arguments[0], startIndex = arguments[1];\n\t\t\tvar ss = mc.getContext();\n\t\t\tif (this.parentEdge !== null) {\n\t\t\t\tif (ss === this.parentEdge && startIndex === this.hotPixelVertexIndex) return null;\n\t\t\t}\n\t\t\tthis._isNodeAdded = this.hotPixel.addSnappedNode(ss, startIndex);\n\t\t} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn HotPixelSnapAction;\n\t}\n});\nMCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;\n","import extend from '../../../../extend';\nimport SegmentIntersector from './SegmentIntersector';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function InteriorIntersectionFinderAdder() {\n\tthis.li = null;\n\tthis.interiorIntersections = null;\n\tlet li = arguments[0];\n\tthis.li = li;\n\tthis.interiorIntersections = new ArrayList();\n}\nextend(InteriorIntersectionFinderAdder.prototype, {\n\tprocessIntersections: function (e0, segIndex0, e1, segIndex1) {\n\t\tif (e0 === e1 && segIndex0 === segIndex1) return null;\n\t\tvar p00 = e0.getCoordinates()[segIndex0];\n\t\tvar p01 = e0.getCoordinates()[segIndex0 + 1];\n\t\tvar p10 = e1.getCoordinates()[segIndex1];\n\t\tvar p11 = e1.getCoordinates()[segIndex1 + 1];\n\t\tthis.li.computeIntersection(p00, p01, p10, p11);\n\t\tif (this.li.hasIntersection()) {\n\t\t\tif (this.li.isInteriorIntersection()) {\n\t\t\t\tfor (var intIndex = 0; intIndex < this.li.getIntersectionNum(); intIndex++) {\n\t\t\t\t\tthis.interiorIntersections.add(this.li.getIntersection(intIndex));\n\t\t\t\t}\n\t\t\t\te0.addIntersections(this.li, segIndex0, 0);\n\t\t\t\te1.addIntersections(this.li, segIndex1, 1);\n\t\t\t}\n\t\t}\n\t},\n\tisDone: function () {\n\t\treturn false;\n\t},\n\tgetInteriorIntersections: function () {\n\t\treturn this.interiorIntersections;\n\t},\n\tinterfaces_: function () {\n\t\treturn [SegmentIntersector];\n\t},\n\tgetClass: function () {\n\t\treturn InteriorIntersectionFinderAdder;\n\t}\n});\n","import NodingValidator from '../NodingValidator';\nimport hasInterface from '../../../../../hasInterface';\nimport Collection from '../../../../../java/util/Collection';\nimport Noder from '../Noder';\nimport MCIndexNoder from '../MCIndexNoder';\nimport NodedSegmentString from '../NodedSegmentString';\nimport HotPixel from './HotPixel';\nimport extend from '../../../../../extend';\nimport Exception from '../../../../../java/lang/Exception';\nimport MCIndexPointSnapper from './MCIndexPointSnapper';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport InteriorIntersectionFinderAdder from '../InteriorIntersectionFinderAdder';\nexport default function MCIndexSnapRounder() {\n\tthis.pm = null;\n\tthis.li = null;\n\tthis.scaleFactor = null;\n\tthis.noder = null;\n\tthis.pointSnapper = null;\n\tthis.nodedSegStrings = null;\n\tlet pm = arguments[0];\n\tthis.pm = pm;\n\tthis.li = new RobustLineIntersector();\n\tthis.li.setPrecisionModel(pm);\n\tthis.scaleFactor = pm.getScale();\n}\nextend(MCIndexSnapRounder.prototype, {\n\tcheckCorrectness: function (inputSegmentStrings) {\n\t\tvar resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n\t\tvar nv = new NodingValidator(resultSegStrings);\n\t\ttry {\n\t\t\tnv.checkValid();\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof Exception) {\n\t\t\t\tex.printStackTrace();\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t},\n\tgetNodedSubstrings: function () {\n\t\treturn NodedSegmentString.getNodedSubstrings(this.nodedSegStrings);\n\t},\n\tsnapRound: function (segStrings, li) {\n\t\tvar intersections = this.findInteriorIntersections(segStrings, li);\n\t\tthis.computeIntersectionSnaps(intersections);\n\t\tthis.computeVertexSnaps(segStrings);\n\t},\n\tfindInteriorIntersections: function (segStrings, li) {\n\t\tvar intFinderAdder = new InteriorIntersectionFinderAdder(li);\n\t\tthis.noder.setSegmentIntersector(intFinderAdder);\n\t\tthis.noder.computeNodes(segStrings);\n\t\treturn intFinderAdder.getInteriorIntersections();\n\t},\n\tcomputeVertexSnaps: function () {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tlet edges = arguments[0];\n\t\t\tfor (var i0 = edges.iterator(); i0.hasNext(); ) {\n\t\t\t\tvar edge0 = i0.next();\n\t\t\t\tthis.computeVertexSnaps(edge0);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof NodedSegmentString) {\n\t\t\tlet e = arguments[0];\n\t\t\tvar pts0 = e.getCoordinates();\n\t\t\tfor (var i = 0; i < pts0.length; i++) {\n\t\t\t\tvar hotPixel = new HotPixel(pts0[i], this.scaleFactor, this.li);\n\t\t\t\tvar isNodeAdded = this.pointSnapper.snap(hotPixel, e, i);\n\t\t\t\tif (isNodeAdded) {\n\t\t\t\t\te.addIntersection(pts0[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputeNodes: function (inputSegmentStrings) {\n\t\tthis.nodedSegStrings = inputSegmentStrings;\n\t\tthis.noder = new MCIndexNoder();\n\t\tthis.pointSnapper = new MCIndexPointSnapper(this.noder.getIndex());\n\t\tthis.snapRound(inputSegmentStrings, this.li);\n\t},\n\tcomputeIntersectionSnaps: function (snapPts) {\n\t\tfor (var it = snapPts.iterator(); it.hasNext(); ) {\n\t\t\tvar snapPt = it.next();\n\t\t\tvar hotPixel = new HotPixel(snapPt, this.scaleFactor, this.li);\n\t\t\tthis.pointSnapper.snap(hotPixel);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [Noder];\n\t},\n\tgetClass: function () {\n\t\treturn MCIndexSnapRounder;\n\t}\n});\n","import BufferParameters from './BufferParameters';\nimport Geometry from '../../geom/Geometry';\nimport BufferBuilder from './BufferBuilder';\nimport ScaledNoder from '../../noding/ScaledNoder';\nimport TopologyException from '../../geom/TopologyException';\nimport extend from '../../../../../extend';\nimport MathUtil from '../../math/MathUtil';\nimport PrecisionModel from '../../geom/PrecisionModel';\nimport RuntimeException from '../../../../../java/lang/RuntimeException';\nimport MCIndexSnapRounder from '../../noding/snapround/MCIndexSnapRounder';\nexport default function BufferOp() {\n\tthis.argGeom = null;\n\tthis.distance = null;\n\tthis.bufParams = new BufferParameters();\n\tthis.resultGeometry = null;\n\tthis.saveException = null;\n\tif (arguments.length === 1) {\n\t\tlet g = arguments[0];\n\t\tthis.argGeom = g;\n\t} else if (arguments.length === 2) {\n\t\tlet g = arguments[0], bufParams = arguments[1];\n\t\tthis.argGeom = g;\n\t\tthis.bufParams = bufParams;\n\t}\n}\nextend(BufferOp.prototype, {\n\tbufferFixedPrecision: function (fixedPM) {\n\t\tvar noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n\t\tvar bufBuilder = new BufferBuilder(this.bufParams);\n\t\tbufBuilder.setWorkingPrecisionModel(fixedPM);\n\t\tbufBuilder.setNoder(noder);\n\t\tthis.resultGeometry = bufBuilder.buffer(this.argGeom, this.distance);\n\t},\n\tbufferReducedPrecision: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tfor (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n\t\t\t\ttry {\n\t\t\t\t\tthis.bufferReducedPrecision(precDigits);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tif (ex instanceof TopologyException) {\n\t\t\t\t\t\tthis.saveException = ex;\n\t\t\t\t\t} else throw ex;\n\t\t\t\t} finally {}\n\t\t\t\tif (this.resultGeometry !== null) return null;\n\t\t\t}\n\t\t\tthrow this.saveException;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet precisionDigits = arguments[0];\n\t\t\tvar sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this.argGeom, this.distance, precisionDigits);\n\t\t\tvar fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n\t\t\tthis.bufferFixedPrecision(fixedPM);\n\t\t}\n\t},\n\tcomputeGeometry: function () {\n\t\tthis.bufferOriginalPrecision();\n\t\tif (this.resultGeometry !== null) return null;\n\t\tvar argPM = this.argGeom.getFactory().getPrecisionModel();\n\t\tif (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM); else this.bufferReducedPrecision();\n\t},\n\tsetQuadrantSegments: function (quadrantSegments) {\n\t\tthis.bufParams.setQuadrantSegments(quadrantSegments);\n\t},\n\tbufferOriginalPrecision: function () {\n\t\ttry {\n\t\t\tvar bufBuilder = new BufferBuilder(this.bufParams);\n\t\t\tthis.resultGeometry = bufBuilder.buffer(this.argGeom, this.distance);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof RuntimeException) {\n\t\t\t\tthis.saveException = ex;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t},\n\tgetResultGeometry: function (distance) {\n\t\tthis.distance = distance;\n\t\tthis.computeGeometry();\n\t\treturn this.resultGeometry;\n\t},\n\tsetEndCapStyle: function (endCapStyle) {\n\t\tthis.bufParams.setEndCapStyle(endCapStyle);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn BufferOp;\n\t}\n});\nBufferOp.bufferOp = function () {\n\tif (arguments.length === 2) {\n\t\tlet g = arguments[0], distance = arguments[1];\n\t\tvar gBuf = new BufferOp(g);\n\t\tvar geomBuf = gBuf.getResultGeometry(distance);\n\t\treturn geomBuf;\n\t} else if (arguments.length === 3) {\n\t\tif (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === \"number\")) {\n\t\t\tlet g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2];\n\t\t\tvar bufOp = new BufferOp(g);\n\t\t\tbufOp.setQuadrantSegments(quadrantSegments);\n\t\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n\t\t\treturn geomBuf;\n\t\t} else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === \"number\")) {\n\t\t\tlet g = arguments[0], distance = arguments[1], params = arguments[2];\n\t\t\tvar bufOp = new BufferOp(g, params);\n\t\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n\t\t\treturn geomBuf;\n\t\t}\n\t} else if (arguments.length === 4) {\n\t\tlet g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2], endCapStyle = arguments[3];\n\t\tvar bufOp = new BufferOp(g);\n\t\tbufOp.setQuadrantSegments(quadrantSegments);\n\t\tbufOp.setEndCapStyle(endCapStyle);\n\t\tvar geomBuf = bufOp.getResultGeometry(distance);\n\t\treturn geomBuf;\n\t}\n};\nBufferOp.precisionScaleFactor = function (g, distance, maxPrecisionDigits) {\n\tvar env = g.getEnvelopeInternal();\n\tvar envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n\tvar expandByDistance = distance > 0.0 ? distance : 0.0;\n\tvar bufEnvMax = envMax + 2 * expandByDistance;\n\tvar bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n\tvar minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n\tvar scaleFactor = Math.pow(10.0, minUnitLog10);\n\treturn scaleFactor;\n};\nBufferOp.CAP_ROUND = BufferParameters.CAP_ROUND;\nBufferOp.CAP_BUTT = BufferParameters.CAP_FLAT;\nBufferOp.CAP_FLAT = BufferParameters.CAP_FLAT;\nBufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE;\nBufferOp.MAX_PRECISION_DIGITS = 12;\n","import Polygon from '../Polygon';\nimport extend from '../../../../../extend';\nimport GeometryCollection from '../GeometryCollection';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport GeometryFilter from '../GeometryFilter';\nexport default function PolygonExtracter() {\n\tthis.comps = null;\n\tlet comps = arguments[0];\n\tthis.comps = comps;\n}\nextend(PolygonExtracter.prototype, {\n\tfilter: function (geom) {\n\t\tif (geom instanceof Polygon) this.comps.add(geom);\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryFilter];\n\t},\n\tgetClass: function () {\n\t\treturn PolygonExtracter;\n\t}\n});\nPolygonExtracter.getPolygons = function () {\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\treturn PolygonExtracter.getPolygons(geom, new ArrayList());\n\t} else if (arguments.length === 2) {\n\t\tlet geom = arguments[0], list = arguments[1];\n\t\tif (geom instanceof Polygon) {\n\t\t\tlist.add(geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tgeom.apply(new PolygonExtracter(list));\n\t\t}\n\t\treturn list;\n\t}\n};\n","import extend from '../../../../../extend';\nexport default function GeometryLocation() {\n\tthis.component = null;\n\tthis.segIndex = null;\n\tthis.pt = null;\n\tif (arguments.length === 2) {\n\t\tlet component = arguments[0], pt = arguments[1];\n\t\tGeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);\n\t} else if (arguments.length === 3) {\n\t\tlet component = arguments[0], segIndex = arguments[1], pt = arguments[2];\n\t\tthis.component = component;\n\t\tthis.segIndex = segIndex;\n\t\tthis.pt = pt;\n\t}\n}\nextend(GeometryLocation.prototype, {\n\tisInsideArea: function () {\n\t\treturn this.segIndex === GeometryLocation.INSIDE_AREA;\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.pt;\n\t},\n\tgetGeometryComponent: function () {\n\t\treturn this.component;\n\t},\n\tgetSegmentIndex: function () {\n\t\treturn this.segIndex;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryLocation;\n\t}\n});\nGeometryLocation.INSIDE_AREA = -1;\n","import Point from '../Point';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport GeometryCollection from '../GeometryCollection';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport GeometryFilter from '../GeometryFilter';\nexport default function PointExtracter() {\n\tthis.pts = null;\n\tlet pts = arguments[0];\n\tthis.pts = pts;\n}\nextend(PointExtracter.prototype, {\n\tfilter: function (geom) {\n\t\tif (geom instanceof Point) this.pts.add(geom);\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryFilter];\n\t},\n\tgetClass: function () {\n\t\treturn PointExtracter;\n\t}\n});\nPointExtracter.getPoints = function () {\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\tif (geom instanceof Point) {\n\t\t\treturn Collections.singletonList(geom);\n\t\t}\n\t\treturn PointExtracter.getPoints(geom, new ArrayList());\n\t} else if (arguments.length === 2) {\n\t\tlet geom = arguments[0], list = arguments[1];\n\t\tif (geom instanceof Point) {\n\t\t\tlist.add(geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tgeom.apply(new PointExtracter(list));\n\t\t}\n\t\treturn list;\n\t}\n};\n","import LineString from '../../geom/LineString';\nimport Point from '../../geom/Point';\nimport Polygon from '../../geom/Polygon';\nimport GeometryLocation from './GeometryLocation';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport GeometryFilter from '../../geom/GeometryFilter';\nexport default function ConnectedElementLocationFilter() {\n\tthis.locations = null;\n\tlet locations = arguments[0];\n\tthis.locations = locations;\n}\nextend(ConnectedElementLocationFilter.prototype, {\n\tfilter: function (geom) {\n\t\tif (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) this.locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryFilter];\n\t},\n\tgetClass: function () {\n\t\treturn ConnectedElementLocationFilter;\n\t}\n});\nConnectedElementLocationFilter.getLocations = function (geom) {\n\tvar locations = new ArrayList();\n\tgeom.apply(new ConnectedElementLocationFilter(locations));\n\treturn locations;\n};\n","import PointLocator from '../../algorithm/PointLocator';\nimport PolygonExtracter from '../../geom/util/PolygonExtracter';\nimport Location from '../../geom/Location';\nimport LineString from '../../geom/LineString';\nimport CGAlgorithms from '../../algorithm/CGAlgorithms';\nimport hasInterface from '../../../../../hasInterface';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport Point from '../../geom/Point';\nimport Polygon from '../../geom/Polygon';\nimport GeometryLocation from './GeometryLocation';\nimport Double from '../../../../../java/lang/Double';\nimport PointExtracter from '../../geom/util/PointExtracter';\nimport extend from '../../../../../extend';\nimport ConnectedElementLocationFilter from './ConnectedElementLocationFilter';\nimport LineSegment from '../../geom/LineSegment';\nimport LinearComponentExtracter from '../../geom/util/LinearComponentExtracter';\nimport List from '../../../../../java/util/List';\nexport default function DistanceOp() {\n\tthis.geom = null;\n\tthis.terminateDistance = 0.0;\n\tthis.ptLocator = new PointLocator();\n\tthis.minDistanceLocation = null;\n\tthis.minDistance = Double.MAX_VALUE;\n\tif (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tDistanceOp.call(this, g0, g1, 0.0);\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], terminateDistance = arguments[2];\n\t\tthis.geom = new Array(2).fill(null);\n\t\tthis.geom[0] = g0;\n\t\tthis.geom[1] = g1;\n\t\tthis.terminateDistance = terminateDistance;\n\t}\n}\nextend(DistanceOp.prototype, {\n\tcomputeContainmentDistance: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tvar locPtPoly = new Array(2).fill(null);\n\t\t\tthis.computeContainmentDistance(0, locPtPoly);\n\t\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\t\tthis.computeContainmentDistance(1, locPtPoly);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet polyGeomIndex = arguments[0], locPtPoly = arguments[1];\n\t\t\tvar locationsIndex = 1 - polyGeomIndex;\n\t\t\tvar polys = PolygonExtracter.getPolygons(this.geom[polyGeomIndex]);\n\t\t\tif (polys.size() > 0) {\n\t\t\t\tvar insideLocs = ConnectedElementLocationFilter.getLocations(this.geom[locationsIndex]);\n\t\t\t\tthis.computeContainmentDistance(insideLocs, polys, locPtPoly);\n\t\t\t\tif (this.minDistance <= this.terminateDistance) {\n\t\t\t\t\tthis.minDistanceLocation[locationsIndex] = locPtPoly[0];\n\t\t\t\t\tthis.minDistanceLocation[polyGeomIndex] = locPtPoly[1];\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (arguments[2] instanceof Array && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n\t\t\t\tlet locs = arguments[0], polys = arguments[1], locPtPoly = arguments[2];\n\t\t\t\tfor (var i = 0; i < locs.size(); i++) {\n\t\t\t\t\tvar loc = locs.get(i);\n\t\t\t\t\tfor (var j = 0; j < polys.size(); j++) {\n\t\t\t\t\t\tthis.computeContainmentDistance(loc, polys.get(j), locPtPoly);\n\t\t\t\t\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (arguments[2] instanceof Array && (arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon)) {\n\t\t\t\tlet ptLoc = arguments[0], poly = arguments[1], locPtPoly = arguments[2];\n\t\t\t\tvar pt = ptLoc.getCoordinate();\n\t\t\t\tif (Location.EXTERIOR !== this.ptLocator.locate(pt, poly)) {\n\t\t\t\t\tthis.minDistance = 0.0;\n\t\t\t\t\tlocPtPoly[0] = ptLoc;\n\t\t\t\t\tlocPtPoly[1] = new GeometryLocation(poly, pt);\n\t\t\t\t\t;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputeMinDistanceLinesPoints: function (lines, points, locGeom) {\n\t\tfor (var i = 0; i < lines.size(); i++) {\n\t\t\tvar line = lines.get(i);\n\t\t\tfor (var j = 0; j < points.size(); j++) {\n\t\t\t\tvar pt = points.get(j);\n\t\t\t\tthis.computeMinDistance(line, pt, locGeom);\n\t\t\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\t\t}\n\t\t}\n\t},\n\tcomputeFacetDistance: function () {\n\t\tvar locGeom = new Array(2).fill(null);\n\t\tvar lines0 = LinearComponentExtracter.getLines(this.geom[0]);\n\t\tvar lines1 = LinearComponentExtracter.getLines(this.geom[1]);\n\t\tvar pts0 = PointExtracter.getPoints(this.geom[0]);\n\t\tvar pts1 = PointExtracter.getPoints(this.geom[1]);\n\t\tthis.computeMinDistanceLines(lines0, lines1, locGeom);\n\t\tthis.updateMinDistance(locGeom, false);\n\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\tlocGeom[0] = null;\n\t\tlocGeom[1] = null;\n\t\tthis.computeMinDistanceLinesPoints(lines0, pts1, locGeom);\n\t\tthis.updateMinDistance(locGeom, false);\n\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\tlocGeom[0] = null;\n\t\tlocGeom[1] = null;\n\t\tthis.computeMinDistanceLinesPoints(lines1, pts0, locGeom);\n\t\tthis.updateMinDistance(locGeom, true);\n\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\tlocGeom[0] = null;\n\t\tlocGeom[1] = null;\n\t\tthis.computeMinDistancePoints(pts0, pts1, locGeom);\n\t\tthis.updateMinDistance(locGeom, false);\n\t},\n\tnearestLocations: function () {\n\t\tthis.computeMinDistance();\n\t\treturn this.minDistanceLocation;\n\t},\n\tupdateMinDistance: function (locGeom, flip) {\n\t\tif (locGeom[0] === null) return null;\n\t\tif (flip) {\n\t\t\tthis.minDistanceLocation[0] = locGeom[1];\n\t\t\tthis.minDistanceLocation[1] = locGeom[0];\n\t\t} else {\n\t\t\tthis.minDistanceLocation[0] = locGeom[0];\n\t\t\tthis.minDistanceLocation[1] = locGeom[1];\n\t\t}\n\t},\n\tnearestPoints: function () {\n\t\tthis.computeMinDistance();\n\t\tvar nearestPts = [this.minDistanceLocation[0].getCoordinate(), this.minDistanceLocation[1].getCoordinate()];\n\t\treturn nearestPts;\n\t},\n\tcomputeMinDistance: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tif (this.minDistanceLocation !== null) return null;\n\t\t\tthis.minDistanceLocation = new Array(2).fill(null);\n\t\t\tthis.computeContainmentDistance();\n\t\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\t\tthis.computeFacetDistance();\n\t\t} else if (arguments.length === 3) {\n\t\t\tif (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof Point)) {\n\t\t\t\tlet line = arguments[0], pt = arguments[1], locGeom = arguments[2];\n\t\t\t\tif (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this.minDistance) return null;\n\t\t\t\tvar coord0 = line.getCoordinates();\n\t\t\t\tvar coord = pt.getCoordinate();\n\t\t\t\tfor (var i = 0; i < coord0.length - 1; i++) {\n\t\t\t\t\tvar dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);\n\t\t\t\t\tif (dist < this.minDistance) {\n\t\t\t\t\t\tthis.minDistance = dist;\n\t\t\t\t\t\tvar seg = new LineSegment(coord0[i], coord0[i + 1]);\n\t\t\t\t\t\tvar segClosestPoint = seg.closestPoint(coord);\n\t\t\t\t\t\tlocGeom[0] = new GeometryLocation(line, i, segClosestPoint);\n\t\t\t\t\t\tlocGeom[1] = new GeometryLocation(pt, 0, coord);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\t\t\t}\n\t\t\t} else if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof LineString)) {\n\t\t\t\tlet line0 = arguments[0], line1 = arguments[1], locGeom = arguments[2];\n\t\t\t\tif (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this.minDistance) return null;\n\t\t\t\tvar coord0 = line0.getCoordinates();\n\t\t\t\tvar coord1 = line1.getCoordinates();\n\t\t\t\tfor (var i = 0; i < coord0.length - 1; i++) {\n\t\t\t\t\tfor (var j = 0; j < coord1.length - 1; j++) {\n\t\t\t\t\t\tvar dist = CGAlgorithms.distanceLineLine(coord0[i], coord0[i + 1], coord1[j], coord1[j + 1]);\n\t\t\t\t\t\tif (dist < this.minDistance) {\n\t\t\t\t\t\t\tthis.minDistance = dist;\n\t\t\t\t\t\t\tvar seg0 = new LineSegment(coord0[i], coord0[i + 1]);\n\t\t\t\t\t\t\tvar seg1 = new LineSegment(coord1[j], coord1[j + 1]);\n\t\t\t\t\t\t\tvar closestPt = seg0.closestPoints(seg1);\n\t\t\t\t\t\t\tlocGeom[0] = new GeometryLocation(line0, i, closestPt[0]);\n\t\t\t\t\t\t\tlocGeom[1] = new GeometryLocation(line1, j, closestPt[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tcomputeMinDistancePoints: function (points0, points1, locGeom) {\n\t\tfor (var i = 0; i < points0.size(); i++) {\n\t\t\tvar pt0 = points0.get(i);\n\t\t\tfor (var j = 0; j < points1.size(); j++) {\n\t\t\t\tvar pt1 = points1.get(j);\n\t\t\t\tvar dist = pt0.getCoordinate().distance(pt1.getCoordinate());\n\t\t\t\tif (dist < this.minDistance) {\n\t\t\t\t\tthis.minDistance = dist;\n\t\t\t\t\tlocGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());\n\t\t\t\t\tlocGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());\n\t\t\t\t}\n\t\t\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\t\t}\n\t\t}\n\t},\n\tdistance: function () {\n\t\tif (this.geom[0] === null || this.geom[1] === null) throw new IllegalArgumentException(\"null geometries are not supported\");\n\t\tif (this.geom[0].isEmpty() || this.geom[1].isEmpty()) return 0.0;\n\t\tthis.computeMinDistance();\n\t\treturn this.minDistance;\n\t},\n\tcomputeMinDistanceLines: function (lines0, lines1, locGeom) {\n\t\tfor (var i = 0; i < lines0.size(); i++) {\n\t\t\tvar line0 = lines0.get(i);\n\t\t\tfor (var j = 0; j < lines1.size(); j++) {\n\t\t\t\tvar line1 = lines1.get(j);\n\t\t\t\tthis.computeMinDistance(line0, line1, locGeom);\n\t\t\t\tif (this.minDistance <= this.terminateDistance) return null;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DistanceOp;\n\t}\n});\nDistanceOp.distance = function (g0, g1) {\n\tvar distOp = new DistanceOp(g0, g1);\n\treturn distOp.distance();\n};\nDistanceOp.isWithinDistance = function (g0, g1, distance) {\n\tvar distOp = new DistanceOp(g0, g1, distance);\n\treturn distOp.distance() <= distance;\n};\nDistanceOp.nearestPoints = function (g0, g1) {\n\tvar distOp = new DistanceOp(g0, g1);\n\treturn distOp.nearestPoints();\n};\n","import CoordinateList from '../../geom/CoordinateList';\nimport extend from '../../../../../extend';\nimport CoordinateArrays from '../../geom/CoordinateArrays';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function EdgeString() {\n\tthis.factory = null;\n\tthis.directedEdges = new ArrayList();\n\tthis.coordinates = null;\n\tlet factory = arguments[0];\n\tthis.factory = factory;\n}\nextend(EdgeString.prototype, {\n\tgetCoordinates: function () {\n\t\tif (this.coordinates === null) {\n\t\t\tvar forwardDirectedEdges = 0;\n\t\t\tvar reverseDirectedEdges = 0;\n\t\t\tvar coordinateList = new CoordinateList();\n\t\t\tfor (var i = this.directedEdges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar directedEdge = i.next();\n\t\t\t\tif (directedEdge.getEdgeDirection()) {\n\t\t\t\t\tforwardDirectedEdges++;\n\t\t\t\t} else {\n\t\t\t\t\treverseDirectedEdges++;\n\t\t\t\t}\n\t\t\t\tcoordinateList.add(directedEdge.getEdge().getLine().getCoordinates(), false, directedEdge.getEdgeDirection());\n\t\t\t}\n\t\t\tthis.coordinates = coordinateList.toCoordinateArray();\n\t\t\tif (reverseDirectedEdges > forwardDirectedEdges) {\n\t\t\t\tCoordinateArrays.reverse(this.coordinates);\n\t\t\t}\n\t\t}\n\t\treturn this.coordinates;\n\t},\n\ttoLineString: function () {\n\t\treturn this.factory.createLineString(this.getCoordinates());\n\t},\n\tadd: function (directedEdge) {\n\t\tthis.directedEdges.add(directedEdge);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeString;\n\t}\n});\n","import extend from '../../../../extend';\nexport default function GraphComponent() {\n\tthis._isMarked = false;\n\tthis._isVisited = false;\n\tthis.data = null;\n}\nextend(GraphComponent.prototype, {\n\tsetVisited: function (isVisited) {\n\t\tthis._isVisited = isVisited;\n\t},\n\tisMarked: function () {\n\t\treturn this._isMarked;\n\t},\n\tsetData: function (data) {\n\t\tthis.data = data;\n\t},\n\tgetData: function () {\n\t\treturn this.data;\n\t},\n\tsetMarked: function (isMarked) {\n\t\tthis._isMarked = isMarked;\n\t},\n\tgetContext: function () {\n\t\treturn this.data;\n\t},\n\tisVisited: function () {\n\t\treturn this._isVisited;\n\t},\n\tsetContext: function (data) {\n\t\tthis.data = data;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GraphComponent;\n\t}\n});\nGraphComponent.getComponentWithVisitedState = function (i, visitedState) {\n\twhile (i.hasNext()) {\n\t\tvar comp = i.next();\n\t\tif (comp.isVisited() === visitedState) return comp;\n\t}\n\treturn null;\n};\nGraphComponent.setVisited = function (i, visited) {\n\twhile (i.hasNext()) {\n\t\tvar comp = i.next();\n\t\tcomp.setVisited(visited);\n\t}\n};\nGraphComponent.setMarked = function (i, marked) {\n\twhile (i.hasNext()) {\n\t\tvar comp = i.next();\n\t\tcomp.setMarked(marked);\n\t}\n};\n","import CGAlgorithms from '../algorithm/CGAlgorithms';\nimport extend from '../../../../extend';\nimport Comparable from '../../../../java/lang/Comparable';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Quadrant from '../geomgraph/Quadrant';\nimport inherits from '../../../../inherits';\nimport GraphComponent from './GraphComponent';\nexport default function DirectedEdge() {\n\tGraphComponent.apply(this);\n\tthis.parentEdge = null;\n\tthis.from = null;\n\tthis.to = null;\n\tthis.p0 = null;\n\tthis.p1 = null;\n\tthis.sym = null;\n\tthis.edgeDirection = null;\n\tthis.quadrant = null;\n\tthis.angle = null;\n\tlet from = arguments[0], to = arguments[1], directionPt = arguments[2], edgeDirection = arguments[3];\n\tthis.from = from;\n\tthis.to = to;\n\tthis.edgeDirection = edgeDirection;\n\tthis.p0 = from.getCoordinate();\n\tthis.p1 = directionPt;\n\tvar dx = this.p1.x - this.p0.x;\n\tvar dy = this.p1.y - this.p0.y;\n\tthis.quadrant = Quadrant.quadrant(dx, dy);\n\tthis.angle = Math.atan2(dy, dx);\n}\ninherits(DirectedEdge, GraphComponent);\nextend(DirectedEdge.prototype, {\n\tisRemoved: function () {\n\t\treturn this.parentEdge === null;\n\t},\n\tcompareDirection: function (e) {\n\t\tif (this.quadrant > e.quadrant) return 1;\n\t\tif (this.quadrant < e.quadrant) return -1;\n\t\treturn CGAlgorithms.computeOrientation(e.p0, e.p1, this.p1);\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.from.getCoordinate();\n\t},\n\tprint: function (out) {\n\t\tvar className = this.getClass().getName();\n\t\tvar lastDotPos = className.lastIndexOf('.');\n\t\tvar name = className.substring(lastDotPos + 1);\n\t\tout.print(\"  \" + name + \": \" + this.p0 + \" - \" + this.p1 + \" \" + this.quadrant + \":\" + this.angle);\n\t},\n\tgetDirectionPt: function () {\n\t\treturn this.p1;\n\t},\n\tgetAngle: function () {\n\t\treturn this.angle;\n\t},\n\tcompareTo: function (obj) {\n\t\tvar de = obj;\n\t\treturn this.compareDirection(de);\n\t},\n\tgetFromNode: function () {\n\t\treturn this.from;\n\t},\n\tgetSym: function () {\n\t\treturn this.sym;\n\t},\n\tsetEdge: function (parentEdge) {\n\t\tthis.parentEdge = parentEdge;\n\t},\n\tremove: function () {\n\t\tthis.sym = null;\n\t\tthis.parentEdge = null;\n\t},\n\tgetEdge: function () {\n\t\treturn this.parentEdge;\n\t},\n\tgetQuadrant: function () {\n\t\treturn this.quadrant;\n\t},\n\tsetSym: function (sym) {\n\t\tthis.sym = sym;\n\t},\n\tgetToNode: function () {\n\t\treturn this.to;\n\t},\n\tgetEdgeDirection: function () {\n\t\treturn this.edgeDirection;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn DirectedEdge;\n\t}\n});\nDirectedEdge.toEdges = function (dirEdges) {\n\tvar edges = new ArrayList();\n\tfor (var i = dirEdges.iterator(); i.hasNext(); ) {\n\t\tedges.add(i.next().parentEdge);\n\t}\n\treturn edges;\n};\n","import extend from '../../../../../extend';\nimport DirectedEdge from '../../planargraph/DirectedEdge';\nimport Assert from '../../util/Assert';\nimport inherits from '../../../../../inherits';\nexport default function LineMergeDirectedEdge() {\n\tlet from = arguments[0], to = arguments[1], directionPt = arguments[2], edgeDirection = arguments[3];\n\tDirectedEdge.call(this, from, to, directionPt, edgeDirection);\n}\ninherits(LineMergeDirectedEdge, DirectedEdge);\nextend(LineMergeDirectedEdge.prototype, {\n\tgetNext: function () {\n\t\tif (this.getToNode().getDegree() !== 2) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.getToNode().getOutEdges().getEdges().get(0) === this.getSym()) {\n\t\t\treturn this.getToNode().getOutEdges().getEdges().get(1);\n\t\t}\n\t\tAssert.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym());\n\t\treturn this.getToNode().getOutEdges().getEdges().get(0);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineMergeDirectedEdge;\n\t}\n});\n","import Node from './Node';\nimport extend from '../../../../extend';\nimport inherits from '../../../../inherits';\nimport GraphComponent from './GraphComponent';\nexport default function Edge() {\n\tGraphComponent.apply(this);\n\tthis.dirEdge = null;\n\tif (arguments.length === 0) {} else if (arguments.length === 2) {\n\t\tlet de0 = arguments[0], de1 = arguments[1];\n\t\tthis.setDirectedEdges(de0, de1);\n\t}\n}\ninherits(Edge, GraphComponent);\nextend(Edge.prototype, {\n\tisRemoved: function () {\n\t\treturn this.dirEdge === null;\n\t},\n\tsetDirectedEdges: function (de0, de1) {\n\t\tthis.dirEdge = [de0, de1];\n\t\tde0.setEdge(this);\n\t\tde1.setEdge(this);\n\t\tde0.setSym(de1);\n\t\tde1.setSym(de0);\n\t\tde0.getFromNode().addOutEdge(de0);\n\t\tde1.getFromNode().addOutEdge(de1);\n\t},\n\tgetDirEdge: function () {\n\t\tif (Number.isInteger(arguments[0])) {\n\t\t\tlet i = arguments[0];\n\t\t\treturn this.dirEdge[i];\n\t\t} else if (arguments[0] instanceof Node) {\n\t\t\tlet fromNode = arguments[0];\n\t\t\tif (this.dirEdge[0].getFromNode() === fromNode) return this.dirEdge[0];\n\t\t\tif (this.dirEdge[1].getFromNode() === fromNode) return this.dirEdge[1];\n\t\t\treturn null;\n\t\t}\n\t},\n\tremove: function () {\n\t\tthis.dirEdge = null;\n\t},\n\tgetOppositeNode: function (node) {\n\t\tif (this.dirEdge[0].getFromNode() === node) return this.dirEdge[0].getToNode();\n\t\tif (this.dirEdge[1].getFromNode() === node) return this.dirEdge[1].getToNode();\n\t\treturn null;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Edge;\n\t}\n});\n","import extend from '../../../../extend';\nimport Collections from '../../../../java/util/Collections';\nimport DirectedEdge from './DirectedEdge';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Edge from './Edge';\nexport default function DirectedEdgeStar() {\n\tthis.outEdges = new ArrayList();\n\tthis.sorted = false;\n}\nextend(DirectedEdgeStar.prototype, {\n\tgetNextEdge: function (dirEdge) {\n\t\tvar i = this.getIndex(dirEdge);\n\t\treturn this.outEdges.get(this.getIndex(i + 1));\n\t},\n\tgetCoordinate: function () {\n\t\tvar it = this.iterator();\n\t\tif (!it.hasNext()) return null;\n\t\tvar e = it.next();\n\t\treturn e.getCoordinate();\n\t},\n\titerator: function () {\n\t\tthis.sortEdges();\n\t\treturn this.outEdges.iterator();\n\t},\n\tsortEdges: function () {\n\t\tif (!this.sorted) {\n\t\t\tCollections.sort(this.outEdges);\n\t\t\tthis.sorted = true;\n\t\t}\n\t},\n\tremove: function (de) {\n\t\tthis.outEdges.remove(de);\n\t},\n\tgetEdges: function () {\n\t\tthis.sortEdges();\n\t\treturn this.outEdges;\n\t},\n\tgetNextCWEdge: function (dirEdge) {\n\t\tvar i = this.getIndex(dirEdge);\n\t\treturn this.outEdges.get(this.getIndex(i - 1));\n\t},\n\tgetIndex: function () {\n\t\tif (arguments[0] instanceof Edge) {\n\t\t\tlet edge = arguments[0];\n\t\t\tthis.sortEdges();\n\t\t\tfor (var i = 0; i < this.outEdges.size(); i++) {\n\t\t\t\tvar de = this.outEdges.get(i);\n\t\t\t\tif (de.getEdge() === edge) return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t} else if (arguments[0] instanceof DirectedEdge) {\n\t\t\tlet dirEdge = arguments[0];\n\t\t\tthis.sortEdges();\n\t\t\tfor (var i = 0; i < this.outEdges.size(); i++) {\n\t\t\t\tvar de = this.outEdges.get(i);\n\t\t\t\tif (de === dirEdge) return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t} else if (Number.isInteger(arguments[0])) {\n\t\t\tlet i = arguments[0];\n\t\t\tvar modi = i % this.outEdges.size();\n\t\t\tif (modi < 0) modi += this.outEdges.size();\n\t\t\treturn modi;\n\t\t}\n\t},\n\tadd: function (de) {\n\t\tthis.outEdges.add(de);\n\t\tthis.sorted = false;\n\t},\n\tgetDegree: function () {\n\t\treturn this.outEdges.size();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DirectedEdgeStar;\n\t}\n});\n","import DirectedEdgeStar from './DirectedEdgeStar';\nimport HashSet from '../../../../java/util/HashSet';\nimport extend from '../../../../extend';\nimport DirectedEdge from './DirectedEdge';\nimport inherits from '../../../../inherits';\nimport GraphComponent from './GraphComponent';\nexport default function Node() {\n\tGraphComponent.apply(this);\n\tthis.pt = null;\n\tthis.deStar = null;\n\tif (arguments.length === 1) {\n\t\tlet pt = arguments[0];\n\t\tNode.call(this, pt, new DirectedEdgeStar());\n\t} else if (arguments.length === 2) {\n\t\tlet pt = arguments[0], deStar = arguments[1];\n\t\tthis.pt = pt;\n\t\tthis.deStar = deStar;\n\t}\n}\ninherits(Node, GraphComponent);\nextend(Node.prototype, {\n\tisRemoved: function () {\n\t\treturn this.pt === null;\n\t},\n\taddOutEdge: function (de) {\n\t\tthis.deStar.add(de);\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.pt;\n\t},\n\tgetOutEdges: function () {\n\t\treturn this.deStar;\n\t},\n\tremove: function () {\n\t\tif (arguments.length === 0) {\n\t\t\tthis.pt = null;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet de = arguments[0];\n\t\t\tthis.deStar.remove(de);\n\t\t}\n\t},\n\tgetIndex: function (edge) {\n\t\treturn this.deStar.getIndex(edge);\n\t},\n\tgetDegree: function () {\n\t\treturn this.deStar.getDegree();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Node;\n\t}\n});\nNode.getEdgesBetween = function (node0, node1) {\n\tvar edges0 = DirectedEdge.toEdges(node0.getOutEdges().getEdges());\n\tvar commonEdges = new HashSet(edges0);\n\tvar edges1 = DirectedEdge.toEdges(node1.getOutEdges().getEdges());\n\tcommonEdges.retainAll(edges1);\n\treturn commonEdges;\n};\n","import extend from '../../../../../extend';\nimport Edge from '../../planargraph/Edge';\nimport inherits from '../../../../../inherits';\nexport default function LineMergeEdge() {\n\tEdge.apply(this);\n\tthis.line = null;\n\tlet line = arguments[0];\n\tthis.line = line;\n}\ninherits(LineMergeEdge, Edge);\nextend(LineMergeEdge.prototype, {\n\tgetLine: function () {\n\t\treturn this.line;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineMergeEdge;\n\t}\n});\n","import extend from '../../../../extend';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function NodeMap() {\n\tthis.nodeMap = new TreeMap();\n}\nextend(NodeMap.prototype, {\n\tfind: function (coord) {\n\t\treturn this.nodeMap.get(coord);\n\t},\n\titerator: function () {\n\t\treturn this.nodeMap.values().iterator();\n\t},\n\tremove: function (pt) {\n\t\treturn this.nodeMap.remove(pt);\n\t},\n\tvalues: function () {\n\t\treturn this.nodeMap.values();\n\t},\n\tadd: function (n) {\n\t\tthis.nodeMap.put(n.getCoordinate(), n);\n\t\treturn n;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn NodeMap;\n\t}\n});\n","import HashSet from '../../../../java/util/HashSet';\nimport Node from './Node';\nimport extend from '../../../../extend';\nimport NodeMap from './NodeMap';\nimport DirectedEdge from './DirectedEdge';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Edge from './Edge';\nexport default function PlanarGraph() {\n\tthis.edges = new HashSet();\n\tthis.dirEdges = new HashSet();\n\tthis.nodeMap = new NodeMap();\n}\nextend(PlanarGraph.prototype, {\n\tfindNodesOfDegree: function (degree) {\n\t\tvar nodesFound = new ArrayList();\n\t\tfor (var i = this.nodeIterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tif (node.getDegree() === degree) nodesFound.add(node);\n\t\t}\n\t\treturn nodesFound;\n\t},\n\tdirEdgeIterator: function () {\n\t\treturn this.dirEdges.iterator();\n\t},\n\tedgeIterator: function () {\n\t\treturn this.edges.iterator();\n\t},\n\tremove: function () {\n\t\tif (arguments[0] instanceof Edge) {\n\t\t\tlet edge = arguments[0];\n\t\t\tthis.remove(edge.getDirEdge(0));\n\t\t\tthis.remove(edge.getDirEdge(1));\n\t\t\tthis.edges.remove(edge);\n\t\t\tedge.remove();\n\t\t} else if (arguments[0] instanceof DirectedEdge) {\n\t\t\tlet de = arguments[0];\n\t\t\tvar sym = de.getSym();\n\t\t\tif (sym !== null) sym.setSym(null);\n\t\t\tde.getFromNode().remove(de);\n\t\t\tde.remove();\n\t\t\tthis.dirEdges.remove(de);\n\t\t} else if (arguments[0] instanceof Node) {\n\t\t\tlet node = arguments[0];\n\t\t\tvar outEdges = node.getOutEdges().getEdges();\n\t\t\tfor (var i = outEdges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar de = i.next();\n\t\t\t\tvar sym = de.getSym();\n\t\t\t\tif (sym !== null) this.remove(sym);\n\t\t\t\tthis.dirEdges.remove(de);\n\t\t\t\tvar edge = de.getEdge();\n\t\t\t\tif (edge !== null) {\n\t\t\t\t\tthis.edges.remove(edge);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.nodeMap.remove(node.getCoordinate());\n\t\t\tnode.remove();\n\t\t}\n\t},\n\tfindNode: function (pt) {\n\t\treturn this.nodeMap.find(pt);\n\t},\n\tgetEdges: function () {\n\t\treturn this.edges;\n\t},\n\tnodeIterator: function () {\n\t\treturn this.nodeMap.iterator();\n\t},\n\tcontains: function () {\n\t\tif (arguments[0] instanceof Edge) {\n\t\t\tlet e = arguments[0];\n\t\t\treturn this.edges.contains(e);\n\t\t} else if (arguments[0] instanceof DirectedEdge) {\n\t\t\tlet de = arguments[0];\n\t\t\treturn this.dirEdges.contains(de);\n\t\t}\n\t},\n\tadd: function () {\n\t\tif (arguments[0] instanceof Node) {\n\t\t\tlet node = arguments[0];\n\t\t\tthis.nodeMap.add(node);\n\t\t} else if (arguments[0] instanceof Edge) {\n\t\t\tlet edge = arguments[0];\n\t\t\tthis.edges.add(edge);\n\t\t\tthis.add(edge.getDirEdge(0));\n\t\t\tthis.add(edge.getDirEdge(1));\n\t\t} else if (arguments[0] instanceof DirectedEdge) {\n\t\t\tlet dirEdge = arguments[0];\n\t\t\tthis.dirEdges.add(dirEdge);\n\t\t}\n\t},\n\tgetNodes: function () {\n\t\treturn this.nodeMap.values();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PlanarGraph;\n\t}\n});\n","import LineMergeDirectedEdge from './LineMergeDirectedEdge';\nimport Node from '../../planargraph/Node';\nimport extend from '../../../../../extend';\nimport CoordinateArrays from '../../geom/CoordinateArrays';\nimport LineMergeEdge from './LineMergeEdge';\nimport inherits from '../../../../../inherits';\nimport PlanarGraph from '../../planargraph/PlanarGraph';\nexport default function LineMergeGraph() {\n\tPlanarGraph.apply(this);\n}\ninherits(LineMergeGraph, PlanarGraph);\nextend(LineMergeGraph.prototype, {\n\taddEdge: function (lineString) {\n\t\tif (lineString.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tvar coordinates = CoordinateArrays.removeRepeatedPoints(lineString.getCoordinates());\n\t\tif (coordinates.length <= 1) return null;\n\t\tvar startCoordinate = coordinates[0];\n\t\tvar endCoordinate = coordinates[coordinates.length - 1];\n\t\tvar startNode = this.getNode(startCoordinate);\n\t\tvar endNode = this.getNode(endCoordinate);\n\t\tvar directedEdge0 = new LineMergeDirectedEdge(startNode, endNode, coordinates[1], true);\n\t\tvar directedEdge1 = new LineMergeDirectedEdge(endNode, startNode, coordinates[coordinates.length - 2], false);\n\t\tvar edge = new LineMergeEdge(lineString);\n\t\tedge.setDirectedEdges(directedEdge0, directedEdge1);\n\t\tthis.add(edge);\n\t},\n\tgetNode: function (coordinate) {\n\t\tvar node = this.findNode(coordinate);\n\t\tif (node === null) {\n\t\t\tnode = new Node(coordinate);\n\t\t\tthis.add(node);\n\t\t}\n\t\treturn node;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineMergeGraph;\n\t}\n});\n","import LineString from '../../geom/LineString';\nimport Geometry from '../../geom/Geometry';\nimport hasInterface from '../../../../../hasInterface';\nimport Collection from '../../../../../java/util/Collection';\nimport EdgeString from './EdgeString';\nimport extend from '../../../../../extend';\nimport LineMergeGraph from './LineMergeGraph';\nimport GeometryComponentFilter from '../../geom/GeometryComponentFilter';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport GraphComponent from '../../planargraph/GraphComponent';\nexport default function LineMerger() {\n\tthis.graph = new LineMergeGraph();\n\tthis.mergedLineStrings = null;\n\tthis.factory = null;\n\tthis.edgeStrings = null;\n}\nextend(LineMerger.prototype, {\n\tbuildEdgeStringsForUnprocessedNodes: function () {\n\t\tfor (var i = this.graph.getNodes().iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tif (!node.isMarked()) {\n\t\t\t\tAssert.isTrue(node.getDegree() === 2);\n\t\t\t\tthis.buildEdgeStringsStartingAt(node);\n\t\t\t\tnode.setMarked(true);\n\t\t\t}\n\t\t}\n\t},\n\tbuildEdgeStringsForNonDegree2Nodes: function () {\n\t\tfor (var i = this.graph.getNodes().iterator(); i.hasNext(); ) {\n\t\t\tvar node = i.next();\n\t\t\tif (node.getDegree() !== 2) {\n\t\t\t\tthis.buildEdgeStringsStartingAt(node);\n\t\t\t\tnode.setMarked(true);\n\t\t\t}\n\t\t}\n\t},\n\tbuildEdgeStringsForObviousStartNodes: function () {\n\t\tthis.buildEdgeStringsForNonDegree2Nodes();\n\t},\n\tgetMergedLineStrings: function () {\n\t\tthis.merge();\n\t\treturn this.mergedLineStrings;\n\t},\n\tbuildEdgeStringsStartingAt: function (node) {\n\t\tfor (var i = node.getOutEdges().iterator(); i.hasNext(); ) {\n\t\t\tvar directedEdge = i.next();\n\t\t\tif (directedEdge.getEdge().isMarked()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.edgeStrings.add(this.buildEdgeStringStartingWith(directedEdge));\n\t\t}\n\t},\n\tmerge: function () {\n\t\tif (this.mergedLineStrings !== null) {\n\t\t\treturn null;\n\t\t}\n\t\tGraphComponent.setMarked(this.graph.nodeIterator(), false);\n\t\tGraphComponent.setMarked(this.graph.edgeIterator(), false);\n\t\tthis.edgeStrings = new ArrayList();\n\t\tthis.buildEdgeStringsForObviousStartNodes();\n\t\tthis.buildEdgeStringsForIsolatedLoops();\n\t\tthis.mergedLineStrings = new ArrayList();\n\t\tfor (var i = this.edgeStrings.iterator(); i.hasNext(); ) {\n\t\t\tvar edgeString = i.next();\n\t\t\tthis.mergedLineStrings.add(edgeString.toLineString());\n\t\t}\n\t},\n\tbuildEdgeStringStartingWith: function (start) {\n\t\tvar edgeString = new EdgeString(this.factory);\n\t\tvar current = start;\n\t\tdo {\n\t\t\tedgeString.add(current);\n\t\t\tcurrent.getEdge().setMarked(true);\n\t\t\tcurrent = current.getNext();\n\t\t} while (current !== null && current !== start);\n\t\treturn edgeString;\n\t},\n\tadd: function () {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet geometry = arguments[0];\n\t\t\tgeometry.apply({\n\t\t\t\tinterfaces_: function () {\n\t\t\t\t\treturn [GeometryComponentFilter];\n\t\t\t\t},\n\t\t\t\tfilter: function (component) {\n\t\t\t\t\tif (component instanceof LineString) {\n\t\t\t\t\t\tthis.add(component);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (hasInterface(arguments[0], Collection)) {\n\t\t\tlet geometries = arguments[0];\n\t\t\tthis.mergedLineStrings = null;\n\t\t\tfor (var i = geometries.iterator(); i.hasNext(); ) {\n\t\t\t\tvar geometry = i.next();\n\t\t\t\tthis.add(geometry);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof LineString) {\n\t\t\tlet lineString = arguments[0];\n\t\t\tif (this.factory === null) {\n\t\t\t\tthis.factory = lineString.getFactory();\n\t\t\t}\n\t\t\tthis.graph.addEdge(lineString);\n\t\t}\n\t},\n\tbuildEdgeStringsForIsolatedLoops: function () {\n\t\tthis.buildEdgeStringsForUnprocessedNodes();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineMerger;\n\t}\n});\n","import extend from '../../../../../extend';\nimport DirectedEdge from '../../planargraph/DirectedEdge';\nimport inherits from '../../../../../inherits';\nexport default function PolygonizeDirectedEdge() {\n\tthis.edgeRing = null;\n\tthis.next = null;\n\tthis.label = -1;\n\tlet from = arguments[0], to = arguments[1], directionPt = arguments[2], edgeDirection = arguments[3];\n\tDirectedEdge.call(this, from, to, directionPt, edgeDirection);\n}\ninherits(PolygonizeDirectedEdge, DirectedEdge);\nextend(PolygonizeDirectedEdge.prototype, {\n\tgetNext: function () {\n\t\treturn this.next;\n\t},\n\tisInRing: function () {\n\t\treturn this.edgeRing !== null;\n\t},\n\tsetRing: function (edgeRing) {\n\t\tthis.edgeRing = edgeRing;\n\t},\n\tsetLabel: function (label) {\n\t\tthis.label = label;\n\t},\n\tgetLabel: function () {\n\t\treturn this.label;\n\t},\n\tsetNext: function (next) {\n\t\tthis.next = next;\n\t},\n\tgetRing: function () {\n\t\treturn this.edgeRing;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PolygonizeDirectedEdge;\n\t}\n});\n","import extend from '../../../../../extend';\nimport Edge from '../../planargraph/Edge';\nimport inherits from '../../../../../inherits';\nexport default function PolygonizeEdge() {\n\tEdge.apply(this);\n\tthis.line = null;\n\tlet line = arguments[0];\n\tthis.line = line;\n}\ninherits(PolygonizeEdge, Edge);\nextend(PolygonizeEdge.prototype, {\n\tgetLine: function () {\n\t\treturn this.line;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PolygonizeEdge;\n\t}\n});\n","import Location from '../../geom/Location';\nimport GeometryFactory from '../../geom/GeometryFactory';\nimport Position from '../../geomgraph/Position';\nimport Polygon from '../../geom/Polygon';\nimport extend from '../../../../../extend';\nimport MultiPolygon from '../../geom/MultiPolygon';\nimport MaximalEdgeRing from '../overlay/MaximalEdgeRing';\nimport OverlayNodeFactory from '../overlay/OverlayNodeFactory';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport PlanarGraph from '../../geomgraph/PlanarGraph';\nexport default function ConnectedInteriorTester() {\n\tthis.geometryFactory = new GeometryFactory();\n\tthis.geomGraph = null;\n\tthis.disconnectedRingcoord = null;\n\tlet geomGraph = arguments[0];\n\tthis.geomGraph = geomGraph;\n}\nextend(ConnectedInteriorTester.prototype, {\n\tvisitInteriorRing: function (ring, graph) {\n\t\tvar pts = ring.getCoordinates();\n\t\tvar pt0 = pts[0];\n\t\tvar pt1 = ConnectedInteriorTester.findDifferentPoint(pts, pt0);\n\t\tvar e = graph.findEdgeInSameDirection(pt0, pt1);\n\t\tvar de = graph.findEdgeEnd(e);\n\t\tvar intDe = null;\n\t\tif (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n\t\t\tintDe = de;\n\t\t} else if (de.getSym().getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n\t\t\tintDe = de.getSym();\n\t\t}\n\t\tAssert.isTrue(intDe !== null, \"unable to find dirEdge with Interior on RHS\");\n\t\tthis.visitLinkedDirectedEdges(intDe);\n\t},\n\tvisitShellInteriors: function (g, graph) {\n\t\tif (g instanceof Polygon) {\n\t\t\tvar p = g;\n\t\t\tthis.visitInteriorRing(p.getExteriorRing(), graph);\n\t\t}\n\t\tif (g instanceof MultiPolygon) {\n\t\t\tvar mp = g;\n\t\t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n\t\t\t\tvar p = mp.getGeometryN(i);\n\t\t\t\tthis.visitInteriorRing(p.getExteriorRing(), graph);\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.disconnectedRingcoord;\n\t},\n\tsetInteriorEdgesInResult: function (graph) {\n\t\tfor (var it = graph.getEdgeEnds().iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {\n\t\t\t\tde.setInResult(true);\n\t\t\t}\n\t\t}\n\t},\n\tvisitLinkedDirectedEdges: function (start) {\n\t\tvar startDe = start;\n\t\tvar de = start;\n\t\tdo {\n\t\t\tAssert.isTrue(de !== null, \"found null Directed Edge\");\n\t\t\tde.setVisited(true);\n\t\t\tde = de.getNext();\n\t\t} while (de !== startDe);\n\t},\n\tbuildEdgeRings: function (dirEdges) {\n\t\tvar edgeRings = new ArrayList();\n\t\tfor (var it = dirEdges.iterator(); it.hasNext(); ) {\n\t\t\tvar de = it.next();\n\t\t\tif (de.isInResult() && de.getEdgeRing() === null) {\n\t\t\t\tvar er = new MaximalEdgeRing(de, this.geometryFactory);\n\t\t\t\ter.linkDirectedEdgesForMinimalEdgeRings();\n\t\t\t\tvar minEdgeRings = er.buildMinimalRings();\n\t\t\t\tedgeRings.addAll(minEdgeRings);\n\t\t\t}\n\t\t}\n\t\treturn edgeRings;\n\t},\n\thasUnvisitedShellEdge: function (edgeRings) {\n\t\tfor (var i = 0; i < edgeRings.size(); i++) {\n\t\t\tvar er = edgeRings.get(i);\n\t\t\tif (er.isHole()) continue;\n\t\t\tvar edges = er.getEdges();\n\t\t\tvar de = edges.get(0);\n\t\t\tif (de.getLabel().getLocation(0, Position.RIGHT) !== Location.INTERIOR) continue;\n\t\t\tfor (var j = 0; j < edges.size(); j++) {\n\t\t\t\tde = edges.get(j);\n\t\t\t\tif (!de.isVisited()) {\n\t\t\t\t\tthis.disconnectedRingcoord = de.getCoordinate();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tisInteriorsConnected: function () {\n\t\tvar splitEdges = new ArrayList();\n\t\tthis.geomGraph.computeSplitEdges(splitEdges);\n\t\tvar graph = new PlanarGraph(new OverlayNodeFactory());\n\t\tgraph.addEdges(splitEdges);\n\t\tthis.setInteriorEdgesInResult(graph);\n\t\tgraph.linkResultDirectedEdges();\n\t\tvar edgeRings = this.buildEdgeRings(graph.getEdgeEnds());\n\t\tthis.visitShellInteriors(this.geomGraph.getGeometry(), graph);\n\t\treturn !this.hasUnvisitedShellEdge(edgeRings);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ConnectedInteriorTester;\n\t}\n});\nConnectedInteriorTester.findDifferentPoint = function (coord, pt) {\n\tfor (var i = 0; i < coord.length; i++) {\n\t\tif (!coord[i].equals(pt)) return coord[i];\n\t}\n\treturn null;\n};\n","import EdgeEnd from '../../geomgraph/EdgeEnd';\nimport extend from '../../../../../extend';\nimport Label from '../../geomgraph/Label';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function EdgeEndBuilder() {}\nextend(EdgeEndBuilder.prototype, {\n\tcreateEdgeEndForNext: function (edge, l, eiCurr, eiNext) {\n\t\tvar iNext = eiCurr.segmentIndex + 1;\n\t\tif (iNext >= edge.getNumPoints() && eiNext === null) return null;\n\t\tvar pNext = edge.getCoordinate(iNext);\n\t\tif (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;\n\t\tvar e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));\n\t\tl.add(e);\n\t},\n\tcreateEdgeEndForPrev: function (edge, l, eiCurr, eiPrev) {\n\t\tvar iPrev = eiCurr.segmentIndex;\n\t\tif (eiCurr.dist === 0.0) {\n\t\t\tif (iPrev === 0) return null;\n\t\t\tiPrev--;\n\t\t}\n\t\tvar pPrev = edge.getCoordinate(iPrev);\n\t\tif (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;\n\t\tvar label = new Label(edge.getLabel());\n\t\tlabel.flip();\n\t\tvar e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);\n\t\tl.add(e);\n\t},\n\tcomputeEdgeEnds: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet edges = arguments[0];\n\t\t\tvar l = new ArrayList();\n\t\t\tfor (var i = edges; i.hasNext(); ) {\n\t\t\t\tvar e = i.next();\n\t\t\t\tthis.computeEdgeEnds(e, l);\n\t\t\t}\n\t\t\treturn l;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet edge = arguments[0], l = arguments[1];\n\t\t\tvar eiList = edge.getEdgeIntersectionList();\n\t\t\teiList.addEndpoints();\n\t\t\tvar it = eiList.iterator();\n\t\t\tvar eiPrev = null;\n\t\t\tvar eiCurr = null;\n\t\t\tif (!it.hasNext()) return null;\n\t\t\tvar eiNext = it.next();\n\t\t\tdo {\n\t\t\t\teiPrev = eiCurr;\n\t\t\t\teiCurr = eiNext;\n\t\t\t\teiNext = null;\n\t\t\t\tif (it.hasNext()) eiNext = it.next();\n\t\t\t\tif (eiCurr !== null) {\n\t\t\t\t\tthis.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);\n\t\t\t\t\tthis.createEdgeEndForNext(edge, l, eiCurr, eiNext);\n\t\t\t\t}\n\t\t\t} while (eiCurr !== null);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeEndBuilder;\n\t}\n});\n","import Location from '../../geom/Location';\nimport EdgeEnd from '../../geomgraph/EdgeEnd';\nimport Position from '../../geomgraph/Position';\nimport extend from '../../../../../extend';\nimport GeometryGraph from '../../geomgraph/GeometryGraph';\nimport Label from '../../geomgraph/Label';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Edge from '../../geomgraph/Edge';\nimport inherits from '../../../../../inherits';\nexport default function EdgeEndBundle() {\n\tthis.edgeEnds = new ArrayList();\n\tif (arguments.length === 1) {\n\t\tlet e = arguments[0];\n\t\tEdgeEndBundle.call(this, null, e);\n\t} else if (arguments.length === 2) {\n\t\tlet boundaryNodeRule = arguments[0], e = arguments[1];\n\t\tEdgeEnd.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new Label(e.getLabel()));\n\t\tthis.insert(e);\n\t}\n}\ninherits(EdgeEndBundle, EdgeEnd);\nextend(EdgeEndBundle.prototype, {\n\tinsert: function (e) {\n\t\tthis.edgeEnds.add(e);\n\t},\n\tprint: function (out) {\n\t\tout.println(\"EdgeEndBundle--> Label: \" + this.label);\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar ee = it.next();\n\t\t\tee.print(out);\n\t\t\tout.println();\n\t\t}\n\t},\n\titerator: function () {\n\t\treturn this.edgeEnds.iterator();\n\t},\n\tgetEdgeEnds: function () {\n\t\treturn this.edgeEnds;\n\t},\n\tcomputeLabelOn: function (geomIndex, boundaryNodeRule) {\n\t\tvar boundaryCount = 0;\n\t\tvar foundInterior = false;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tvar loc = e.getLabel().getLocation(geomIndex);\n\t\t\tif (loc === Location.BOUNDARY) boundaryCount++;\n\t\t\tif (loc === Location.INTERIOR) foundInterior = true;\n\t\t}\n\t\tvar loc = Location.NONE;\n\t\tif (foundInterior) loc = Location.INTERIOR;\n\t\tif (boundaryCount > 0) {\n\t\t\tloc = GeometryGraph.determineBoundary(boundaryNodeRule, boundaryCount);\n\t\t}\n\t\tthis.label.setLocation(geomIndex, loc);\n\t},\n\tcomputeLabelSide: function (geomIndex, side) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.getLabel().isArea()) {\n\t\t\t\tvar loc = e.getLabel().getLocation(geomIndex, side);\n\t\t\t\tif (loc === Location.INTERIOR) {\n\t\t\t\t\tthis.label.setLocation(geomIndex, side, Location.INTERIOR);\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (loc === Location.EXTERIOR) this.label.setLocation(geomIndex, side, Location.EXTERIOR);\n\t\t\t}\n\t\t}\n\t},\n\tgetLabel: function () {\n\t\treturn this.label;\n\t},\n\tcomputeLabelSides: function (geomIndex) {\n\t\tthis.computeLabelSide(geomIndex, Position.LEFT);\n\t\tthis.computeLabelSide(geomIndex, Position.RIGHT);\n\t},\n\tupdateIM: function (im) {\n\t\tEdge.updateIM(this.label, im);\n\t},\n\tcomputeLabel: function (boundaryNodeRule) {\n\t\tvar isArea = false;\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar e = it.next();\n\t\t\tif (e.getLabel().isArea()) isArea = true;\n\t\t}\n\t\tif (isArea) this.label = new Label(Location.NONE, Location.NONE, Location.NONE); else this.label = new Label(Location.NONE);\n\t\tfor (var i = 0; i < 2; i++) {\n\t\t\tthis.computeLabelOn(i, boundaryNodeRule);\n\t\t\tif (isArea) this.computeLabelSides(i);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeEndBundle;\n\t}\n});\n","import extend from '../../../../../extend';\nimport EdgeEndStar from '../../geomgraph/EdgeEndStar';\nimport inherits from '../../../../../inherits';\nimport EdgeEndBundle from './EdgeEndBundle';\nexport default function EdgeEndBundleStar() {\n\tEdgeEndStar.apply(this);\n}\ninherits(EdgeEndBundleStar, EdgeEndStar);\nextend(EdgeEndBundleStar.prototype, {\n\tupdateIM: function (im) {\n\t\tfor (var it = this.iterator(); it.hasNext(); ) {\n\t\t\tvar esb = it.next();\n\t\t\tesb.updateIM(im);\n\t\t}\n\t},\n\tinsert: function (e) {\n\t\tvar eb = this.edgeMap.get(e);\n\t\tif (eb === null) {\n\t\t\teb = new EdgeEndBundle(e);\n\t\t\tthis.insertEdgeEnd(e, eb);\n\t\t} else {\n\t\t\teb.insert(e);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeEndBundleStar;\n\t}\n});\n","import Node from '../../geomgraph/Node';\nimport extend from '../../../../../extend';\nimport inherits from '../../../../../inherits';\nexport default function RelateNode() {\n\tlet coord = arguments[0], edges = arguments[1];\n\tNode.call(this, coord, edges);\n}\ninherits(RelateNode, Node);\nextend(RelateNode.prototype, {\n\tupdateIMFromEdges: function (im) {\n\t\tthis.edges.updateIM(im);\n\t},\n\tcomputeIM: function (im) {\n\t\tim.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RelateNode;\n\t}\n});\n","import EdgeEndBundleStar from './EdgeEndBundleStar';\nimport extend from '../../../../../extend';\nimport RelateNode from './RelateNode';\nimport inherits from '../../../../../inherits';\nimport NodeFactory from '../../geomgraph/NodeFactory';\nexport default function RelateNodeFactory() {\n\tNodeFactory.apply(this);\n}\ninherits(RelateNodeFactory, NodeFactory);\nextend(RelateNodeFactory.prototype, {\n\tcreateNode: function (coord) {\n\t\treturn new RelateNode(coord, new EdgeEndBundleStar());\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RelateNodeFactory;\n\t}\n});\n","import Location from '../../geom/Location';\nimport EdgeEndBuilder from './EdgeEndBuilder';\nimport extend from '../../../../../extend';\nimport NodeMap from '../../geomgraph/NodeMap';\nimport RelateNodeFactory from './RelateNodeFactory';\nexport default function RelateNodeGraph() {\n\tthis.nodes = new NodeMap(new RelateNodeFactory());\n}\nextend(RelateNodeGraph.prototype, {\n\tinsertEdgeEnds: function (ee) {\n\t\tfor (var i = ee.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tthis.nodes.add(e);\n\t\t}\n\t},\n\tgetNodeIterator: function () {\n\t\treturn this.nodes.iterator();\n\t},\n\tcopyNodesAndLabels: function (geomGraph, argIndex) {\n\t\tfor (var nodeIt = geomGraph.getNodeIterator(); nodeIt.hasNext(); ) {\n\t\t\tvar graphNode = nodeIt.next();\n\t\t\tvar newNode = this.nodes.addNode(graphNode.getCoordinate());\n\t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n\t\t}\n\t},\n\tbuild: function (geomGraph) {\n\t\tthis.computeIntersectionNodes(geomGraph, 0);\n\t\tthis.copyNodesAndLabels(geomGraph, 0);\n\t\tvar eeBuilder = new EdgeEndBuilder();\n\t\tvar eeList = eeBuilder.computeEdgeEnds(geomGraph.getEdgeIterator());\n\t\tthis.insertEdgeEnds(eeList);\n\t},\n\tcomputeIntersectionNodes: function (geomGraph, argIndex) {\n\t\tfor (var edgeIt = geomGraph.getEdgeIterator(); edgeIt.hasNext(); ) {\n\t\t\tvar e = edgeIt.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this.nodes.addNode(ei.coord);\n\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex); else {\n\t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RelateNodeGraph;\n\t}\n});\n","import RelateNodeGraph from '../relate/RelateNodeGraph';\nimport extend from '../../../../../extend';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nexport default function ConsistentAreaTester() {\n\tthis.li = new RobustLineIntersector();\n\tthis.geomGraph = null;\n\tthis.nodeGraph = new RelateNodeGraph();\n\tthis.invalidPoint = null;\n\tlet geomGraph = arguments[0];\n\tthis.geomGraph = geomGraph;\n}\nextend(ConsistentAreaTester.prototype, {\n\tisNodeEdgeAreaLabelsConsistent: function () {\n\t\tfor (var nodeIt = this.nodeGraph.getNodeIterator(); nodeIt.hasNext(); ) {\n\t\t\tvar node = nodeIt.next();\n\t\t\tif (!node.getEdges().isAreaLabelsConsistent(this.geomGraph)) {\n\t\t\t\tthis.invalidPoint = node.getCoordinate().copy();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tgetInvalidPoint: function () {\n\t\treturn this.invalidPoint;\n\t},\n\thasDuplicateRings: function () {\n\t\tfor (var nodeIt = this.nodeGraph.getNodeIterator(); nodeIt.hasNext(); ) {\n\t\t\tvar node = nodeIt.next();\n\t\t\tfor (var i = node.getEdges().iterator(); i.hasNext(); ) {\n\t\t\t\tvar eeb = i.next();\n\t\t\t\tif (eeb.getEdgeEnds().size() > 1) {\n\t\t\t\t\tthis.invalidPoint = eeb.getEdge().getCoordinate(0);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tisNodeConsistentArea: function () {\n\t\tvar intersector = this.geomGraph.computeSelfNodes(this.li, true, true);\n\t\tif (intersector.hasProperIntersection()) {\n\t\t\tthis.invalidPoint = intersector.getProperIntersectionPoint();\n\t\t\treturn false;\n\t\t}\n\t\tthis.nodeGraph.build(this.geomGraph);\n\t\treturn this.isNodeEdgeAreaLabelsConsistent();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ConsistentAreaTester;\n\t}\n});\n","import CGAlgorithms from '../../algorithm/CGAlgorithms';\nimport STRtree from '../../index/strtree/STRtree';\nimport IsValidOp from './IsValidOp';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Envelope from '../../geom/Envelope';\nexport default function IndexedNestedRingTester() {\n\tthis.graph = null;\n\tthis.rings = new ArrayList();\n\tthis.totalEnv = new Envelope();\n\tthis.index = null;\n\tthis.nestedPt = null;\n\tlet graph = arguments[0];\n\tthis.graph = graph;\n}\nextend(IndexedNestedRingTester.prototype, {\n\tbuildIndex: function () {\n\t\tthis.index = new STRtree();\n\t\tfor (var i = 0; i < this.rings.size(); i++) {\n\t\t\tvar ring = this.rings.get(i);\n\t\t\tvar env = ring.getEnvelopeInternal();\n\t\t\tthis.index.insert(env, ring);\n\t\t}\n\t},\n\tgetNestedPoint: function () {\n\t\treturn this.nestedPt;\n\t},\n\tisNonNested: function () {\n\t\tthis.buildIndex();\n\t\tfor (var i = 0; i < this.rings.size(); i++) {\n\t\t\tvar innerRing = this.rings.get(i);\n\t\t\tvar innerRingPts = innerRing.getCoordinates();\n\t\t\tvar results = this.index.query(innerRing.getEnvelopeInternal());\n\t\t\tfor (var j = 0; j < results.size(); j++) {\n\t\t\t\tvar searchRing = results.get(j);\n\t\t\t\tvar searchRingPts = searchRing.getCoordinates();\n\t\t\t\tif (innerRing === searchRing) continue;\n\t\t\t\tif (!innerRing.getEnvelopeInternal().intersects(searchRing.getEnvelopeInternal())) continue;\n\t\t\t\tvar innerRingPt = IsValidOp.findPtNotNode(innerRingPts, searchRing, this.graph);\n\t\t\t\tif (innerRingPt === null) continue;\n\t\t\t\tvar isInside = CGAlgorithms.isPointInRing(innerRingPt, searchRingPts);\n\t\t\t\tif (isInside) {\n\t\t\t\t\tthis.nestedPt = innerRingPt;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\tadd: function (ring) {\n\t\tthis.rings.add(ring);\n\t\tthis.totalEnv.expandToInclude(ring.getEnvelopeInternal());\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IndexedNestedRingTester;\n\t}\n});\n","import extend from '../../../../../extend';\nexport default function TopologyValidationError() {\n\tthis.errorType = null;\n\tthis.pt = null;\n\tif (arguments.length === 1) {\n\t\tlet errorType = arguments[0];\n\t\tTopologyValidationError.call(this, errorType, null);\n\t} else if (arguments.length === 2) {\n\t\tlet errorType = arguments[0], pt = arguments[1];\n\t\tthis.errorType = errorType;\n\t\tif (pt !== null) this.pt = pt.copy();\n\t}\n}\nextend(TopologyValidationError.prototype, {\n\tgetErrorType: function () {\n\t\treturn this.errorType;\n\t},\n\tgetMessage: function () {\n\t\treturn TopologyValidationError.errMsg[this.errorType];\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.pt;\n\t},\n\ttoString: function () {\n\t\tvar locStr = \"\";\n\t\tif (this.pt !== null) locStr = \" at or near point \" + this.pt;\n\t\treturn this.getMessage() + locStr;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TopologyValidationError;\n\t}\n});\nTopologyValidationError.ERROR = 0;\nTopologyValidationError.REPEATED_POINT = 1;\nTopologyValidationError.HOLE_OUTSIDE_SHELL = 2;\nTopologyValidationError.NESTED_HOLES = 3;\nTopologyValidationError.DISCONNECTED_INTERIOR = 4;\nTopologyValidationError.SELF_INTERSECTION = 5;\nTopologyValidationError.RING_SELF_INTERSECTION = 6;\nTopologyValidationError.NESTED_SHELLS = 7;\nTopologyValidationError.DUPLICATE_RINGS = 8;\nTopologyValidationError.TOO_FEW_POINTS = 9;\nTopologyValidationError.INVALID_COORDINATE = 10;\nTopologyValidationError.RING_NOT_CLOSED = 11;\nTopologyValidationError.errMsg = [\"Topology Validation Error\", \"Repeated Point\", \"Hole lies outside shell\", \"Holes are nested\", \"Interior is disconnected\", \"Self-intersection\", \"Ring Self-intersection\", \"Nested shells\", \"Duplicate Rings\", \"Too few distinct points in geometry component\", \"Invalid Coordinate\", \"Ring is not closed\"];\n","import TreeSet from '../../../../../java/util/TreeSet';\nimport LineString from '../../geom/LineString';\nimport CGAlgorithms from '../../algorithm/CGAlgorithms';\nimport Geometry from '../../geom/Geometry';\nimport ConnectedInteriorTester from './ConnectedInteriorTester';\nimport Coordinate from '../../geom/Coordinate';\nimport Point from '../../geom/Point';\nimport Polygon from '../../geom/Polygon';\nimport MultiPoint from '../../geom/MultiPoint';\nimport LinearRing from '../../geom/LinearRing';\nimport Double from '../../../../../java/lang/Double';\nimport extend from '../../../../../extend';\nimport MCPointInRing from '../../algorithm/MCPointInRing';\nimport GeometryGraph from '../../geomgraph/GeometryGraph';\nimport MultiPolygon from '../../geom/MultiPolygon';\nimport ConsistentAreaTester from './ConsistentAreaTester';\nimport GeometryCollection from '../../geom/GeometryCollection';\nimport IndexedNestedRingTester from './IndexedNestedRingTester';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport TopologyValidationError from './TopologyValidationError';\nimport Assert from '../../util/Assert';\nexport default function IsValidOp() {\n\tthis.parentGeometry = null;\n\tthis.isSelfTouchingRingFormingHoleValid = false;\n\tthis.validErr = null;\n\tlet parentGeometry = arguments[0];\n\tthis.parentGeometry = parentGeometry;\n}\nextend(IsValidOp.prototype, {\n\tcheckInvalidCoordinates: function () {\n\t\tif (arguments[0] instanceof Array) {\n\t\t\tlet coords = arguments[0];\n\t\t\tfor (var i = 0; i < coords.length; i++) {\n\t\t\t\tif (!IsValidOp.isValid(coords[i])) {\n\t\t\t\t\tthis.validErr = new TopologyValidationError(TopologyValidationError.INVALID_COORDINATE, coords[i]);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Polygon) {\n\t\t\tlet poly = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\t\tthis.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());\n\t\t\t\tif (this.validErr !== null) return null;\n\t\t\t}\n\t\t}\n\t},\n\tcheckHolesNotNested: function (p, graph) {\n\t\tvar nestedTester = new IndexedNestedRingTester(graph);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar innerHole = p.getInteriorRingN(i);\n\t\t\tnestedTester.add(innerHole);\n\t\t}\n\t\tvar isNonNested = nestedTester.isNonNested();\n\t\tif (!isNonNested) {\n\t\t\tthis.validErr = new TopologyValidationError(TopologyValidationError.NESTED_HOLES, nestedTester.getNestedPoint());\n\t\t}\n\t},\n\tcheckConsistentArea: function (graph) {\n\t\tvar cat = new ConsistentAreaTester(graph);\n\t\tvar isValidArea = cat.isNodeConsistentArea();\n\t\tif (!isValidArea) {\n\t\t\tthis.validErr = new TopologyValidationError(TopologyValidationError.SELF_INTERSECTION, cat.getInvalidPoint());\n\t\t\treturn null;\n\t\t}\n\t\tif (cat.hasDuplicateRings()) {\n\t\t\tthis.validErr = new TopologyValidationError(TopologyValidationError.DUPLICATE_RINGS, cat.getInvalidPoint());\n\t\t}\n\t},\n\tisValid: function () {\n\t\tthis.checkValid(this.parentGeometry);\n\t\treturn this.validErr === null;\n\t},\n\tcheckShellInsideHole: function (shell, hole, graph) {\n\t\tvar shellPts = shell.getCoordinates();\n\t\tvar holePts = hole.getCoordinates();\n\t\tvar shellPt = IsValidOp.findPtNotNode(shellPts, hole, graph);\n\t\tif (shellPt !== null) {\n\t\t\tvar insideHole = CGAlgorithms.isPointInRing(shellPt, holePts);\n\t\t\tif (!insideHole) {\n\t\t\t\treturn shellPt;\n\t\t\t}\n\t\t}\n\t\tvar holePt = IsValidOp.findPtNotNode(holePts, shell, graph);\n\t\tif (holePt !== null) {\n\t\t\tvar insideShell = CGAlgorithms.isPointInRing(holePt, shellPts);\n\t\t\tif (insideShell) {\n\t\t\t\treturn holePt;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tAssert.shouldNeverReachHere(\"points in shell and hole appear to be equal\");\n\t\treturn null;\n\t},\n\tcheckNoSelfIntersectingRings: function (graph) {\n\t\tfor (var i = graph.getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tthis.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());\n\t\t\tif (this.validErr !== null) return null;\n\t\t}\n\t},\n\tcheckConnectedInteriors: function (graph) {\n\t\tvar cit = new ConnectedInteriorTester(graph);\n\t\tif (!cit.isInteriorsConnected()) this.validErr = new TopologyValidationError(TopologyValidationError.DISCONNECTED_INTERIOR, cit.getCoordinate());\n\t},\n\tcheckNoSelfIntersectingRing: function (eiList) {\n\t\tvar nodeSet = new TreeSet();\n\t\tvar isFirst = true;\n\t\tfor (var i = eiList.iterator(); i.hasNext(); ) {\n\t\t\tvar ei = i.next();\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nodeSet.contains(ei.coord)) {\n\t\t\t\tthis.validErr = new TopologyValidationError(TopologyValidationError.RING_SELF_INTERSECTION, ei.coord);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tnodeSet.add(ei.coord);\n\t\t\t}\n\t\t}\n\t},\n\tcheckHolesInShell: function (p, graph) {\n\t\tvar shell = p.getExteriorRing();\n\t\tvar pir = new MCPointInRing(shell);\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tvar holePt = IsValidOp.findPtNotNode(hole.getCoordinates(), shell, graph);\n\t\t\tif (holePt === null) return null;\n\t\t\tvar outside = !pir.isInside(holePt);\n\t\t\tif (outside) {\n\t\t\t\tthis.validErr = new TopologyValidationError(TopologyValidationError.HOLE_OUTSIDE_SHELL, holePt);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tcheckTooFewPoints: function (graph) {\n\t\tif (graph.hasTooFewPoints()) {\n\t\t\tthis.validErr = new TopologyValidationError(TopologyValidationError.TOO_FEW_POINTS, graph.getInvalidPoint());\n\t\t\treturn null;\n\t\t}\n\t},\n\tgetValidationError: function () {\n\t\tthis.checkValid(this.parentGeometry);\n\t\treturn this.validErr;\n\t},\n\tcheckValid: function () {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tlet g = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n\t\t} else if (arguments[0] instanceof MultiPoint) {\n\t\t\tlet g = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n\t\t} else if (arguments[0] instanceof LinearRing) {\n\t\t\tlet g = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tthis.checkClosedRing(g);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tvar graph = new GeometryGraph(0, g);\n\t\t\tthis.checkTooFewPoints(graph);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tvar li = new RobustLineIntersector();\n\t\t\tgraph.computeSelfNodes(li, true, true);\n\t\t\tthis.checkNoSelfIntersectingRings(graph);\n\t\t} else if (arguments[0] instanceof LineString) {\n\t\t\tlet g = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(g.getCoordinates());\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tvar graph = new GeometryGraph(0, g);\n\t\t\tthis.checkTooFewPoints(graph);\n\t\t} else if (arguments[0] instanceof Polygon) {\n\t\t\tlet g = arguments[0];\n\t\t\tthis.checkInvalidCoordinates(g);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tthis.checkClosedRings(g);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tvar graph = new GeometryGraph(0, g);\n\t\t\tthis.checkTooFewPoints(graph);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tthis.checkConsistentArea(graph);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tif (!this.isSelfTouchingRingFormingHoleValid) {\n\t\t\t\tthis.checkNoSelfIntersectingRings(graph);\n\t\t\t\tif (this.validErr !== null) return null;\n\t\t\t}\n\t\t\tthis.checkHolesInShell(g, graph);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tthis.checkHolesNotNested(g, graph);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tthis.checkConnectedInteriors(graph);\n\t\t} else if (arguments[0] instanceof MultiPolygon) {\n\t\t\tlet g = arguments[0];\n\t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n\t\t\t\tvar p = g.getGeometryN(i);\n\t\t\t\tthis.checkInvalidCoordinates(p);\n\t\t\t\tif (this.validErr !== null) return null;\n\t\t\t\tthis.checkClosedRings(p);\n\t\t\t\tif (this.validErr !== null) return null;\n\t\t\t}\n\t\t\tvar graph = new GeometryGraph(0, g);\n\t\t\tthis.checkTooFewPoints(graph);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tthis.checkConsistentArea(graph);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tif (!this.isSelfTouchingRingFormingHoleValid) {\n\t\t\t\tthis.checkNoSelfIntersectingRings(graph);\n\t\t\t\tif (this.validErr !== null) return null;\n\t\t\t}\n\t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n\t\t\t\tvar p = g.getGeometryN(i);\n\t\t\t\tthis.checkHolesInShell(p, graph);\n\t\t\t\tif (this.validErr !== null) return null;\n\t\t\t}\n\t\t\tfor (var i = 0; i < g.getNumGeometries(); i++) {\n\t\t\t\tvar p = g.getGeometryN(i);\n\t\t\t\tthis.checkHolesNotNested(p, graph);\n\t\t\t\tif (this.validErr !== null) return null;\n\t\t\t}\n\t\t\tthis.checkShellsNotNested(g, graph);\n\t\t\tif (this.validErr !== null) return null;\n\t\t\tthis.checkConnectedInteriors(graph);\n\t\t} else if (arguments[0] instanceof GeometryCollection) {\n\t\t\tlet gc = arguments[0];\n\t\t\tfor (var i = 0; i < gc.getNumGeometries(); i++) {\n\t\t\t\tvar g = gc.getGeometryN(i);\n\t\t\t\tthis.checkValid(g);\n\t\t\t\tif (this.validErr !== null) return null;\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tlet g = arguments[0];\n\t\t\tthis.validErr = null;\n\t\t\tif (g.isEmpty()) return null;\n\t\t\tif (g instanceof Point) this.checkValid(g); else if (g instanceof MultiPoint) this.checkValid(g); else if (g instanceof LinearRing) this.checkValid(g); else if (g instanceof LineString) this.checkValid(g); else if (g instanceof Polygon) this.checkValid(g); else if (g instanceof MultiPolygon) this.checkValid(g); else if (g instanceof GeometryCollection) this.checkValid(g); else throw new UnsupportedOperationException(g.getClass().getName());\n\t\t}\n\t},\n\tsetSelfTouchingRingFormingHoleValid: function (isValid) {\n\t\tthis.isSelfTouchingRingFormingHoleValid = isValid;\n\t},\n\tcheckShellNotNested: function (shell, p, graph) {\n\t\tvar shellPts = shell.getCoordinates();\n\t\tvar polyShell = p.getExteriorRing();\n\t\tvar polyPts = polyShell.getCoordinates();\n\t\tvar shellPt = IsValidOp.findPtNotNode(shellPts, polyShell, graph);\n\t\tif (shellPt === null) return null;\n\t\tvar insidePolyShell = CGAlgorithms.isPointInRing(shellPt, polyPts);\n\t\tif (!insidePolyShell) return null;\n\t\tif (p.getNumInteriorRing() <= 0) {\n\t\t\tthis.validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, shellPt);\n\t\t\treturn null;\n\t\t}\n\t\tvar badNestedPt = null;\n\t\tfor (var i = 0; i < p.getNumInteriorRing(); i++) {\n\t\t\tvar hole = p.getInteriorRingN(i);\n\t\t\tbadNestedPt = this.checkShellInsideHole(shell, hole, graph);\n\t\t\tif (badNestedPt === null) return null;\n\t\t}\n\t\tthis.validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, badNestedPt);\n\t},\n\tcheckClosedRings: function (poly) {\n\t\tthis.checkClosedRing(poly.getExteriorRing());\n\t\tif (this.validErr !== null) return null;\n\t\tfor (var i = 0; i < poly.getNumInteriorRing(); i++) {\n\t\t\tthis.checkClosedRing(poly.getInteriorRingN(i));\n\t\t\tif (this.validErr !== null) return null;\n\t\t}\n\t},\n\tcheckClosedRing: function (ring) {\n\t\tif (!ring.isClosed()) {\n\t\t\tvar pt = null;\n\t\t\tif (ring.getNumPoints() >= 1) pt = ring.getCoordinateN(0);\n\t\t\tthis.validErr = new TopologyValidationError(TopologyValidationError.RING_NOT_CLOSED, pt);\n\t\t}\n\t},\n\tcheckShellsNotNested: function (mp, graph) {\n\t\tfor (var i = 0; i < mp.getNumGeometries(); i++) {\n\t\t\tvar p = mp.getGeometryN(i);\n\t\t\tvar shell = p.getExteriorRing();\n\t\t\tfor (var j = 0; j < mp.getNumGeometries(); j++) {\n\t\t\t\tif (i === j) continue;\n\t\t\t\tvar p2 = mp.getGeometryN(j);\n\t\t\t\tthis.checkShellNotNested(shell, p2, graph);\n\t\t\t\tif (this.validErr !== null) return null;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IsValidOp;\n\t}\n});\nIsValidOp.findPtNotNode = function (testCoords, searchRing, graph) {\n\tvar searchEdge = graph.findEdge(searchRing);\n\tvar eiList = searchEdge.getEdgeIntersectionList();\n\tfor (var i = 0; i < testCoords.length; i++) {\n\t\tvar pt = testCoords[i];\n\t\tif (!eiList.isIntersection(pt)) return pt;\n\t}\n\treturn null;\n};\nIsValidOp.isValid = function () {\n\tif (arguments[0] instanceof Geometry) {\n\t\tlet geom = arguments[0];\n\t\tvar isValidOp = new IsValidOp(geom);\n\t\treturn isValidOp.isValid();\n\t} else if (arguments[0] instanceof Coordinate) {\n\t\tlet coord = arguments[0];\n\t\tif (Double.isNaN(coord.x)) return false;\n\t\tif (Double.isInfinite(coord.x)) return false;\n\t\tif (Double.isNaN(coord.y)) return false;\n\t\tif (Double.isInfinite(coord.y)) return false;\n\t\treturn true;\n\t}\n};\n","import CGAlgorithms from '../../algorithm/CGAlgorithms';\nimport CoordinateList from '../../geom/CoordinateList';\nimport WKTWriter from '../../io/WKTWriter';\nimport CoordinateArraySequence from '../../geom/impl/CoordinateArraySequence';\nimport IsValidOp from '../valid/IsValidOp';\nimport LinearRing from '../../geom/LinearRing';\nimport extend from '../../../../../extend';\nimport Exception from '../../../../../java/lang/Exception';\nimport System from '../../../../../java/lang/System';\nimport CoordinateArrays from '../../geom/CoordinateArrays';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Comparator from '../../../../../java/util/Comparator';\nimport Assert from '../../util/Assert';\nexport default function EdgeRing() {\n\tthis.factory = null;\n\tthis.deList = new ArrayList();\n\tthis.lowestEdge = null;\n\tthis.ring = null;\n\tthis.ringPts = null;\n\tthis.holes = null;\n\tthis.shell = null;\n\tthis._isHole = null;\n\tthis._isProcessed = false;\n\tthis._isIncludedSet = false;\n\tthis._isIncluded = false;\n\tlet factory = arguments[0];\n\tthis.factory = factory;\n}\nextend(EdgeRing.prototype, {\n\tisIncluded: function () {\n\t\treturn this._isIncluded;\n\t},\n\tgetCoordinates: function () {\n\t\tif (this.ringPts === null) {\n\t\t\tvar coordList = new CoordinateList();\n\t\t\tfor (var i = this.deList.iterator(); i.hasNext(); ) {\n\t\t\t\tvar de = i.next();\n\t\t\t\tvar edge = de.getEdge();\n\t\t\t\tEdgeRing.addEdge(edge.getLine().getCoordinates(), de.getEdgeDirection(), coordList);\n\t\t\t}\n\t\t\tthis.ringPts = coordList.toCoordinateArray();\n\t\t}\n\t\treturn this.ringPts;\n\t},\n\tisIncludedSet: function () {\n\t\treturn this._isIncludedSet;\n\t},\n\tisValid: function () {\n\t\tthis.getCoordinates();\n\t\tif (this.ringPts.length <= 3) return false;\n\t\tthis.getRing();\n\t\treturn IsValidOp.isValid(this.ring);\n\t},\n\tbuild: function (startDE) {\n\t\tvar de = startDE;\n\t\tdo {\n\t\t\tthis.add(de);\n\t\t\tde.setRing(this);\n\t\t\tde = de.getNext();\n\t\t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n\t\t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n\t\t} while (de !== startDE);\n\t},\n\tisOuterHole: function () {\n\t\tif (!this._isHole) return false;\n\t\treturn !this.hasShell();\n\t},\n\tgetPolygon: function () {\n\t\tvar holeLR = null;\n\t\tif (this.holes !== null) {\n\t\t\tholeLR = new Array(this.holes.size()).fill(null);\n\t\t\tfor (var i = 0; i < this.holes.size(); i++) {\n\t\t\t\tholeLR[i] = this.holes.get(i);\n\t\t\t}\n\t\t}\n\t\tvar poly = this.factory.createPolygon(this.ring, holeLR);\n\t\treturn poly;\n\t},\n\tisHole: function () {\n\t\treturn this._isHole;\n\t},\n\tisProcessed: function () {\n\t\treturn this._isProcessed;\n\t},\n\taddHole: function () {\n\t\tif (arguments[0] instanceof LinearRing) {\n\t\t\tlet hole = arguments[0];\n\t\t\tif (this.holes === null) this.holes = new ArrayList();\n\t\t\tthis.holes.add(hole);\n\t\t} else if (arguments[0] instanceof EdgeRing) {\n\t\t\tlet holeER = arguments[0];\n\t\t\tholeER.setShell(this);\n\t\t\tvar hole = holeER.getRing();\n\t\t\tif (this.holes === null) this.holes = new ArrayList();\n\t\t\tthis.holes.add(hole);\n\t\t}\n\t},\n\tsetIncluded: function (isIncluded) {\n\t\tthis._isIncluded = isIncluded;\n\t\tthis._isIncludedSet = true;\n\t},\n\tgetOuterHole: function () {\n\t\tif (this.isHole()) return null;\n\t\tfor (var i = 0; i < this.deList.size(); i++) {\n\t\t\tvar de = this.deList.get(i);\n\t\t\tvar adjRing = de.getSym().getRing();\n\t\t\tif (adjRing.isOuterHole()) return adjRing;\n\t\t}\n\t\treturn null;\n\t},\n\tcomputeHole: function () {\n\t\tvar ring = this.getRing();\n\t\tthis._isHole = CGAlgorithms.isCCW(ring.getCoordinates());\n\t},\n\thasShell: function () {\n\t\treturn this.shell !== null;\n\t},\n\tisOuterShell: function () {\n\t\treturn this.getOuterHole() !== null;\n\t},\n\tgetLineString: function () {\n\t\tthis.getCoordinates();\n\t\treturn this.factory.createLineString(this.ringPts);\n\t},\n\ttoString: function () {\n\t\treturn WKTWriter.toLineString(new CoordinateArraySequence(this.getCoordinates()));\n\t},\n\tgetShell: function () {\n\t\tif (this.isHole()) return this.shell;\n\t\treturn this;\n\t},\n\tadd: function (de) {\n\t\tthis.deList.add(de);\n\t},\n\tgetRing: function () {\n\t\tif (this.ring !== null) return this.ring;\n\t\tthis.getCoordinates();\n\t\tif (this.ringPts.length < 3) System.out.println(this.ringPts);\n\t\ttry {\n\t\t\tthis.ring = this.factory.createLinearRing(this.ringPts);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof Exception) {\n\t\t\t\tSystem.out.println(this.ringPts);\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t\treturn this.ring;\n\t},\n\tupdateIncluded: function () {\n\t\tif (this.isHole()) return null;\n\t\tfor (var i = 0; i < this.deList.size(); i++) {\n\t\t\tvar de = this.deList.get(i);\n\t\t\tvar adjShell = de.getSym().getRing().getShell();\n\t\t\tif (adjShell !== null && adjShell.isIncludedSet()) {\n\t\t\t\tthis.setIncluded(!adjShell.isIncluded());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tsetShell: function (shell) {\n\t\tthis.shell = shell;\n\t},\n\tsetProcessed: function (isProcessed) {\n\t\tthis._isProcessed = isProcessed;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EdgeRing;\n\t}\n});\nEdgeRing.findDirEdgesInRing = function (startDE) {\n\tvar de = startDE;\n\tvar edges = new ArrayList();\n\tdo {\n\t\tedges.add(de);\n\t\tde = de.getNext();\n\t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n\t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n\t} while (de !== startDE);\n\treturn edges;\n};\nEdgeRing.addEdge = function (coords, isForward, coordList) {\n\tif (isForward) {\n\t\tfor (var i = 0; i < coords.length; i++) {\n\t\t\tcoordList.add(coords[i], false);\n\t\t}\n\t} else {\n\t\tfor (var i = coords.length - 1; i >= 0; i--) {\n\t\t\tcoordList.add(coords[i], false);\n\t\t}\n\t}\n};\nEdgeRing.findEdgeRingContaining = function (testEr, shellList) {\n\tvar testRing = testEr.getRing();\n\tvar testEnv = testRing.getEnvelopeInternal();\n\tvar testPt = testRing.getCoordinateN(0);\n\tvar minShell = null;\n\tvar minShellEnv = null;\n\tfor (var it = shellList.iterator(); it.hasNext(); ) {\n\t\tvar tryShell = it.next();\n\t\tvar tryShellRing = tryShell.getRing();\n\t\tvar tryShellEnv = tryShellRing.getEnvelopeInternal();\n\t\tif (tryShellEnv.equals(testEnv)) continue;\n\t\tif (!tryShellEnv.contains(testEnv)) continue;\n\t\ttestPt = CoordinateArrays.ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates());\n\t\tvar isContained = false;\n\t\tif (CGAlgorithms.isPointInRing(testPt, tryShellRing.getCoordinates())) isContained = true;\n\t\tif (isContained) {\n\t\t\tif (minShell === null || minShellEnv.contains(tryShellEnv)) {\n\t\t\t\tminShell = tryShell;\n\t\t\t\tminShellEnv = minShell.getRing().getEnvelopeInternal();\n\t\t\t}\n\t\t}\n\t}\n\treturn minShell;\n};\nfunction EnvelopeComparator() {}\nextend(EnvelopeComparator.prototype, {\n\tcompare: function (obj0, obj1) {\n\t\tvar r0 = obj0;\n\t\tvar r1 = obj1;\n\t\treturn r0.getRing().getEnvelope().compareTo(r1.getRing().getEnvelope());\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparator];\n\t},\n\tgetClass: function () {\n\t\treturn EnvelopeComparator;\n\t}\n});\nEdgeRing.EnvelopeComparator = EnvelopeComparator;\n","import PolygonizeDirectedEdge from './PolygonizeDirectedEdge';\nimport HashSet from '../../../../../java/util/HashSet';\nimport Stack from '../../../../../java/util/Stack';\nimport Node from '../../planargraph/Node';\nimport PolygonizeEdge from './PolygonizeEdge';\nimport extend from '../../../../../extend';\nimport EdgeRing from './EdgeRing';\nimport CoordinateArrays from '../../geom/CoordinateArrays';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Assert from '../../util/Assert';\nimport inherits from '../../../../../inherits';\nimport PlanarGraph from '../../planargraph/PlanarGraph';\nexport default function PolygonizeGraph() {\n\tPlanarGraph.apply(this);\n\tthis.factory = null;\n\tlet factory = arguments[0];\n\tthis.factory = factory;\n}\ninherits(PolygonizeGraph, PlanarGraph);\nextend(PolygonizeGraph.prototype, {\n\tfindEdgeRing: function (startDE) {\n\t\tvar er = new EdgeRing(this.factory);\n\t\ter.build(startDE);\n\t\treturn er;\n\t},\n\tcomputeDepthParity: function () {\n\t\tif (arguments.length === 0) {\n\t\t\twhile (true) {\n\t\t\t\tvar de = null;\n\t\t\t\tif (de === null) return null;\n\t\t\t\tthis.computeDepthParity(de);\n\t\t\t}\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet de = arguments[0];\n\t\t}\n\t},\n\tcomputeNextCWEdges: function () {\n\t\tfor (var iNode = this.nodeIterator(); iNode.hasNext(); ) {\n\t\t\tvar node = iNode.next();\n\t\t\tPolygonizeGraph.computeNextCWEdges(node);\n\t\t}\n\t},\n\taddEdge: function (line) {\n\t\tif (line.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tvar linePts = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\t\tif (linePts.length < 2) {\n\t\t\treturn null;\n\t\t}\n\t\tvar startPt = linePts[0];\n\t\tvar endPt = linePts[linePts.length - 1];\n\t\tvar nStart = this.getNode(startPt);\n\t\tvar nEnd = this.getNode(endPt);\n\t\tvar de0 = new PolygonizeDirectedEdge(nStart, nEnd, linePts[1], true);\n\t\tvar de1 = new PolygonizeDirectedEdge(nEnd, nStart, linePts[linePts.length - 2], false);\n\t\tvar edge = new PolygonizeEdge(line);\n\t\tedge.setDirectedEdges(de0, de1);\n\t\tthis.add(edge);\n\t},\n\tdeleteCutEdges: function () {\n\t\tthis.computeNextCWEdges();\n\t\tPolygonizeGraph.findLabeledEdgeRings(this.dirEdges);\n\t\tvar cutLines = new ArrayList();\n\t\tfor (var i = this.dirEdges.iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tif (de.isMarked()) continue;\n\t\t\tvar sym = de.getSym();\n\t\t\tif (de.getLabel() === sym.getLabel()) {\n\t\t\t\tde.setMarked(true);\n\t\t\t\tsym.setMarked(true);\n\t\t\t\tvar e = de.getEdge();\n\t\t\t\tcutLines.add(e.getLine());\n\t\t\t}\n\t\t}\n\t\treturn cutLines;\n\t},\n\tgetEdgeRings: function () {\n\t\tthis.computeNextCWEdges();\n\t\tPolygonizeGraph.label(this.dirEdges, -1);\n\t\tvar maximalRings = PolygonizeGraph.findLabeledEdgeRings(this.dirEdges);\n\t\tthis.convertMaximalToMinimalEdgeRings(maximalRings);\n\t\tvar edgeRingList = new ArrayList();\n\t\tfor (var i = this.dirEdges.iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tif (de.isMarked()) continue;\n\t\t\tif (de.isInRing()) continue;\n\t\t\tvar er = this.findEdgeRing(de);\n\t\t\tedgeRingList.add(er);\n\t\t}\n\t\treturn edgeRingList;\n\t},\n\tgetNode: function (pt) {\n\t\tvar node = this.findNode(pt);\n\t\tif (node === null) {\n\t\t\tnode = new Node(pt);\n\t\t\tthis.add(node);\n\t\t}\n\t\treturn node;\n\t},\n\tconvertMaximalToMinimalEdgeRings: function (ringEdges) {\n\t\tfor (var i = ringEdges.iterator(); i.hasNext(); ) {\n\t\t\tvar de = i.next();\n\t\t\tvar label = de.getLabel();\n\t\t\tvar intNodes = PolygonizeGraph.findIntersectionNodes(de, label);\n\t\t\tif (intNodes === null) continue;\n\t\t\tfor (var iNode = intNodes.iterator(); iNode.hasNext(); ) {\n\t\t\t\tvar node = iNode.next();\n\t\t\t\tPolygonizeGraph.computeNextCCWEdges(node, label);\n\t\t\t}\n\t\t}\n\t},\n\tdeleteDangles: function () {\n\t\tvar nodesToRemove = this.findNodesOfDegree(1);\n\t\tvar dangleLines = new HashSet();\n\t\tvar nodeStack = new Stack();\n\t\tfor (var i = nodesToRemove.iterator(); i.hasNext(); ) {\n\t\t\tnodeStack.push(i.next());\n\t\t}\n\t\twhile (!nodeStack.isEmpty()) {\n\t\t\tvar node = nodeStack.pop();\n\t\t\tPolygonizeGraph.deleteAllEdges(node);\n\t\t\tvar nodeOutEdges = node.getOutEdges().getEdges();\n\t\t\tfor (var i = nodeOutEdges.iterator(); i.hasNext(); ) {\n\t\t\t\tvar de = i.next();\n\t\t\t\tde.setMarked(true);\n\t\t\t\tvar sym = de.getSym();\n\t\t\t\tif (sym !== null) sym.setMarked(true);\n\t\t\t\tvar e = de.getEdge();\n\t\t\t\tdangleLines.add(e.getLine());\n\t\t\t\tvar toNode = de.getToNode();\n\t\t\t\tif (PolygonizeGraph.getDegreeNonDeleted(toNode) === 1) nodeStack.push(toNode);\n\t\t\t}\n\t\t}\n\t\treturn dangleLines;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PolygonizeGraph;\n\t}\n});\nPolygonizeGraph.findLabeledEdgeRings = function (dirEdges) {\n\tvar edgeRingStarts = new ArrayList();\n\tvar currLabel = 1;\n\tfor (var i = dirEdges.iterator(); i.hasNext(); ) {\n\t\tvar de = i.next();\n\t\tif (de.isMarked()) continue;\n\t\tif (de.getLabel() >= 0) continue;\n\t\tedgeRingStarts.add(de);\n\t\tvar edges = EdgeRing.findDirEdgesInRing(de);\n\t\tPolygonizeGraph.label(edges, currLabel);\n\t\tcurrLabel++;\n\t}\n\treturn edgeRingStarts;\n};\nPolygonizeGraph.getDegreeNonDeleted = function (node) {\n\tvar edges = node.getOutEdges().getEdges();\n\tvar degree = 0;\n\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\tvar de = i.next();\n\t\tif (!de.isMarked()) degree++;\n\t}\n\treturn degree;\n};\nPolygonizeGraph.deleteAllEdges = function (node) {\n\tvar edges = node.getOutEdges().getEdges();\n\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\tvar de = i.next();\n\t\tde.setMarked(true);\n\t\tvar sym = de.getSym();\n\t\tif (sym !== null) sym.setMarked(true);\n\t}\n};\nPolygonizeGraph.label = function (dirEdges, label) {\n\tfor (var i = dirEdges.iterator(); i.hasNext(); ) {\n\t\tvar de = i.next();\n\t\tde.setLabel(label);\n\t}\n};\nPolygonizeGraph.computeNextCWEdges = function (node) {\n\tvar deStar = node.getOutEdges();\n\tvar startDE = null;\n\tvar prevDE = null;\n\tfor (var i = deStar.getEdges().iterator(); i.hasNext(); ) {\n\t\tvar outDE = i.next();\n\t\tif (outDE.isMarked()) continue;\n\t\tif (startDE === null) startDE = outDE;\n\t\tif (prevDE !== null) {\n\t\t\tvar sym = prevDE.getSym();\n\t\t\tsym.setNext(outDE);\n\t\t}\n\t\tprevDE = outDE;\n\t}\n\tif (prevDE !== null) {\n\t\tvar sym = prevDE.getSym();\n\t\tsym.setNext(startDE);\n\t}\n};\nPolygonizeGraph.computeNextCCWEdges = function (node, label) {\n\tvar deStar = node.getOutEdges();\n\tvar firstOutDE = null;\n\tvar prevInDE = null;\n\tvar edges = deStar.getEdges();\n\tfor (var i = edges.size() - 1; i >= 0; i--) {\n\t\tvar de = edges.get(i);\n\t\tvar sym = de.getSym();\n\t\tvar outDE = null;\n\t\tif (de.getLabel() === label) outDE = de;\n\t\tvar inDE = null;\n\t\tif (sym.getLabel() === label) inDE = sym;\n\t\tif (outDE === null && inDE === null) continue;\n\t\tif (inDE !== null) {\n\t\t\tprevInDE = inDE;\n\t\t}\n\t\tif (outDE !== null) {\n\t\t\tif (prevInDE !== null) {\n\t\t\t\tprevInDE.setNext(outDE);\n\t\t\t\tprevInDE = null;\n\t\t\t}\n\t\t\tif (firstOutDE === null) firstOutDE = outDE;\n\t\t}\n\t}\n\tif (prevInDE !== null) {\n\t\tAssert.isTrue(firstOutDE !== null);\n\t\tprevInDE.setNext(firstOutDE);\n\t}\n};\nPolygonizeGraph.getDegree = function (node, label) {\n\tvar edges = node.getOutEdges().getEdges();\n\tvar degree = 0;\n\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\tvar de = i.next();\n\t\tif (de.getLabel() === label) degree++;\n\t}\n\treturn degree;\n};\nPolygonizeGraph.findIntersectionNodes = function (startDE, label) {\n\tvar de = startDE;\n\tvar intNodes = null;\n\tdo {\n\t\tvar node = de.getFromNode();\n\t\tif (PolygonizeGraph.getDegree(node, label) > 1) {\n\t\t\tif (intNodes === null) intNodes = new ArrayList();\n\t\t\tintNodes.add(node);\n\t\t}\n\t\tde = de.getNext();\n\t\tAssert.isTrue(de !== null, \"found null DE in ring\");\n\t\tAssert.isTrue(de === startDE || !de.isInRing(), \"found DE already in ring\");\n\t} while (de !== startDE);\n\treturn intNodes;\n};\n","import LineString from '../../geom/LineString';\nimport Geometry from '../../geom/Geometry';\nimport PolygonizeGraph from './PolygonizeGraph';\nimport hasInterface from '../../../../../hasInterface';\nimport GeometryFactory from '../../geom/GeometryFactory';\nimport Collection from '../../../../../java/util/Collection';\nimport extend from '../../../../../extend';\nimport Collections from '../../../../../java/util/Collections';\nimport EdgeRing from './EdgeRing';\nimport GeometryComponentFilter from '../../geom/GeometryComponentFilter';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function Polygonizer() {\n\tthis.lineStringAdder = new LineStringAdder(this);\n\tthis.graph = null;\n\tthis.dangles = new ArrayList();\n\tthis.cutEdges = new ArrayList();\n\tthis.invalidRingLines = new ArrayList();\n\tthis.holeList = null;\n\tthis.shellList = null;\n\tthis.polyList = null;\n\tthis.isCheckingRingsValid = true;\n\tthis.extractOnlyPolygonal = null;\n\tthis.geomFactory = null;\n\tif (arguments.length === 0) {\n\t\tPolygonizer.call(this, false);\n\t} else if (arguments.length === 1) {\n\t\tlet extractOnlyPolygonal = arguments[0];\n\t\tthis.extractOnlyPolygonal = extractOnlyPolygonal;\n\t}\n}\nextend(Polygonizer.prototype, {\n\tgetGeometry: function () {\n\t\tif (this.geomFactory === null) this.geomFactory = new GeometryFactory();\n\t\tthis.polygonize();\n\t\tif (this.extractOnlyPolygonal) {\n\t\t\treturn this.geomFactory.buildGeometry(this.polyList);\n\t\t}\n\t\treturn this.geomFactory.createGeometryCollection(GeometryFactory.toGeometryArray(this.polyList));\n\t},\n\tgetInvalidRingLines: function () {\n\t\tthis.polygonize();\n\t\treturn this.invalidRingLines;\n\t},\n\tfindValidRings: function (edgeRingList, validEdgeRingList, invalidRingList) {\n\t\tfor (var i = edgeRingList.iterator(); i.hasNext(); ) {\n\t\t\tvar er = i.next();\n\t\t\tif (er.isValid()) validEdgeRingList.add(er); else invalidRingList.add(er.getLineString());\n\t\t}\n\t},\n\tpolygonize: function () {\n\t\tif (this.polyList !== null) return null;\n\t\tthis.polyList = new ArrayList();\n\t\tif (this.graph === null) return null;\n\t\tthis.dangles = this.graph.deleteDangles();\n\t\tthis.cutEdges = this.graph.deleteCutEdges();\n\t\tvar edgeRingList = this.graph.getEdgeRings();\n\t\tvar validEdgeRingList = new ArrayList();\n\t\tthis.invalidRingLines = new ArrayList();\n\t\tif (this.isCheckingRingsValid) {\n\t\t\tthis.findValidRings(edgeRingList, validEdgeRingList, this.invalidRingLines);\n\t\t} else {\n\t\t\tvalidEdgeRingList = edgeRingList;\n\t\t}\n\t\tthis.findShellsAndHoles(validEdgeRingList);\n\t\tPolygonizer.assignHolesToShells(this.holeList, this.shellList);\n\t\tCollections.sort(this.shellList, new EdgeRing.EnvelopeComparator());\n\t\tvar includeAll = true;\n\t\tif (this.extractOnlyPolygonal) {\n\t\t\tPolygonizer.findDisjointShells(this.shellList);\n\t\t\tincludeAll = false;\n\t\t}\n\t\tthis.polyList = Polygonizer.extractPolygons(this.shellList, includeAll);\n\t},\n\tgetDangles: function () {\n\t\tthis.polygonize();\n\t\treturn this.dangles;\n\t},\n\tgetCutEdges: function () {\n\t\tthis.polygonize();\n\t\treturn this.cutEdges;\n\t},\n\tgetPolygons: function () {\n\t\tthis.polygonize();\n\t\treturn this.polyList;\n\t},\n\tadd: function () {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tlet geomList = arguments[0];\n\t\t\tfor (var i = geomList.iterator(); i.hasNext(); ) {\n\t\t\t\tvar geometry = i.next();\n\t\t\t\tthis.add(geometry);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof LineString) {\n\t\t\tlet line = arguments[0];\n\t\t\tthis.geomFactory = line.getFactory();\n\t\t\tif (this.graph === null) this.graph = new PolygonizeGraph(this.geomFactory);\n\t\t\tthis.graph.addEdge(line);\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tlet g = arguments[0];\n\t\t\tg.apply(this.lineStringAdder);\n\t\t}\n\t},\n\tsetCheckRingsValid: function (isCheckingRingsValid) {\n\t\tthis.isCheckingRingsValid = isCheckingRingsValid;\n\t},\n\tfindShellsAndHoles: function (edgeRingList) {\n\t\tthis.holeList = new ArrayList();\n\t\tthis.shellList = new ArrayList();\n\t\tfor (var i = edgeRingList.iterator(); i.hasNext(); ) {\n\t\t\tvar er = i.next();\n\t\t\ter.computeHole();\n\t\t\tif (er.isHole()) this.holeList.add(er); else this.shellList.add(er);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Polygonizer;\n\t}\n});\nPolygonizer.findOuterShells = function (shellList) {\n\tfor (var i = shellList.iterator(); i.hasNext(); ) {\n\t\tvar er = i.next();\n\t\tvar outerHoleER = er.getOuterHole();\n\t\tif (outerHoleER !== null && !outerHoleER.isProcessed()) {\n\t\t\ter.setIncluded(true);\n\t\t\touterHoleER.setProcessed(true);\n\t\t}\n\t}\n};\nPolygonizer.extractPolygons = function (shellList, includeAll) {\n\tvar polyList = new ArrayList();\n\tfor (var i = shellList.iterator(); i.hasNext(); ) {\n\t\tvar er = i.next();\n\t\tif (includeAll || er.isIncluded()) {\n\t\t\tpolyList.add(er.getPolygon());\n\t\t}\n\t}\n\treturn polyList;\n};\nPolygonizer.assignHolesToShells = function (holeList, shellList) {\n\tfor (var i = holeList.iterator(); i.hasNext(); ) {\n\t\tvar holeER = i.next();\n\t\tPolygonizer.assignHoleToShell(holeER, shellList);\n\t}\n};\nPolygonizer.assignHoleToShell = function (holeER, shellList) {\n\tvar shell = EdgeRing.findEdgeRingContaining(holeER, shellList);\n\tif (shell !== null) {\n\t\tshell.addHole(holeER);\n\t}\n};\nPolygonizer.findDisjointShells = function (shellList) {\n\tPolygonizer.findOuterShells(shellList);\n\tvar isMoreToScan = null;\n\tdo {\n\t\tisMoreToScan = false;\n\t\tfor (var i = shellList.iterator(); i.hasNext(); ) {\n\t\t\tvar er = i.next();\n\t\t\tif (er.isIncludedSet()) continue;\n\t\t\ter.updateIncluded();\n\t\t\tif (!er.isIncludedSet()) {\n\t\t\t\tisMoreToScan = true;\n\t\t\t}\n\t\t}\n\t} while (isMoreToScan);\n};\nfunction LineStringAdder() {\n\tthis.p = null;\n\tlet p = arguments[0];\n\tthis.p = p;\n}\nextend(LineStringAdder.prototype, {\n\tfilter: function (g) {\n\t\tif (g instanceof LineString) this.p.add(g);\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tgetClass: function () {\n\t\treturn LineStringAdder;\n\t}\n});\nPolygonizer.LineStringAdder = LineStringAdder;\n","import PointLocator from '../../algorithm/PointLocator';\nimport Location from '../../geom/Location';\nimport IntersectionMatrix from '../../geom/IntersectionMatrix';\nimport EdgeEndBuilder from './EdgeEndBuilder';\nimport extend from '../../../../../extend';\nimport NodeMap from '../../geomgraph/NodeMap';\nimport RelateNodeFactory from './RelateNodeFactory';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport RobustLineIntersector from '../../algorithm/RobustLineIntersector';\nimport Assert from '../../util/Assert';\nexport default function RelateComputer() {\n\tthis.li = new RobustLineIntersector();\n\tthis.ptLocator = new PointLocator();\n\tthis.arg = null;\n\tthis.nodes = new NodeMap(new RelateNodeFactory());\n\tthis.im = null;\n\tthis.isolatedEdges = new ArrayList();\n\tthis.invalidPoint = null;\n\tlet arg = arguments[0];\n\tthis.arg = arg;\n}\nextend(RelateComputer.prototype, {\n\tinsertEdgeEnds: function (ee) {\n\t\tfor (var i = ee.iterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tthis.nodes.add(e);\n\t\t}\n\t},\n\tcomputeProperIntersectionIM: function (intersector, im) {\n\t\tvar dimA = this.arg[0].getGeometry().getDimension();\n\t\tvar dimB = this.arg[1].getGeometry().getDimension();\n\t\tvar hasProper = intersector.hasProperIntersection();\n\t\tvar hasProperInterior = intersector.hasProperInteriorIntersection();\n\t\tif (dimA === 2 && dimB === 2) {\n\t\t\tif (hasProper) im.setAtLeast(\"212101212\");\n\t\t} else if (dimA === 2 && dimB === 1) {\n\t\t\tif (hasProper) im.setAtLeast(\"FFF0FFFF2\");\n\t\t\tif (hasProperInterior) im.setAtLeast(\"1FFFFF1FF\");\n\t\t} else if (dimA === 1 && dimB === 2) {\n\t\t\tif (hasProper) im.setAtLeast(\"F0FFFFFF2\");\n\t\t\tif (hasProperInterior) im.setAtLeast(\"1F1FFFFFF\");\n\t\t} else if (dimA === 1 && dimB === 1) {\n\t\t\tif (hasProperInterior) im.setAtLeast(\"0FFFFFFFF\");\n\t\t}\n\t},\n\tlabelIsolatedEdges: function (thisIndex, targetIndex) {\n\t\tfor (var ei = this.arg[thisIndex].getEdgeIterator(); ei.hasNext(); ) {\n\t\t\tvar e = ei.next();\n\t\t\tif (e.isIsolated()) {\n\t\t\t\tthis.labelIsolatedEdge(e, targetIndex, this.arg[targetIndex].getGeometry());\n\t\t\t\tthis.isolatedEdges.add(e);\n\t\t\t}\n\t\t}\n\t},\n\tlabelIsolatedEdge: function (e, targetIndex, target) {\n\t\tif (target.getDimension() > 0) {\n\t\t\tvar loc = this.ptLocator.locate(e.getCoordinate(), target);\n\t\t\te.getLabel().setAllLocations(targetIndex, loc);\n\t\t} else {\n\t\t\te.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);\n\t\t}\n\t},\n\tcomputeIM: function () {\n\t\tvar im = new IntersectionMatrix();\n\t\tim.set(Location.EXTERIOR, Location.EXTERIOR, 2);\n\t\tif (!this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal())) {\n\t\t\tthis.computeDisjointIM(im);\n\t\t\treturn im;\n\t\t}\n\t\tthis.arg[0].computeSelfNodes(this.li, false);\n\t\tthis.arg[1].computeSelfNodes(this.li, false);\n\t\tvar intersector = this.arg[0].computeEdgeIntersections(this.arg[1], this.li, false);\n\t\tthis.computeIntersectionNodes(0);\n\t\tthis.computeIntersectionNodes(1);\n\t\tthis.copyNodesAndLabels(0);\n\t\tthis.copyNodesAndLabels(1);\n\t\tthis.labelIsolatedNodes();\n\t\tthis.computeProperIntersectionIM(intersector, im);\n\t\tvar eeBuilder = new EdgeEndBuilder();\n\t\tvar ee0 = eeBuilder.computeEdgeEnds(this.arg[0].getEdgeIterator());\n\t\tthis.insertEdgeEnds(ee0);\n\t\tvar ee1 = eeBuilder.computeEdgeEnds(this.arg[1].getEdgeIterator());\n\t\tthis.insertEdgeEnds(ee1);\n\t\tthis.labelNodeEdges();\n\t\tthis.labelIsolatedEdges(0, 1);\n\t\tthis.labelIsolatedEdges(1, 0);\n\t\tthis.updateIM(im);\n\t\treturn im;\n\t},\n\tlabelNodeEdges: function () {\n\t\tfor (var ni = this.nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar node = ni.next();\n\t\t\tnode.getEdges().computeLabelling(this.arg);\n\t\t}\n\t},\n\tcopyNodesAndLabels: function (argIndex) {\n\t\tfor (var i = this.arg[argIndex].getNodeIterator(); i.hasNext(); ) {\n\t\t\tvar graphNode = i.next();\n\t\t\tvar newNode = this.nodes.addNode(graphNode.getCoordinate());\n\t\t\tnewNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n\t\t}\n\t},\n\tlabelIntersectionNodes: function (argIndex) {\n\t\tfor (var i = this.arg[argIndex].getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this.nodes.find(ei.coord);\n\t\t\t\tif (n.getLabel().isNull(argIndex)) {\n\t\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex); else n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tlabelIsolatedNode: function (n, targetIndex) {\n\t\tvar loc = this.ptLocator.locate(n.getCoordinate(), this.arg[targetIndex].getGeometry());\n\t\tn.getLabel().setAllLocations(targetIndex, loc);\n\t},\n\tcomputeIntersectionNodes: function (argIndex) {\n\t\tfor (var i = this.arg[argIndex].getEdgeIterator(); i.hasNext(); ) {\n\t\t\tvar e = i.next();\n\t\t\tvar eLoc = e.getLabel().getLocation(argIndex);\n\t\t\tfor (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\n\t\t\t\tvar ei = eiIt.next();\n\t\t\t\tvar n = this.nodes.addNode(ei.coord);\n\t\t\t\tif (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex); else {\n\t\t\t\t\tif (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tlabelIsolatedNodes: function () {\n\t\tfor (var ni = this.nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar n = ni.next();\n\t\t\tvar label = n.getLabel();\n\t\t\tAssert.isTrue(label.getGeometryCount() > 0, \"node with empty label found\");\n\t\t\tif (n.isIsolated()) {\n\t\t\t\tif (label.isNull(0)) this.labelIsolatedNode(n, 0); else this.labelIsolatedNode(n, 1);\n\t\t\t}\n\t\t}\n\t},\n\tupdateIM: function (im) {\n\t\tfor (var ei = this.isolatedEdges.iterator(); ei.hasNext(); ) {\n\t\t\tvar e = ei.next();\n\t\t\te.updateIM(im);\n\t\t}\n\t\tfor (var ni = this.nodes.iterator(); ni.hasNext(); ) {\n\t\t\tvar node = ni.next();\n\t\t\tnode.updateIM(im);\n\t\t\tnode.updateIMFromEdges(im);\n\t\t}\n\t},\n\tcomputeDisjointIM: function (im) {\n\t\tvar ga = this.arg[0].getGeometry();\n\t\tif (!ga.isEmpty()) {\n\t\t\tim.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());\n\t\t\tim.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());\n\t\t}\n\t\tvar gb = this.arg[1].getGeometry();\n\t\tif (!gb.isEmpty()) {\n\t\t\tim.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());\n\t\t\tim.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RelateComputer;\n\t}\n});\n","import LineString from '../../geom/LineString';\nimport Coordinate from '../../geom/Coordinate';\nimport Point from '../../geom/Point';\nimport Polygon from '../../geom/Polygon';\nimport extend from '../../../../../extend';\nexport default function RectangleContains() {\n\tthis.rectEnv = null;\n\tlet rectangle = arguments[0];\n\tthis.rectEnv = rectangle.getEnvelopeInternal();\n}\nextend(RectangleContains.prototype, {\n\tisContainedInBoundary: function (geom) {\n\t\tif (geom instanceof Polygon) return false;\n\t\tif (geom instanceof Point) return this.isPointContainedInBoundary(geom);\n\t\tif (geom instanceof LineString) return this.isLineStringContainedInBoundary(geom);\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar comp = geom.getGeometryN(i);\n\t\t\tif (!this.isContainedInBoundary(comp)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tisLineSegmentContainedInBoundary: function (p0, p1) {\n\t\tif (p0.equals(p1)) return this.isPointContainedInBoundary(p0);\n\t\tif (p0.x === p1.x) {\n\t\t\tif (p0.x === this.rectEnv.getMinX() || p0.x === this.rectEnv.getMaxX()) return true;\n\t\t} else if (p0.y === p1.y) {\n\t\t\tif (p0.y === this.rectEnv.getMinY() || p0.y === this.rectEnv.getMaxY()) return true;\n\t\t}\n\t\treturn false;\n\t},\n\tisLineStringContainedInBoundary: function (line) {\n\t\tvar seq = line.getCoordinateSequence();\n\t\tvar p0 = new Coordinate();\n\t\tvar p1 = new Coordinate();\n\t\tfor (var i = 0; i < seq.size() - 1; i++) {\n\t\t\tseq.getCoordinate(i, p0);\n\t\t\tseq.getCoordinate(i + 1, p1);\n\t\t\tif (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;\n\t\t}\n\t\treturn true;\n\t},\n\tisPointContainedInBoundary: function () {\n\t\tif (arguments[0] instanceof Point) {\n\t\t\tlet point = arguments[0];\n\t\t\treturn this.isPointContainedInBoundary(point.getCoordinate());\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet pt = arguments[0];\n\t\t\treturn pt.x === this.rectEnv.getMinX() || pt.x === this.rectEnv.getMaxX() || pt.y === this.rectEnv.getMinY() || pt.y === this.rectEnv.getMaxY();\n\t\t}\n\t},\n\tcontains: function (geom) {\n\t\tif (!this.rectEnv.contains(geom.getEnvelopeInternal())) return false;\n\t\tif (this.isContainedInBoundary(geom)) return false;\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RectangleContains;\n\t}\n});\nRectangleContains.contains = function (rectangle, b) {\n\tvar rc = new RectangleContains(rectangle);\n\treturn rc.contains(b);\n};\n","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport RobustLineIntersector from './RobustLineIntersector';\nimport Envelope from '../geom/Envelope';\nexport default function RectangleLineIntersector() {\n\tthis.li = new RobustLineIntersector();\n\tthis.rectEnv = null;\n\tthis.diagUp0 = null;\n\tthis.diagUp1 = null;\n\tthis.diagDown0 = null;\n\tthis.diagDown1 = null;\n\tlet rectEnv = arguments[0];\n\tthis.rectEnv = rectEnv;\n\tthis.diagUp0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMinY());\n\tthis.diagUp1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMaxY());\n\tthis.diagDown0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMaxY());\n\tthis.diagDown1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMinY());\n}\nextend(RectangleLineIntersector.prototype, {\n\tintersects: function (p0, p1) {\n\t\tvar segEnv = new Envelope(p0, p1);\n\t\tif (!this.rectEnv.intersects(segEnv)) return false;\n\t\tif (this.rectEnv.intersects(p0)) return true;\n\t\tif (this.rectEnv.intersects(p1)) return true;\n\t\tif (p0.compareTo(p1) > 0) {\n\t\t\tvar tmp = p0;\n\t\t\tp0 = p1;\n\t\t\tp1 = tmp;\n\t\t}\n\t\tvar isSegUpwards = false;\n\t\tif (p1.y > p0.y) isSegUpwards = true;\n\t\tif (isSegUpwards) {\n\t\t\tthis.li.computeIntersection(p0, p1, this.diagDown0, this.diagDown1);\n\t\t} else {\n\t\t\tthis.li.computeIntersection(p0, p1, this.diagUp0, this.diagUp1);\n\t\t}\n\t\tif (this.li.hasIntersection()) return true;\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RectangleLineIntersector;\n\t}\n});\n","import extend from '../../../../../extend';\nimport GeometryCollection from '../GeometryCollection';\nexport default function ShortCircuitedGeometryVisitor() {\n\tthis._isDone = false;\n}\nextend(ShortCircuitedGeometryVisitor.prototype, {\n\tapplyTo: function (geom) {\n\t\tfor (var i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {\n\t\t\tvar element = geom.getGeometryN(i);\n\t\t\tif (!(element instanceof GeometryCollection)) {\n\t\t\t\tthis.visit(element);\n\t\t\t\tif (this.isDone()) {\n\t\t\t\t\tthis._isDone = true;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else this.applyTo(element);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ShortCircuitedGeometryVisitor;\n\t}\n});\n","import Coordinate from '../../geom/Coordinate';\nimport Polygon from '../../geom/Polygon';\nimport RectangleLineIntersector from '../../algorithm/RectangleLineIntersector';\nimport extend from '../../../../../extend';\nimport ShortCircuitedGeometryVisitor from '../../geom/util/ShortCircuitedGeometryVisitor';\nimport SimplePointInAreaLocator from '../../algorithm/locate/SimplePointInAreaLocator';\nimport LinearComponentExtracter from '../../geom/util/LinearComponentExtracter';\nimport inherits from '../../../../../inherits';\nexport default function RectangleIntersects() {\n\tthis.rectangle = null;\n\tthis.rectEnv = null;\n\tlet rectangle = arguments[0];\n\tthis.rectangle = rectangle;\n\tthis.rectEnv = rectangle.getEnvelopeInternal();\n}\nextend(RectangleIntersects.prototype, {\n\tintersects: function (geom) {\n\t\tif (!this.rectEnv.intersects(geom.getEnvelopeInternal())) return false;\n\t\tvar visitor = new EnvelopeIntersectsVisitor(this.rectEnv);\n\t\tvisitor.applyTo(geom);\n\t\tif (visitor.intersects()) return true;\n\t\tvar ecpVisitor = new GeometryContainsPointVisitor(this.rectangle);\n\t\tecpVisitor.applyTo(geom);\n\t\tif (ecpVisitor.containsPoint()) return true;\n\t\tvar riVisitor = new RectangleIntersectsSegmentVisitor(this.rectangle);\n\t\triVisitor.applyTo(geom);\n\t\tif (riVisitor.intersects()) return true;\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RectangleIntersects;\n\t}\n});\nRectangleIntersects.intersects = function (rectangle, b) {\n\tvar rp = new RectangleIntersects(rectangle);\n\treturn rp.intersects(b);\n};\nfunction EnvelopeIntersectsVisitor() {\n\tShortCircuitedGeometryVisitor.apply(this);\n\tthis.rectEnv = null;\n\tthis._intersects = false;\n\tlet rectEnv = arguments[0];\n\tthis.rectEnv = rectEnv;\n}\ninherits(EnvelopeIntersectsVisitor, ShortCircuitedGeometryVisitor);\nextend(EnvelopeIntersectsVisitor.prototype, {\n\tisDone: function () {\n\t\treturn this._intersects === true;\n\t},\n\tvisit: function (element) {\n\t\tvar elementEnv = element.getEnvelopeInternal();\n\t\tif (!this.rectEnv.intersects(elementEnv)) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.rectEnv.contains(elementEnv)) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (elementEnv.getMinX() >= this.rectEnv.getMinX() && elementEnv.getMaxX() <= this.rectEnv.getMaxX()) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t\tif (elementEnv.getMinY() >= this.rectEnv.getMinY() && elementEnv.getMaxY() <= this.rectEnv.getMaxY()) {\n\t\t\tthis._intersects = true;\n\t\t\treturn null;\n\t\t}\n\t},\n\tintersects: function () {\n\t\treturn this._intersects;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn EnvelopeIntersectsVisitor;\n\t}\n});\nfunction GeometryContainsPointVisitor() {\n\tShortCircuitedGeometryVisitor.apply(this);\n\tthis.rectSeq = null;\n\tthis.rectEnv = null;\n\tthis._containsPoint = false;\n\tlet rectangle = arguments[0];\n\tthis.rectSeq = rectangle.getExteriorRing().getCoordinateSequence();\n\tthis.rectEnv = rectangle.getEnvelopeInternal();\n}\ninherits(GeometryContainsPointVisitor, ShortCircuitedGeometryVisitor);\nextend(GeometryContainsPointVisitor.prototype, {\n\tisDone: function () {\n\t\treturn this._containsPoint === true;\n\t},\n\tvisit: function (geom) {\n\t\tif (!(geom instanceof Polygon)) return null;\n\t\tvar elementEnv = geom.getEnvelopeInternal();\n\t\tif (!this.rectEnv.intersects(elementEnv)) return null;\n\t\tvar rectPt = new Coordinate();\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tthis.rectSeq.getCoordinate(i, rectPt);\n\t\t\tif (!elementEnv.contains(rectPt)) continue;\n\t\t\tif (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {\n\t\t\t\tthis._containsPoint = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tcontainsPoint: function () {\n\t\treturn this._containsPoint;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryContainsPointVisitor;\n\t}\n});\nfunction RectangleIntersectsSegmentVisitor() {\n\tShortCircuitedGeometryVisitor.apply(this);\n\tthis.rectEnv = null;\n\tthis.rectIntersector = null;\n\tthis.hasIntersection = false;\n\tthis.p0 = new Coordinate();\n\tthis.p1 = new Coordinate();\n\tlet rectangle = arguments[0];\n\tthis.rectEnv = rectangle.getEnvelopeInternal();\n\tthis.rectIntersector = new RectangleLineIntersector(this.rectEnv);\n}\ninherits(RectangleIntersectsSegmentVisitor, ShortCircuitedGeometryVisitor);\nextend(RectangleIntersectsSegmentVisitor.prototype, {\n\tintersects: function () {\n\t\treturn this.hasIntersection;\n\t},\n\tisDone: function () {\n\t\treturn this.hasIntersection === true;\n\t},\n\tvisit: function (geom) {\n\t\tvar elementEnv = geom.getEnvelopeInternal();\n\t\tif (!this.rectEnv.intersects(elementEnv)) return null;\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tthis.checkIntersectionWithLineStrings(lines);\n\t},\n\tcheckIntersectionWithLineStrings: function (lines) {\n\t\tfor (var i = lines.iterator(); i.hasNext(); ) {\n\t\t\tvar testLine = i.next();\n\t\t\tthis.checkIntersectionWithSegments(testLine);\n\t\t\tif (this.hasIntersection) return null;\n\t\t}\n\t},\n\tcheckIntersectionWithSegments: function (testLine) {\n\t\tvar seq1 = testLine.getCoordinateSequence();\n\t\tfor (var j = 1; j < seq1.size(); j++) {\n\t\t\tseq1.getCoordinate(j - 1, this.p0);\n\t\t\tseq1.getCoordinate(j, this.p1);\n\t\t\tif (this.rectIntersector.intersects(this.p0, this.p1)) {\n\t\t\t\tthis.hasIntersection = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RectangleIntersectsSegmentVisitor;\n\t}\n});\n","import Geometry from '../../geom/Geometry';\nimport hasInterface from '../../../../../hasInterface';\nimport RelateComputer from './RelateComputer';\nimport BoundaryNodeRule from '../../algorithm/BoundaryNodeRule';\nimport extend from '../../../../../extend';\nimport GeometryGraphOperation from '../GeometryGraphOperation';\nimport RectangleContains from '../predicate/RectangleContains';\nimport inherits from '../../../../../inherits';\nimport RectangleIntersects from '../predicate/RectangleIntersects';\nexport default function RelateOp() {\n\tthis._relate = null;\n\tif (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tGeometryGraphOperation.call(this, g0, g1);\n\t\tthis._relate = new RelateComputer(this.arg);\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];\n\t\tGeometryGraphOperation.call(this, g0, g1, boundaryNodeRule);\n\t\tthis._relate = new RelateComputer(this.arg);\n\t}\n}\ninherits(RelateOp, GeometryGraphOperation);\nextend(RelateOp.prototype, {\n\tgetIntersectionMatrix: function () {\n\t\treturn this._relate.computeIM();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn RelateOp;\n\t}\n});\nRelateOp.covers = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;\n\tif (g1.isRectangle()) {\n\t\treturn true;\n\t}\n\treturn RelateOp.relate(g1, g2).isCovers();\n};\nRelateOp.intersects = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\tif (g1.isRectangle()) {\n\t\treturn RectangleIntersects.intersects(g1, g2);\n\t}\n\tif (g2.isRectangle()) {\n\t\treturn RectangleIntersects.intersects(g2, g1);\n\t}\n\treturn RelateOp.relate(g1, g2).isIntersects();\n};\nRelateOp.touches = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\treturn RelateOp.relate(g1, g2).isTouches(g1.getDimension(), g2.getDimension());\n};\nRelateOp.within = function (g1, g2) {\n\treturn g2.contains(g1);\n};\nRelateOp.coveredBy = function (g1, g2) {\n\treturn RelateOp.covers(g2, g1);\n};\nRelateOp.relate = function () {\n\tif (arguments.length === 2) {\n\t\tlet a = arguments[0], b = arguments[1];\n\t\tvar relOp = new RelateOp(a, b);\n\t\tvar im = relOp.getIntersectionMatrix();\n\t\treturn im;\n\t} else if (arguments.length === 3) {\n\t\tif (typeof arguments[2] === \"string\" && (arguments[0] instanceof Geometry && arguments[1] instanceof Geometry)) {\n\t\t\tlet g1 = arguments[0], g2 = arguments[1], intersectionPattern = arguments[2];\n\t\t\treturn RelateOp.relateWithCheck(g1, g2).matches(intersectionPattern);\n\t\t} else if (hasInterface(arguments[2], BoundaryNodeRule) && (arguments[0] instanceof Geometry && arguments[1] instanceof Geometry)) {\n\t\t\tlet a = arguments[0], b = arguments[1], boundaryNodeRule = arguments[2];\n\t\t\tvar relOp = new RelateOp(a, b, boundaryNodeRule);\n\t\t\tvar im = relOp.getIntersectionMatrix();\n\t\t\treturn im;\n\t\t}\n\t}\n};\nRelateOp.overlaps = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\treturn RelateOp.relate(g1, g2).isOverlaps(g1.getDimension(), g2.getDimension());\n};\nRelateOp.disjoint = function (g1, g2) {\n\treturn !g1.intersects(g2);\n};\nRelateOp.relateWithCheck = function (g1, g2) {\n\tg1.checkNotGeometryCollection(g1);\n\tg1.checkNotGeometryCollection(g2);\n\treturn RelateOp.relate(g1, g2);\n};\nRelateOp.crosses = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n\treturn RelateOp.relate(g1, g2).isCrosses(g1.getDimension(), g2.getDimension());\n};\nRelateOp.contains = function (g1, g2) {\n\tif (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;\n\tif (g1.isRectangle()) {\n\t\treturn RectangleContains.contains(g1, g2);\n\t}\n\treturn RelateOp.relate(g1, g2).isContains();\n};\n","import extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nexport default function GeometryCombiner() {\n\tthis.geomFactory = null;\n\tthis.skipEmpty = false;\n\tthis.inputGeoms = null;\n\tlet geoms = arguments[0];\n\tthis.geomFactory = GeometryCombiner.extractFactory(geoms);\n\tthis.inputGeoms = geoms;\n}\nextend(GeometryCombiner.prototype, {\n\textractElements: function (geom, elems) {\n\t\tif (geom === null) return null;\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar elemGeom = geom.getGeometryN(i);\n\t\t\tif (this.skipEmpty && elemGeom.isEmpty()) continue;\n\t\t\telems.add(elemGeom);\n\t\t}\n\t},\n\tcombine: function () {\n\t\tvar elems = new ArrayList();\n\t\tfor (var i = this.inputGeoms.iterator(); i.hasNext(); ) {\n\t\t\tvar g = i.next();\n\t\t\tthis.extractElements(g, elems);\n\t\t}\n\t\tif (elems.size() === 0) {\n\t\t\tif (this.geomFactory !== null) {\n\t\t\t\treturn this.geomFactory.createGeometryCollection(null);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\treturn this.geomFactory.buildGeometry(elems);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryCombiner;\n\t}\n});\nGeometryCombiner.combine = function () {\n\tif (arguments.length === 1) {\n\t\tlet geoms = arguments[0];\n\t\tvar combiner = new GeometryCombiner(geoms);\n\t\treturn combiner.combine();\n\t} else if (arguments.length === 2) {\n\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\tvar combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));\n\t\treturn combiner.combine();\n\t} else if (arguments.length === 3) {\n\t\tlet g0 = arguments[0], g1 = arguments[1], g2 = arguments[2];\n\t\tvar combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1, g2));\n\t\treturn combiner.combine();\n\t}\n};\nGeometryCombiner.extractFactory = function (geoms) {\n\tif (geoms.isEmpty()) return null;\n\treturn geoms.iterator().next().getFactory();\n};\nGeometryCombiner.createList = function () {\n\tif (arguments.length === 2) {\n\t\tlet obj0 = arguments[0], obj1 = arguments[1];\n\t\tvar list = new ArrayList();\n\t\tlist.add(obj0);\n\t\tlist.add(obj1);\n\t\treturn list;\n\t} else if (arguments.length === 3) {\n\t\tlet obj0 = arguments[0], obj1 = arguments[1], obj2 = arguments[2];\n\t\tvar list = new ArrayList();\n\t\tlist.add(obj0);\n\t\tlist.add(obj1);\n\t\tlist.add(obj2);\n\t\treturn list;\n\t}\n};\n","import PointLocator from '../../algorithm/PointLocator';\nimport Location from '../../geom/Location';\nimport TreeSet from '../../../../../java/util/TreeSet';\nimport extend from '../../../../../extend';\nimport GeometryCombiner from '../../geom/util/GeometryCombiner';\nimport CoordinateArrays from '../../geom/CoordinateArrays';\nexport default function PointGeometryUnion() {\n\tthis.pointGeom = null;\n\tthis.otherGeom = null;\n\tthis.geomFact = null;\n\tlet pointGeom = arguments[0], otherGeom = arguments[1];\n\tthis.pointGeom = pointGeom;\n\tthis.otherGeom = otherGeom;\n\tthis.geomFact = otherGeom.getFactory();\n}\nextend(PointGeometryUnion.prototype, {\n\tunion: function () {\n\t\tvar locater = new PointLocator();\n\t\tvar exteriorCoords = new TreeSet();\n\t\tfor (var i = 0; i < this.pointGeom.getNumGeometries(); i++) {\n\t\t\tvar point = this.pointGeom.getGeometryN(i);\n\t\t\tvar coord = point.getCoordinate();\n\t\t\tvar loc = locater.locate(coord, this.otherGeom);\n\t\t\tif (loc === Location.EXTERIOR) exteriorCoords.add(coord);\n\t\t}\n\t\tif (exteriorCoords.size() === 0) return this.otherGeom;\n\t\tvar ptComp = null;\n\t\tvar coords = CoordinateArrays.toCoordinateArray(exteriorCoords);\n\t\tif (coords.length === 1) {\n\t\t\tptComp = this.geomFact.createPoint(coords[0]);\n\t\t} else {\n\t\t\tptComp = this.geomFact.createMultiPointFromCoords(coords);\n\t\t}\n\t\treturn GeometryCombiner.combine(ptComp, this.otherGeom);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PointGeometryUnion;\n\t}\n});\nPointGeometryUnion.union = function (pointGeom, otherGeom) {\n\tvar unioner = new PointGeometryUnion(pointGeom, otherGeom);\n\treturn unioner.union();\n};\n","import extend from '../../../../../extend';\nimport GeometryCollection from '../GeometryCollection';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport GeometryFilter from '../GeometryFilter';\nexport default function GeometryExtracter() {\n\tthis.sortIndex = -1;\n\tthis.comps = null;\n\tlet sortIndex = arguments[0], comps = arguments[1];\n\tthis.sortIndex = sortIndex;\n\tthis.comps = comps;\n}\nextend(GeometryExtracter.prototype, {\n\tfilter: function (geom) {\n\t\tif (this.sortIndex === -1 || geom.getSortIndex() === this.sortIndex) this.comps.add(geom);\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryFilter];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryExtracter;\n\t}\n});\nGeometryExtracter.extract = function () {\n\tif (arguments.length === 2) {\n\t\tlet geom = arguments[0], sortIndex = arguments[1];\n\t\treturn GeometryExtracter.extract(geom, sortIndex, new ArrayList());\n\t} else if (arguments.length === 3) {\n\t\tlet geom = arguments[0], sortIndex = arguments[1], list = arguments[2];\n\t\tif (geom.getSortIndex() === sortIndex) {\n\t\t\tlist.add(geom);\n\t\t} else if (geom instanceof GeometryCollection) {\n\t\t\tgeom.apply(new GeometryExtracter(sortIndex, list));\n\t\t}\n\t\treturn list;\n\t}\n};\n","import PolygonExtracter from '../../geom/util/PolygonExtracter';\nimport STRtree from '../../index/strtree/STRtree';\nimport Geometry from '../../geom/Geometry';\nimport hasInterface from '../../../../../hasInterface';\nimport GeometryFactory from '../../geom/GeometryFactory';\nimport extend from '../../../../../extend';\nimport GeometryCombiner from '../../geom/util/GeometryCombiner';\nimport Polygonal from '../../geom/Polygonal';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport List from '../../../../../java/util/List';\nexport default function CascadedPolygonUnion() {\n\tthis.inputPolys = null;\n\tthis.geomFactory = null;\n\tlet polys = arguments[0];\n\tthis.inputPolys = polys;\n\tif (this.inputPolys === null) this.inputPolys = new ArrayList();\n}\nextend(CascadedPolygonUnion.prototype, {\n\treduceToGeometries: function (geomTree) {\n\t\tvar geoms = new ArrayList();\n\t\tfor (var i = geomTree.iterator(); i.hasNext(); ) {\n\t\t\tvar o = i.next();\n\t\t\tvar geom = null;\n\t\t\tif (hasInterface(o, List)) {\n\t\t\t\tgeom = this.unionTree(o);\n\t\t\t} else if (o instanceof Geometry) {\n\t\t\t\tgeom = o;\n\t\t\t}\n\t\t\tgeoms.add(geom);\n\t\t}\n\t\treturn geoms;\n\t},\n\textractByEnvelope: function (env, geom, disjointGeoms) {\n\t\tvar intersectingGeoms = new ArrayList();\n\t\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\t\tvar elem = geom.getGeometryN(i);\n\t\t\tif (elem.getEnvelopeInternal().intersects(env)) intersectingGeoms.add(elem); else disjointGeoms.add(elem);\n\t\t}\n\t\treturn this.geomFactory.buildGeometry(intersectingGeoms);\n\t},\n\tunionOptimized: function (g0, g1) {\n\t\tvar g0Env = g0.getEnvelopeInternal();\n\t\tvar g1Env = g1.getEnvelopeInternal();\n\t\tif (!g0Env.intersects(g1Env)) {\n\t\t\tvar combo = GeometryCombiner.combine(g0, g1);\n\t\t\treturn combo;\n\t\t}\n\t\tif (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) return this.unionActual(g0, g1);\n\t\tvar commonEnv = g0Env.intersection(g1Env);\n\t\treturn this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);\n\t},\n\tunion: function () {\n\t\tif (this.inputPolys === null) throw new IllegalStateException(\"union() method cannot be called twice\");\n\t\tif (this.inputPolys.isEmpty()) return null;\n\t\tthis.geomFactory = this.inputPolys.iterator().next().getFactory();\n\t\tvar index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);\n\t\tfor (var i = this.inputPolys.iterator(); i.hasNext(); ) {\n\t\t\tvar item = i.next();\n\t\t\tindex.insert(item.getEnvelopeInternal(), item);\n\t\t}\n\t\tthis.inputPolys = null;\n\t\tvar itemTree = index.itemsTree();\n\t\tvar unionAll = this.unionTree(itemTree);\n\t\treturn unionAll;\n\t},\n\tbinaryUnion: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geoms = arguments[0];\n\t\t\treturn this.binaryUnion(geoms, 0, geoms.size());\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet geoms = arguments[0], start = arguments[1], end = arguments[2];\n\t\t\tif (end - start <= 1) {\n\t\t\t\tvar g0 = CascadedPolygonUnion.getGeometry(geoms, start);\n\t\t\t\treturn this.unionSafe(g0, null);\n\t\t\t} else if (end - start === 2) {\n\t\t\t\treturn this.unionSafe(CascadedPolygonUnion.getGeometry(geoms, start), CascadedPolygonUnion.getGeometry(geoms, start + 1));\n\t\t\t} else {\n\t\t\t\tvar mid = Math.trunc((end + start) / 2);\n\t\t\t\tvar g0 = this.binaryUnion(geoms, start, mid);\n\t\t\t\tvar g1 = this.binaryUnion(geoms, mid, end);\n\t\t\t\treturn this.unionSafe(g0, g1);\n\t\t\t}\n\t\t}\n\t},\n\trepeatedUnion: function (geoms) {\n\t\tvar union = null;\n\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\tvar g = i.next();\n\t\t\tif (union === null) union = g.copy(); else union = union.union(g);\n\t\t}\n\t\treturn union;\n\t},\n\tunionSafe: function (g0, g1) {\n\t\tif (g0 === null && g1 === null) return null;\n\t\tif (g0 === null) return g1.copy();\n\t\tif (g1 === null) return g0.copy();\n\t\treturn this.unionOptimized(g0, g1);\n\t},\n\tunionActual: function (g0, g1) {\n\t\treturn CascadedPolygonUnion.restrictToPolygons(g0.union(g1));\n\t},\n\tunionTree: function (geomTree) {\n\t\tvar geoms = this.reduceToGeometries(geomTree);\n\t\tvar union = this.binaryUnion(geoms);\n\t\treturn union;\n\t},\n\tunionUsingEnvelopeIntersection: function (g0, g1, common) {\n\t\tvar disjointPolys = new ArrayList();\n\t\tvar g0Int = this.extractByEnvelope(common, g0, disjointPolys);\n\t\tvar g1Int = this.extractByEnvelope(common, g1, disjointPolys);\n\t\tvar union = this.unionActual(g0Int, g1Int);\n\t\tdisjointPolys.add(union);\n\t\tvar overallUnion = GeometryCombiner.combine(disjointPolys);\n\t\treturn overallUnion;\n\t},\n\tbufferUnion: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet geoms = arguments[0];\n\t\t\tvar factory = geoms.get(0).getFactory();\n\t\t\tvar gColl = factory.buildGeometry(geoms);\n\t\t\tvar unionAll = gColl.buffer(0.0);\n\t\t\treturn unionAll;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet g0 = arguments[0], g1 = arguments[1];\n\t\t\tvar factory = g0.getFactory();\n\t\t\tvar gColl = factory.createGeometryCollection([g0, g1]);\n\t\t\tvar unionAll = gColl.buffer(0.0);\n\t\t\treturn unionAll;\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn CascadedPolygonUnion;\n\t}\n});\nCascadedPolygonUnion.restrictToPolygons = function (g) {\n\tif (hasInterface(g, Polygonal)) {\n\t\treturn g;\n\t}\n\tvar polygons = PolygonExtracter.getPolygons(g);\n\tif (polygons.size() === 1) return polygons.get(0);\n\treturn g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons));\n};\nCascadedPolygonUnion.getGeometry = function (list, index) {\n\tif (index >= list.size()) return null;\n\treturn list.get(index);\n};\nCascadedPolygonUnion.union = function (polys) {\n\tvar op = new CascadedPolygonUnion(polys);\n\treturn op.union();\n};\nCascadedPolygonUnion.STRTREE_NODE_CAPACITY = 4;\n","import Geometry from '../../geom/Geometry';\nimport PointGeometryUnion from './PointGeometryUnion';\nimport hasInterface from '../../../../../hasInterface';\nimport Collection from '../../../../../java/util/Collection';\nimport SnapIfNeededOverlayOp from '../overlay/snap/SnapIfNeededOverlayOp';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport GeometryExtracter from '../../geom/util/GeometryExtracter';\nimport OverlayOp from '../overlay/OverlayOp';\nimport CascadedPolygonUnion from './CascadedPolygonUnion';\nexport default function UnaryUnionOp() {\n\tthis.polygons = new ArrayList();\n\tthis.lines = new ArrayList();\n\tthis.points = new ArrayList();\n\tthis.geomFact = null;\n\tif (arguments.length === 1) {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tlet geoms = arguments[0];\n\t\t\tthis.extract(geoms);\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tlet geom = arguments[0];\n\t\t\tthis.extract(geom);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet geoms = arguments[0], geomFact = arguments[1];\n\t\tthis.geomFact = geomFact;\n\t\tthis.extract(geoms);\n\t}\n}\nextend(UnaryUnionOp.prototype, {\n\tunionNoOpt: function (g0) {\n\t\tvar empty = this.geomFact.createPoint();\n\t\treturn SnapIfNeededOverlayOp.overlayOp(g0, empty, OverlayOp.UNION);\n\t},\n\tunionWithNull: function (g0, g1) {\n\t\tif (g0 === null && g1 === null) return null;\n\t\tif (g1 === null) return g0;\n\t\tif (g0 === null) return g1;\n\t\treturn g0.union(g1);\n\t},\n\textract: function () {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tlet geoms = arguments[0];\n\t\t\tfor (var i = geoms.iterator(); i.hasNext(); ) {\n\t\t\t\tvar geom = i.next();\n\t\t\t\tthis.extract(geom);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tlet geom = arguments[0];\n\t\t\tif (this.geomFact === null) this.geomFact = geom.getFactory();\n\t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_POLYGON, this.polygons);\n\t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_LINESTRING, this.lines);\n\t\t\tGeometryExtracter.extract(geom, Geometry.SORTINDEX_POINT, this.points);\n\t\t}\n\t},\n\tunion: function () {\n\t\tif (this.geomFact === null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar unionPoints = null;\n\t\tif (this.points.size() > 0) {\n\t\t\tvar ptGeom = this.geomFact.buildGeometry(this.points);\n\t\t\tunionPoints = this.unionNoOpt(ptGeom);\n\t\t}\n\t\tvar unionLines = null;\n\t\tif (this.lines.size() > 0) {\n\t\t\tvar lineGeom = this.geomFact.buildGeometry(this.lines);\n\t\t\tunionLines = this.unionNoOpt(lineGeom);\n\t\t}\n\t\tvar unionPolygons = null;\n\t\tif (this.polygons.size() > 0) {\n\t\t\tunionPolygons = CascadedPolygonUnion.union(this.polygons);\n\t\t}\n\t\tvar unionLA = this.unionWithNull(unionLines, unionPolygons);\n\t\tvar union = null;\n\t\tif (unionPoints === null) union = unionLA; else if (unionLA === null) union = unionPoints; else union = PointGeometryUnion.union(unionPoints, unionLA);\n\t\tif (union === null) return this.geomFact.createGeometryCollection();\n\t\treturn union;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn UnaryUnionOp;\n\t}\n});\nUnaryUnionOp.union = function () {\n\tif (arguments.length === 1) {\n\t\tif (hasInterface(arguments[0], Collection)) {\n\t\t\tlet geoms = arguments[0];\n\t\t\tvar op = new UnaryUnionOp(geoms);\n\t\t\treturn op.union();\n\t\t} else if (arguments[0] instanceof Geometry) {\n\t\t\tlet geom = arguments[0];\n\t\t\tvar op = new UnaryUnionOp(geom);\n\t\t\treturn op.union();\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet geoms = arguments[0], geomFact = arguments[1];\n\t\tvar op = new UnaryUnionOp(geoms, geomFact);\n\t\treturn op.union();\n\t}\n};\n","import LineString from '../geom/LineString';\nimport CoordinateList from '../geom/CoordinateList';\nimport Coordinate from '../geom/Coordinate';\nimport GeometryEditor from '../geom/util/GeometryEditor';\nimport LinearRing from '../geom/LinearRing';\nimport extend from '../../../../extend';\nimport inherits from '../../../../inherits';\nexport default function PrecisionReducerCoordinateOperation() {\n\tGeometryEditor.CoordinateOperation.apply(this);\n\tthis.targetPM = null;\n\tthis.removeCollapsed = true;\n\tlet targetPM = arguments[0], removeCollapsed = arguments[1];\n\tthis.targetPM = targetPM;\n\tthis.removeCollapsed = removeCollapsed;\n}\ninherits(PrecisionReducerCoordinateOperation, GeometryEditor.CoordinateOperation);\nextend(PrecisionReducerCoordinateOperation.prototype, {\n\teditCoordinates: function (coordinates, geom) {\n\t\tif (coordinates.length === 0) return null;\n\t\tvar reducedCoords = new Array(coordinates.length).fill(null);\n\t\tfor (var i = 0; i < coordinates.length; i++) {\n\t\t\tvar coord = new Coordinate(coordinates[i]);\n\t\t\tthis.targetPM.makePrecise(coord);\n\t\t\treducedCoords[i] = coord;\n\t\t}\n\t\tvar noRepeatedCoordList = new CoordinateList(reducedCoords, false);\n\t\tvar noRepeatedCoords = noRepeatedCoordList.toCoordinateArray();\n\t\tvar minLength = 0;\n\t\tif (geom instanceof LineString) minLength = 2;\n\t\tif (geom instanceof LinearRing) minLength = 4;\n\t\tvar collapsedCoords = reducedCoords;\n\t\tif (this.removeCollapsed) collapsedCoords = null;\n\t\tif (noRepeatedCoords.length < minLength) {\n\t\t\treturn collapsedCoords;\n\t\t}\n\t\treturn noRepeatedCoords;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn PrecisionReducerCoordinateOperation;\n\t}\n});\n","import hasInterface from '../../../../hasInterface';\nimport GeometryFactory from '../geom/GeometryFactory';\nimport GeometryEditor from '../geom/util/GeometryEditor';\nimport extend from '../../../../extend';\nimport Polygonal from '../geom/Polygonal';\nimport PrecisionReducerCoordinateOperation from './PrecisionReducerCoordinateOperation';\nexport default function GeometryPrecisionReducer() {\n\tthis.targetPM = null;\n\tthis.removeCollapsed = true;\n\tthis.changePrecisionModel = false;\n\tthis.isPointwise = false;\n\tlet pm = arguments[0];\n\tthis.targetPM = pm;\n}\nextend(GeometryPrecisionReducer.prototype, {\n\tfixPolygonalTopology: function (geom) {\n\t\tvar geomToBuffer = geom;\n\t\tif (!this.changePrecisionModel) {\n\t\t\tgeomToBuffer = this.changePM(geom, this.targetPM);\n\t\t}\n\t\tvar bufGeom = geomToBuffer.buffer(0);\n\t\tvar finalGeom = bufGeom;\n\t\tif (!this.changePrecisionModel) {\n\t\t\tfinalGeom = this.changePM(bufGeom, geom.getPrecisionModel());\n\t\t}\n\t\treturn finalGeom;\n\t},\n\treducePointwise: function (geom) {\n\t\tvar geomEdit = null;\n\t\tif (this.changePrecisionModel) {\n\t\t\tvar newFactory = this.createFactory(geom.getFactory(), this.targetPM);\n\t\t\tgeomEdit = new GeometryEditor(newFactory);\n\t\t} else geomEdit = new GeometryEditor();\n\t\tvar finalRemoveCollapsed = this.removeCollapsed;\n\t\tif (geom.getDimension() >= 2) finalRemoveCollapsed = true;\n\t\tvar reduceGeom = geomEdit.edit(geom, new PrecisionReducerCoordinateOperation(this.targetPM, finalRemoveCollapsed));\n\t\treturn reduceGeom;\n\t},\n\tchangePM: function (geom, newPM) {\n\t\tvar geomEditor = this.createEditor(geom.getFactory(), newPM);\n\t\treturn geomEditor.edit(geom, new GeometryEditor.NoOpGeometryOperation());\n\t},\n\tsetRemoveCollapsedComponents: function (removeCollapsed) {\n\t\tthis.removeCollapsed = removeCollapsed;\n\t},\n\tcreateFactory: function (inputFactory, pm) {\n\t\tvar newFactory = new GeometryFactory(pm, inputFactory.getSRID(), inputFactory.getCoordinateSequenceFactory());\n\t\treturn newFactory;\n\t},\n\tsetChangePrecisionModel: function (changePrecisionModel) {\n\t\tthis.changePrecisionModel = changePrecisionModel;\n\t},\n\treduce: function (geom) {\n\t\tvar reducePW = this.reducePointwise(geom);\n\t\tif (this.isPointwise) return reducePW;\n\t\tif (!hasInterface(reducePW, Polygonal)) return reducePW;\n\t\tif (reducePW.isValid()) return reducePW;\n\t\treturn this.fixPolygonalTopology(reducePW);\n\t},\n\tsetPointwise: function (isPointwise) {\n\t\tthis.isPointwise = isPointwise;\n\t},\n\tcreateEditor: function (geomFactory, newPM) {\n\t\tif (geomFactory.getPrecisionModel() === newPM) return new GeometryEditor();\n\t\tvar newFactory = this.createFactory(geomFactory, newPM);\n\t\tvar geomEdit = new GeometryEditor(newFactory);\n\t\treturn geomEdit;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn GeometryPrecisionReducer;\n\t}\n});\nGeometryPrecisionReducer.reduce = function (g, precModel) {\n\tvar reducer = new GeometryPrecisionReducer(precModel);\n\treturn reducer.reduce(g);\n};\nGeometryPrecisionReducer.reducePointwise = function (g, precModel) {\n\tvar reducer = new GeometryPrecisionReducer(precModel);\n\treducer.setPointwise(true);\n\treturn reducer.reduce(g);\n};\n","import CoordinateList from '../geom/CoordinateList';\nimport Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport LineSegment from '../geom/LineSegment';\nexport default function DouglasPeuckerLineSimplifier() {\n\tthis.pts = null;\n\tthis.usePt = null;\n\tthis.distanceTolerance = null;\n\tthis.seg = new LineSegment();\n\tlet pts = arguments[0];\n\tthis.pts = pts;\n}\nextend(DouglasPeuckerLineSimplifier.prototype, {\n\tsimplifySection: function (i, j) {\n\t\tif (i + 1 === j) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.seg.p0 = this.pts[i];\n\t\tthis.seg.p1 = this.pts[j];\n\t\tvar maxDistance = -1.0;\n\t\tvar maxIndex = i;\n\t\tfor (var k = i + 1; k < j; k++) {\n\t\t\tvar distance = this.seg.distance(this.pts[k]);\n\t\t\tif (distance > maxDistance) {\n\t\t\t\tmaxDistance = distance;\n\t\t\t\tmaxIndex = k;\n\t\t\t}\n\t\t}\n\t\tif (maxDistance <= this.distanceTolerance) {\n\t\t\tfor (var k = i + 1; k < j; k++) {\n\t\t\t\tthis.usePt[k] = false;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.simplifySection(i, maxIndex);\n\t\t\tthis.simplifySection(maxIndex, j);\n\t\t}\n\t},\n\tsetDistanceTolerance: function (distanceTolerance) {\n\t\tthis.distanceTolerance = distanceTolerance;\n\t},\n\tsimplify: function () {\n\t\tthis.usePt = new Array(this.pts.length).fill(null);\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tthis.usePt[i] = true;\n\t\t}\n\t\tthis.simplifySection(0, this.pts.length - 1);\n\t\tvar coordList = new CoordinateList();\n\t\tfor (var i = 0; i < this.pts.length; i++) {\n\t\t\tif (this.usePt[i]) coordList.add(new Coordinate(this.pts[i]));\n\t\t}\n\t\treturn coordList.toCoordinateArray();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DouglasPeuckerLineSimplifier;\n\t}\n});\nDouglasPeuckerLineSimplifier.simplify = function (pts, distanceTolerance) {\n\tvar simp = new DouglasPeuckerLineSimplifier(pts);\n\tsimp.setDistanceTolerance(distanceTolerance);\n\treturn simp.simplify();\n};\n","import DouglasPeuckerLineSimplifier from './DouglasPeuckerLineSimplifier';\nimport GeometryTransformer from '../geom/util/GeometryTransformer';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport Polygon from '../geom/Polygon';\nimport LinearRing from '../geom/LinearRing';\nimport extend from '../../../../extend';\nimport MultiPolygon from '../geom/MultiPolygon';\nimport inherits from '../../../../inherits';\nexport default function DouglasPeuckerSimplifier() {\n\tthis.inputGeom = null;\n\tthis.distanceTolerance = null;\n\tthis.isEnsureValidTopology = true;\n\tlet inputGeom = arguments[0];\n\tthis.inputGeom = inputGeom;\n}\nextend(DouglasPeuckerSimplifier.prototype, {\n\tsetEnsureValid: function (isEnsureValidTopology) {\n\t\tthis.isEnsureValidTopology = isEnsureValidTopology;\n\t},\n\tgetResultGeometry: function () {\n\t\tif (this.inputGeom.isEmpty()) return this.inputGeom.copy();\n\t\treturn new DPTransformer(this.isEnsureValidTopology, this.distanceTolerance).transform(this.inputGeom);\n\t},\n\tsetDistanceTolerance: function (distanceTolerance) {\n\t\tif (distanceTolerance < 0.0) throw new IllegalArgumentException(\"Tolerance must be non-negative\");\n\t\tthis.distanceTolerance = distanceTolerance;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DouglasPeuckerSimplifier;\n\t}\n});\nDouglasPeuckerSimplifier.simplify = function (geom, distanceTolerance) {\n\tvar tss = new DouglasPeuckerSimplifier(geom);\n\ttss.setDistanceTolerance(distanceTolerance);\n\treturn tss.getResultGeometry();\n};\nfunction DPTransformer() {\n\tGeometryTransformer.apply(this);\n\tthis.isEnsureValidTopology = true;\n\tthis.distanceTolerance = null;\n\tlet isEnsureValidTopology = arguments[0], distanceTolerance = arguments[1];\n\tthis.isEnsureValidTopology = isEnsureValidTopology;\n\tthis.distanceTolerance = distanceTolerance;\n}\ninherits(DPTransformer, GeometryTransformer);\nextend(DPTransformer.prototype, {\n\ttransformPolygon: function (geom, parent) {\n\t\tif (geom.isEmpty()) return null;\n\t\tvar rawGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);\n\t\tif (parent instanceof MultiPolygon) {\n\t\t\treturn rawGeom;\n\t\t}\n\t\treturn this.createValidArea(rawGeom);\n\t},\n\tcreateValidArea: function (rawAreaGeom) {\n\t\tif (this.isEnsureValidTopology) return rawAreaGeom.buffer(0.0);\n\t\treturn rawAreaGeom;\n\t},\n\ttransformCoordinates: function (coords, parent) {\n\t\tvar inputPts = coords.toCoordinateArray();\n\t\tvar newPts = null;\n\t\tif (inputPts.length === 0) {\n\t\t\tnewPts = new Array(0).fill(null);\n\t\t} else {\n\t\t\tnewPts = DouglasPeuckerLineSimplifier.simplify(inputPts, this.distanceTolerance);\n\t\t}\n\t\treturn this.factory.getCoordinateSequenceFactory().create(newPts);\n\t},\n\ttransformMultiPolygon: function (geom, parent) {\n\t\tvar rawGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);\n\t\treturn this.createValidArea(rawGeom);\n\t},\n\ttransformLinearRing: function (geom, parent) {\n\t\tvar removeDegenerateRings = parent instanceof Polygon;\n\t\tvar simpResult = GeometryTransformer.prototype.transformLinearRing.call(this, geom, parent);\n\t\tif (removeDegenerateRings && !(simpResult instanceof LinearRing)) return null;\n\t\t;\n\t\treturn simpResult;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DPTransformer;\n\t}\n});\nDouglasPeuckerSimplifier.DPTransformer = DPTransformer;\n","import extend from '../../../../extend';\nimport LineSegment from '../geom/LineSegment';\nimport inherits from '../../../../inherits';\nexport default function TaggedLineSegment() {\n\tthis.parent = null;\n\tthis.index = null;\n\tif (arguments.length === 2) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tTaggedLineSegment.call(this, p0, p1, null, -1);\n\t} else if (arguments.length === 4) {\n\t\tlet p0 = arguments[0], p1 = arguments[1], parent = arguments[2], index = arguments[3];\n\t\tLineSegment.call(this, p0, p1);\n\t\tthis.parent = parent;\n\t\tthis.index = index;\n\t}\n}\ninherits(TaggedLineSegment, LineSegment);\nextend(TaggedLineSegment.prototype, {\n\tgetIndex: function () {\n\t\treturn this.index;\n\t},\n\tgetParent: function () {\n\t\treturn this.parent;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TaggedLineSegment;\n\t}\n});\n","import extend from '../../../../extend';\nimport TaggedLineSegment from './TaggedLineSegment';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function TaggedLineString() {\n\tthis.parentLine = null;\n\tthis.segs = null;\n\tthis.resultSegs = new ArrayList();\n\tthis.minimumSize = null;\n\tif (arguments.length === 1) {\n\t\tlet parentLine = arguments[0];\n\t\tTaggedLineString.call(this, parentLine, 2);\n\t} else if (arguments.length === 2) {\n\t\tlet parentLine = arguments[0], minimumSize = arguments[1];\n\t\tthis.parentLine = parentLine;\n\t\tthis.minimumSize = minimumSize;\n\t\tthis.init();\n\t}\n}\nextend(TaggedLineString.prototype, {\n\taddToResult: function (seg) {\n\t\tthis.resultSegs.add(seg);\n\t},\n\tasLineString: function () {\n\t\treturn this.parentLine.getFactory().createLineString(TaggedLineString.extractCoordinates(this.resultSegs));\n\t},\n\tgetResultSize: function () {\n\t\tvar resultSegsSize = this.resultSegs.size();\n\t\treturn resultSegsSize === 0 ? 0 : resultSegsSize + 1;\n\t},\n\tgetParent: function () {\n\t\treturn this.parentLine;\n\t},\n\tgetSegment: function (i) {\n\t\treturn this.segs[i];\n\t},\n\tgetParentCoordinates: function () {\n\t\treturn this.parentLine.getCoordinates();\n\t},\n\tgetMinimumSize: function () {\n\t\treturn this.minimumSize;\n\t},\n\tasLinearRing: function () {\n\t\treturn this.parentLine.getFactory().createLinearRing(TaggedLineString.extractCoordinates(this.resultSegs));\n\t},\n\tgetSegments: function () {\n\t\treturn this.segs;\n\t},\n\tinit: function () {\n\t\tvar pts = this.parentLine.getCoordinates();\n\t\tthis.segs = new Array(pts.length - 1).fill(null);\n\t\tfor (var i = 0; i < pts.length - 1; i++) {\n\t\t\tvar seg = new TaggedLineSegment(pts[i], pts[i + 1], this.parentLine, i);\n\t\t\tthis.segs[i] = seg;\n\t\t}\n\t},\n\tgetResultCoordinates: function () {\n\t\treturn TaggedLineString.extractCoordinates(this.resultSegs);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TaggedLineString;\n\t}\n});\nTaggedLineString.extractCoordinates = function (segs) {\n\tvar pts = new Array(segs.size() + 1).fill(null);\n\tvar seg = null;\n\tfor (var i = 0; i < segs.size(); i++) {\n\t\tseg = segs.get(i);\n\t\tpts[i] = seg.p0;\n\t}\n\tpts[pts.length - 1] = seg.p1;\n\treturn pts;\n};\n","import Quadtree from '../index/quadtree/Quadtree';\nimport ItemVisitor from '../index/ItemVisitor';\nimport extend from '../../../../extend';\nimport LineSegment from '../geom/LineSegment';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Envelope from '../geom/Envelope';\nimport TaggedLineString from './TaggedLineString';\nexport default function LineSegmentIndex() {\n\tthis.index = new Quadtree();\n}\nextend(LineSegmentIndex.prototype, {\n\tremove: function (seg) {\n\t\tthis.index.remove(new Envelope(seg.p0, seg.p1), seg);\n\t},\n\tadd: function () {\n\t\tif (arguments[0] instanceof TaggedLineString) {\n\t\t\tlet line = arguments[0];\n\t\t\tvar segs = line.getSegments();\n\t\t\tfor (var i = 0; i < segs.length; i++) {\n\t\t\t\tvar seg = segs[i];\n\t\t\t\tthis.add(seg);\n\t\t\t}\n\t\t} else if (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tthis.index.insert(new Envelope(seg.p0, seg.p1), seg);\n\t\t}\n\t},\n\tquery: function (querySeg) {\n\t\tvar env = new Envelope(querySeg.p0, querySeg.p1);\n\t\tvar visitor = new LineSegmentVisitor(querySeg);\n\t\tthis.index.query(env, visitor);\n\t\tvar itemsFound = visitor.getItems();\n\t\treturn itemsFound;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineSegmentIndex;\n\t}\n});\nfunction LineSegmentVisitor() {\n\tthis.querySeg = null;\n\tthis.items = new ArrayList();\n\tlet querySeg = arguments[0];\n\tthis.querySeg = querySeg;\n}\nextend(LineSegmentVisitor.prototype, {\n\tvisitItem: function (item) {\n\t\tvar seg = item;\n\t\tif (Envelope.intersects(seg.p0, seg.p1, this.querySeg.p0, this.querySeg.p1)) this.items.add(item);\n\t},\n\tgetItems: function () {\n\t\treturn this.items;\n\t},\n\tinterfaces_: function () {\n\t\treturn [ItemVisitor];\n\t},\n\tgetClass: function () {\n\t\treturn LineSegmentVisitor;\n\t}\n});\n","import extend from '../../../../extend';\nimport LineSegment from '../geom/LineSegment';\nimport LineSegmentIndex from './LineSegmentIndex';\nimport RobustLineIntersector from '../algorithm/RobustLineIntersector';\nexport default function TaggedLineStringSimplifier() {\n\tthis.li = new RobustLineIntersector();\n\tthis.inputIndex = new LineSegmentIndex();\n\tthis.outputIndex = new LineSegmentIndex();\n\tthis.line = null;\n\tthis.linePts = null;\n\tthis.distanceTolerance = 0.0;\n\tlet inputIndex = arguments[0], outputIndex = arguments[1];\n\tthis.inputIndex = inputIndex;\n\tthis.outputIndex = outputIndex;\n}\nextend(TaggedLineStringSimplifier.prototype, {\n\tflatten: function (start, end) {\n\t\tvar p0 = this.linePts[start];\n\t\tvar p1 = this.linePts[end];\n\t\tvar newSeg = new LineSegment(p0, p1);\n\t\tthis.remove(this.line, start, end);\n\t\tthis.outputIndex.add(newSeg);\n\t\treturn newSeg;\n\t},\n\thasBadIntersection: function (parentLine, sectionIndex, candidateSeg) {\n\t\tif (this.hasBadOutputIntersection(candidateSeg)) return true;\n\t\tif (this.hasBadInputIntersection(parentLine, sectionIndex, candidateSeg)) return true;\n\t\treturn false;\n\t},\n\tsetDistanceTolerance: function (distanceTolerance) {\n\t\tthis.distanceTolerance = distanceTolerance;\n\t},\n\tsimplifySection: function (i, j, depth) {\n\t\tdepth += 1;\n\t\tvar sectionIndex = new Array(2).fill(null);\n\t\tif (i + 1 === j) {\n\t\t\tvar newSeg = this.line.getSegment(i);\n\t\t\tthis.line.addToResult(newSeg);\n\t\t\treturn null;\n\t\t}\n\t\tvar isValidToSimplify = true;\n\t\tif (this.line.getResultSize() < this.line.getMinimumSize()) {\n\t\t\tvar worstCaseSize = depth + 1;\n\t\t\tif (worstCaseSize < this.line.getMinimumSize()) isValidToSimplify = false;\n\t\t}\n\t\tvar distance = new Array(1).fill(null);\n\t\tvar furthestPtIndex = this.findFurthestPoint(this.linePts, i, j, distance);\n\t\tif (distance[0] > this.distanceTolerance) isValidToSimplify = false;\n\t\tvar candidateSeg = new LineSegment();\n\t\tcandidateSeg.p0 = this.linePts[i];\n\t\tcandidateSeg.p1 = this.linePts[j];\n\t\tsectionIndex[0] = i;\n\t\tsectionIndex[1] = j;\n\t\tif (this.hasBadIntersection(this.line, sectionIndex, candidateSeg)) isValidToSimplify = false;\n\t\tif (isValidToSimplify) {\n\t\t\tvar newSeg = this.flatten(i, j);\n\t\t\tthis.line.addToResult(newSeg);\n\t\t\treturn null;\n\t\t}\n\t\tthis.simplifySection(i, furthestPtIndex, depth);\n\t\tthis.simplifySection(furthestPtIndex, j, depth);\n\t},\n\thasBadOutputIntersection: function (candidateSeg) {\n\t\tvar querySegs = this.outputIndex.query(candidateSeg);\n\t\tfor (var i = querySegs.iterator(); i.hasNext(); ) {\n\t\t\tvar querySeg = i.next();\n\t\t\tif (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tfindFurthestPoint: function (pts, i, j, maxDistance) {\n\t\tvar seg = new LineSegment();\n\t\tseg.p0 = pts[i];\n\t\tseg.p1 = pts[j];\n\t\tvar maxDist = -1.0;\n\t\tvar maxIndex = i;\n\t\tfor (var k = i + 1; k < j; k++) {\n\t\t\tvar midPt = pts[k];\n\t\t\tvar distance = seg.distance(midPt);\n\t\t\tif (distance > maxDist) {\n\t\t\t\tmaxDist = distance;\n\t\t\t\tmaxIndex = k;\n\t\t\t}\n\t\t}\n\t\tmaxDistance[0] = maxDist;\n\t\treturn maxIndex;\n\t},\n\tsimplify: function (line) {\n\t\tthis.line = line;\n\t\tthis.linePts = line.getParentCoordinates();\n\t\tthis.simplifySection(0, this.linePts.length - 1, 0);\n\t},\n\tremove: function (line, start, end) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar seg = line.getSegment(i);\n\t\t\tthis.inputIndex.remove(seg);\n\t\t}\n\t},\n\thasInteriorIntersection: function (seg0, seg1) {\n\t\tthis.li.computeIntersection(seg0.p0, seg0.p1, seg1.p0, seg1.p1);\n\t\treturn this.li.isInteriorIntersection();\n\t},\n\thasBadInputIntersection: function (parentLine, sectionIndex, candidateSeg) {\n\t\tvar querySegs = this.inputIndex.query(candidateSeg);\n\t\tfor (var i = querySegs.iterator(); i.hasNext(); ) {\n\t\t\tvar querySeg = i.next();\n\t\t\tif (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n\t\t\t\tif (TaggedLineStringSimplifier.isInLineSection(parentLine, sectionIndex, querySeg)) continue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TaggedLineStringSimplifier;\n\t}\n});\nTaggedLineStringSimplifier.isInLineSection = function (line, sectionIndex, seg) {\n\tif (seg.getParent() !== line.getParent()) return false;\n\tvar segIndex = seg.getIndex();\n\tif (segIndex >= sectionIndex[0] && segIndex < sectionIndex[1]) return true;\n\treturn false;\n};\n","import extend from '../../../../extend';\nimport TaggedLineStringSimplifier from './TaggedLineStringSimplifier';\nimport LineSegmentIndex from './LineSegmentIndex';\nexport default function TaggedLinesSimplifier() {\n\tthis.inputIndex = new LineSegmentIndex();\n\tthis.outputIndex = new LineSegmentIndex();\n\tthis.distanceTolerance = 0.0;\n}\nextend(TaggedLinesSimplifier.prototype, {\n\tsetDistanceTolerance: function (distanceTolerance) {\n\t\tthis.distanceTolerance = distanceTolerance;\n\t},\n\tsimplify: function (taggedLines) {\n\t\tfor (var i = taggedLines.iterator(); i.hasNext(); ) {\n\t\t\tthis.inputIndex.add(i.next());\n\t\t}\n\t\tfor (var i = taggedLines.iterator(); i.hasNext(); ) {\n\t\t\tvar tlss = new TaggedLineStringSimplifier(this.inputIndex, this.outputIndex);\n\t\t\ttlss.setDistanceTolerance(this.distanceTolerance);\n\t\t\ttlss.simplify(i.next());\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TaggedLinesSimplifier;\n\t}\n});\n","import LineString from '../geom/LineString';\nimport HashMap from '../../../../java/util/HashMap';\nimport GeometryTransformer from '../geom/util/GeometryTransformer';\nimport TaggedLinesSimplifier from './TaggedLinesSimplifier';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport GeometryComponentFilter from '../geom/GeometryComponentFilter';\nimport inherits from '../../../../inherits';\nimport TaggedLineString from './TaggedLineString';\nexport default function TopologyPreservingSimplifier() {\n\tthis.inputGeom = null;\n\tthis.lineSimplifier = new TaggedLinesSimplifier();\n\tthis.linestringMap = null;\n\tlet inputGeom = arguments[0];\n\tthis.inputGeom = inputGeom;\n}\nextend(TopologyPreservingSimplifier.prototype, {\n\tgetResultGeometry: function () {\n\t\tif (this.inputGeom.isEmpty()) return this.inputGeom.copy();\n\t\tthis.linestringMap = new HashMap();\n\t\tthis.inputGeom.apply(new LineStringMapBuilderFilter(this));\n\t\tthis.lineSimplifier.simplify(this.linestringMap.values());\n\t\tvar result = new LineStringTransformer(this.linestringMap).transform(this.inputGeom);\n\t\treturn result;\n\t},\n\tsetDistanceTolerance: function (distanceTolerance) {\n\t\tif (distanceTolerance < 0.0) throw new IllegalArgumentException(\"Tolerance must be non-negative\");\n\t\tthis.lineSimplifier.setDistanceTolerance(distanceTolerance);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TopologyPreservingSimplifier;\n\t}\n});\nTopologyPreservingSimplifier.simplify = function (geom, distanceTolerance) {\n\tvar tss = new TopologyPreservingSimplifier(geom);\n\ttss.setDistanceTolerance(distanceTolerance);\n\treturn tss.getResultGeometry();\n};\nfunction LineStringTransformer() {\n\tGeometryTransformer.apply(this);\n\tthis.linestringMap = null;\n\tlet linestringMap = arguments[0];\n\tthis.linestringMap = linestringMap;\n}\ninherits(LineStringTransformer, GeometryTransformer);\nextend(LineStringTransformer.prototype, {\n\ttransformCoordinates: function (coords, parent) {\n\t\tif (coords.size() === 0) return null;\n\t\tif (parent instanceof LineString) {\n\t\t\tvar taggedLine = this.linestringMap.get(parent);\n\t\t\treturn this.createCoordinateSequence(taggedLine.getResultCoordinates());\n\t\t}\n\t\treturn GeometryTransformer.prototype.transformCoordinates.call(this, coords, parent);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LineStringTransformer;\n\t}\n});\nfunction LineStringMapBuilderFilter() {\n\tthis.tps = null;\n\tlet tps = arguments[0];\n\tthis.tps = tps;\n}\nextend(LineStringMapBuilderFilter.prototype, {\n\tfilter: function (geom) {\n\t\tif (geom instanceof LineString) {\n\t\t\tvar line = geom;\n\t\t\tif (line.isEmpty()) return null;\n\t\t\tvar minSize = line.isClosed() ? 4 : 2;\n\t\t\tvar taggedLine = new TaggedLineString(line, minSize);\n\t\t\tthis.tps.linestringMap.put(line, taggedLine);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [GeometryComponentFilter];\n\t},\n\tgetClass: function () {\n\t\treturn LineStringMapBuilderFilter;\n\t}\n});\nTopologyPreservingSimplifier.LineStringTransformer = LineStringTransformer;\nTopologyPreservingSimplifier.LineStringMapBuilderFilter = LineStringMapBuilderFilter;\n","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nexport default function SplitSegment() {\n\tthis.seg = null;\n\tthis.segLen = null;\n\tthis.splitPt = null;\n\tthis.minimumLen = 0.0;\n\tlet seg = arguments[0];\n\tthis.seg = seg;\n\tthis.segLen = seg.getLength();\n}\nextend(SplitSegment.prototype, {\n\tsplitAt: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet pt = arguments[0];\n\t\t\tvar minFrac = this.minimumLen / this.segLen;\n\t\t\tif (pt.distance(this.seg.p0) < this.minimumLen) {\n\t\t\t\tthis.splitPt = this.seg.pointAlong(minFrac);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (pt.distance(this.seg.p1) < this.minimumLen) {\n\t\t\t\tthis.splitPt = SplitSegment.pointAlongReverse(this.seg, minFrac);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis.splitPt = pt;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet length = arguments[0], endPt = arguments[1];\n\t\t\tvar actualLen = this.getConstrainedLength(length);\n\t\t\tvar frac = actualLen / this.segLen;\n\t\t\tif (endPt.equals2D(this.seg.p0)) this.splitPt = this.seg.pointAlong(frac); else this.splitPt = SplitSegment.pointAlongReverse(this.seg, frac);\n\t\t}\n\t},\n\tsetMinimumLength: function (minLen) {\n\t\tthis.minimumLen = minLen;\n\t},\n\tgetConstrainedLength: function (len) {\n\t\tif (len < this.minimumLen) return this.minimumLen;\n\t\treturn len;\n\t},\n\tgetSplitPoint: function () {\n\t\treturn this.splitPt;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn SplitSegment;\n\t}\n});\nSplitSegment.pointAlongReverse = function (seg, segmentLengthFraction) {\n\tvar coord = new Coordinate();\n\tcoord.x = seg.p1.x - segmentLengthFraction * (seg.p1.x - seg.p0.x);\n\tcoord.y = seg.p1.y - segmentLengthFraction * (seg.p1.y - seg.p0.y);\n\treturn coord;\n};\n","import extend from '../../../../extend';\nexport default function ConstraintSplitPointFinder() {}\nextend(ConstraintSplitPointFinder.prototype, {\n\tfindSplitPoint: function (seg, encroachPt) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ConstraintSplitPointFinder;\n\t}\n});\n","import extend from '../../../../extend';\nimport SplitSegment from './SplitSegment';\nimport ConstraintSplitPointFinder from './ConstraintSplitPointFinder';\nexport default function NonEncroachingSplitPointFinder() {}\nextend(NonEncroachingSplitPointFinder.prototype, {\n\tfindSplitPoint: function (seg, encroachPt) {\n\t\tvar lineSeg = seg.getLineSegment();\n\t\tvar segLen = lineSeg.getLength();\n\t\tvar midPtLen = segLen / 2;\n\t\tvar splitSeg = new SplitSegment(lineSeg);\n\t\tvar projPt = NonEncroachingSplitPointFinder.projectedSplitPoint(seg, encroachPt);\n\t\tvar nonEncroachDiam = projPt.distance(encroachPt) * 2 * 0.8;\n\t\tvar maxSplitLen = nonEncroachDiam;\n\t\tif (maxSplitLen > midPtLen) {\n\t\t\tmaxSplitLen = midPtLen;\n\t\t}\n\t\tsplitSeg.setMinimumLength(maxSplitLen);\n\t\tsplitSeg.splitAt(projPt);\n\t\treturn splitSeg.getSplitPoint();\n\t},\n\tinterfaces_: function () {\n\t\treturn [ConstraintSplitPointFinder];\n\t},\n\tgetClass: function () {\n\t\treturn NonEncroachingSplitPointFinder;\n\t}\n});\nNonEncroachingSplitPointFinder.projectedSplitPoint = function (seg, encroachPt) {\n\tvar lineSeg = seg.getLineSegment();\n\tvar projPt = lineSeg.project(encroachPt);\n\treturn projPt;\n};\n","import WKTWriter from '../../io/WKTWriter';\nimport CoordinateArraySequence from '../../geom/impl/CoordinateArraySequence';\nimport extend from '../../../../../extend';\nimport DD from '../../math/DD';\nimport System from '../../../../../java/lang/System';\nimport Triangle from '../../geom/Triangle';\nexport default function TrianglePredicate() {}\nextend(TrianglePredicate.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TrianglePredicate;\n\t}\n});\nTrianglePredicate.triArea = function (a, b, c) {\n\treturn (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n};\nTrianglePredicate.isInCircleDDNormalized = function (a, b, c, p) {\n\tvar adx = DD.valueOf(a.x).selfSubtract(p.x);\n\tvar ady = DD.valueOf(a.y).selfSubtract(p.y);\n\tvar bdx = DD.valueOf(b.x).selfSubtract(p.x);\n\tvar bdy = DD.valueOf(b.y).selfSubtract(p.y);\n\tvar cdx = DD.valueOf(c.x).selfSubtract(p.x);\n\tvar cdy = DD.valueOf(c.y).selfSubtract(p.y);\n\tvar abdet = adx.multiply(bdy).selfSubtract(bdx.multiply(ady));\n\tvar bcdet = bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));\n\tvar cadet = cdx.multiply(ady).selfSubtract(adx.multiply(cdy));\n\tvar alift = adx.multiply(adx).selfAdd(ady.multiply(ady));\n\tvar blift = bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));\n\tvar clift = cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));\n\tvar sum = alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(clift.selfMultiply(abdet));\n\tvar isInCircle = sum.doubleValue() > 0;\n\treturn isInCircle;\n};\nTrianglePredicate.checkRobustInCircle = function (a, b, c, p) {\n\tvar nonRobustInCircle = TrianglePredicate.isInCircleNonRobust(a, b, c, p);\n\tvar isInCircleDD = TrianglePredicate.isInCircleDDSlow(a, b, c, p);\n\tvar isInCircleCC = TrianglePredicate.isInCircleCC(a, b, c, p);\n\tvar circumCentre = Triangle.circumcentre(a, b, c);\n\tSystem.out.println(\"p radius diff a = \" + Math.abs(p.distance(circumCentre) - a.distance(circumCentre)) / a.distance(circumCentre));\n\tif (nonRobustInCircle !== isInCircleDD || nonRobustInCircle !== isInCircleCC) {\n\t\tSystem.out.println(\"inCircle robustness failure (double result = \" + nonRobustInCircle + \", DD result = \" + isInCircleDD + \", CC result = \" + isInCircleCC + \")\");\n\t\tSystem.out.println(WKTWriter.toLineString(new CoordinateArraySequence([a, b, c, p])));\n\t\tSystem.out.println(\"Circumcentre = \" + WKTWriter.toPoint(circumCentre) + \" radius = \" + a.distance(circumCentre));\n\t\tSystem.out.println(\"p radius diff a = \" + Math.abs(p.distance(circumCentre) / a.distance(circumCentre) - 1));\n\t\tSystem.out.println(\"p radius diff b = \" + Math.abs(p.distance(circumCentre) / b.distance(circumCentre) - 1));\n\t\tSystem.out.println(\"p radius diff c = \" + Math.abs(p.distance(circumCentre) / c.distance(circumCentre) - 1));\n\t\tSystem.out.println();\n\t}\n};\nTrianglePredicate.isInCircleDDFast = function (a, b, c, p) {\n\tvar aTerm = DD.sqr(a.x).selfAdd(DD.sqr(a.y)).selfMultiply(TrianglePredicate.triAreaDDFast(b, c, p));\n\tvar bTerm = DD.sqr(b.x).selfAdd(DD.sqr(b.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, c, p));\n\tvar cTerm = DD.sqr(c.x).selfAdd(DD.sqr(c.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, p));\n\tvar pTerm = DD.sqr(p.x).selfAdd(DD.sqr(p.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, c));\n\tvar sum = aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);\n\tvar isInCircle = sum.doubleValue() > 0;\n\treturn isInCircle;\n};\nTrianglePredicate.isInCircleCC = function (a, b, c, p) {\n\tvar cc = Triangle.circumcentre(a, b, c);\n\tvar ccRadius = a.distance(cc);\n\tvar pRadiusDiff = p.distance(cc) - ccRadius;\n\treturn pRadiusDiff <= 0;\n};\nTrianglePredicate.isInCircleNormalized = function (a, b, c, p) {\n\tvar adx = a.x - p.x;\n\tvar ady = a.y - p.y;\n\tvar bdx = b.x - p.x;\n\tvar bdy = b.y - p.y;\n\tvar cdx = c.x - p.x;\n\tvar cdy = c.y - p.y;\n\tvar abdet = adx * bdy - bdx * ady;\n\tvar bcdet = bdx * cdy - cdx * bdy;\n\tvar cadet = cdx * ady - adx * cdy;\n\tvar alift = adx * adx + ady * ady;\n\tvar blift = bdx * bdx + bdy * bdy;\n\tvar clift = cdx * cdx + cdy * cdy;\n\tvar disc = alift * bcdet + blift * cadet + clift * abdet;\n\treturn disc > 0;\n};\nTrianglePredicate.isInCircleDDSlow = function (a, b, c, p) {\n\tvar px = DD.valueOf(p.x);\n\tvar py = DD.valueOf(p.y);\n\tvar ax = DD.valueOf(a.x);\n\tvar ay = DD.valueOf(a.y);\n\tvar bx = DD.valueOf(b.x);\n\tvar by = DD.valueOf(b.y);\n\tvar cx = DD.valueOf(c.x);\n\tvar cy = DD.valueOf(c.y);\n\tvar aTerm = ax.multiply(ax).add(ay.multiply(ay)).multiply(TrianglePredicate.triAreaDDSlow(bx, by, cx, cy, px, py));\n\tvar bTerm = bx.multiply(bx).add(by.multiply(by)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, cx, cy, px, py));\n\tvar cTerm = cx.multiply(cx).add(cy.multiply(cy)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, px, py));\n\tvar pTerm = px.multiply(px).add(py.multiply(py)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, cx, cy));\n\tvar sum = aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);\n\tvar isInCircle = sum.doubleValue() > 0;\n\treturn isInCircle;\n};\nTrianglePredicate.isInCircleNonRobust = function (a, b, c, p) {\n\tvar isInCircle = (a.x * a.x + a.y * a.y) * TrianglePredicate.triArea(b, c, p) - (b.x * b.x + b.y * b.y) * TrianglePredicate.triArea(a, c, p) + (c.x * c.x + c.y * c.y) * TrianglePredicate.triArea(a, b, p) - (p.x * p.x + p.y * p.y) * TrianglePredicate.triArea(a, b, c) > 0;\n\treturn isInCircle;\n};\nTrianglePredicate.isInCircleRobust = function (a, b, c, p) {\n\treturn TrianglePredicate.isInCircleNormalized(a, b, c, p);\n};\nTrianglePredicate.triAreaDDSlow = function (ax, ay, bx, by, cx, cy) {\n\treturn bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay).multiply(cx.subtract(ax)));\n};\nTrianglePredicate.triAreaDDFast = function (a, b, c) {\n\tvar t1 = DD.valueOf(b.x).selfSubtract(a.x).selfMultiply(DD.valueOf(c.y).selfSubtract(a.y));\n\tvar t2 = DD.valueOf(b.y).selfSubtract(a.y).selfMultiply(DD.valueOf(c.x).selfSubtract(a.x));\n\treturn t1.selfSubtract(t2);\n};\n","import NotRepresentableException from '../../algorithm/NotRepresentableException';\nimport Coordinate from '../../geom/Coordinate';\nimport TrianglePredicate from './TrianglePredicate';\nimport extend from '../../../../../extend';\nimport System from '../../../../../java/lang/System';\nimport HCoordinate from '../../algorithm/HCoordinate';\nexport default function Vertex() {\n\tthis.p = null;\n\tif (arguments.length === 1) {\n\t\tlet _p = arguments[0];\n\t\tthis.p = new Coordinate(_p);\n\t} else if (arguments.length === 2) {\n\t\tlet _x = arguments[0], _y = arguments[1];\n\t\tthis.p = new Coordinate(_x, _y);\n\t} else if (arguments.length === 3) {\n\t\tlet _x = arguments[0], _y = arguments[1], _z = arguments[2];\n\t\tthis.p = new Coordinate(_x, _y, _z);\n\t}\n}\nextend(Vertex.prototype, {\n\tcircleCenter: function (b, c) {\n\t\tvar a = new Vertex(this.getX(), this.getY());\n\t\tvar cab = this.bisector(a, b);\n\t\tvar cbc = this.bisector(b, c);\n\t\tvar hcc = new HCoordinate(cab, cbc);\n\t\tvar cc = null;\n\t\ttry {\n\t\t\tcc = new Vertex(hcc.getX(), hcc.getY());\n\t\t} catch (nre) {\n\t\t\tif (nre instanceof NotRepresentableException) {\n\t\t\t\tSystem.err.println(\"a: \" + a + \"  b: \" + b + \"  c: \" + c);\n\t\t\t\tSystem.err.println(nre);\n\t\t\t} else throw nre;\n\t\t} finally {}\n\t\treturn cc;\n\t},\n\tdot: function (v) {\n\t\treturn this.p.x * v.getX() + this.p.y * v.getY();\n\t},\n\tmagn: function () {\n\t\treturn Math.sqrt(this.p.x * this.p.x + this.p.y * this.p.y);\n\t},\n\tgetZ: function () {\n\t\treturn this.p.z;\n\t},\n\tbisector: function (a, b) {\n\t\tvar dx = b.getX() - a.getX();\n\t\tvar dy = b.getY() - a.getY();\n\t\tvar l1 = new HCoordinate(a.getX() + dx / 2.0, a.getY() + dy / 2.0, 1.0);\n\t\tvar l2 = new HCoordinate(a.getX() - dy + dx / 2.0, a.getY() + dx + dy / 2.0, 1.0);\n\t\treturn new HCoordinate(l1, l2);\n\t},\n\tequals: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet _x = arguments[0];\n\t\t\tif (this.p.x === _x.getX() && this.p.y === _x.getY()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet _x = arguments[0], tolerance = arguments[1];\n\t\t\tif (this.p.distance(_x.getCoordinate()) < tolerance) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.p;\n\t},\n\tisInCircle: function (a, b, c) {\n\t\treturn TrianglePredicate.isInCircleRobust(a.p, b.p, c.p, this.p);\n\t},\n\tinterpolateZValue: function (v0, v1, v2) {\n\t\tvar x0 = v0.getX();\n\t\tvar y0 = v0.getY();\n\t\tvar a = v1.getX() - x0;\n\t\tvar b = v2.getX() - x0;\n\t\tvar c = v1.getY() - y0;\n\t\tvar d = v2.getY() - y0;\n\t\tvar det = a * d - b * c;\n\t\tvar dx = this.getX() - x0;\n\t\tvar dy = this.getY() - y0;\n\t\tvar t = (d * dx - b * dy) / det;\n\t\tvar u = (-c * dx + a * dy) / det;\n\t\tvar z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());\n\t\treturn z;\n\t},\n\tmidPoint: function (a) {\n\t\tvar xm = (this.p.x + a.getX()) / 2.0;\n\t\tvar ym = (this.p.y + a.getY()) / 2.0;\n\t\tvar zm = (this.p.z + a.getZ()) / 2.0;\n\t\treturn new Vertex(xm, ym, zm);\n\t},\n\trightOf: function (e) {\n\t\treturn this.isCCW(e.dest(), e.orig());\n\t},\n\tisCCW: function (b, c) {\n\t\treturn (b.p.x - this.p.x) * (c.p.y - this.p.y) - (b.p.y - this.p.y) * (c.p.x - this.p.x) > 0;\n\t},\n\tgetX: function () {\n\t\treturn this.p.x;\n\t},\n\tcrossProduct: function (v) {\n\t\treturn this.p.x * v.getY() - this.p.y * v.getX();\n\t},\n\tsetZ: function (_z) {\n\t\tthis.p.z = _z;\n\t},\n\ttimes: function (c) {\n\t\treturn new Vertex(c * this.p.x, c * this.p.y);\n\t},\n\tcross: function () {\n\t\treturn new Vertex(this.p.y, -this.p.x);\n\t},\n\tleftOf: function (e) {\n\t\treturn this.isCCW(e.orig(), e.dest());\n\t},\n\ttoString: function () {\n\t\treturn \"POINT (\" + this.p.x + \" \" + this.p.y + \")\";\n\t},\n\tsub: function (v) {\n\t\treturn new Vertex(this.p.x - v.getX(), this.p.y - v.getY());\n\t},\n\tgetY: function () {\n\t\treturn this.p.y;\n\t},\n\tclassify: function (p0, p1) {\n\t\tvar p2 = this;\n\t\tvar a = p1.sub(p0);\n\t\tvar b = p2.sub(p0);\n\t\tvar sa = a.crossProduct(b);\n\t\tif (sa > 0.0) return Vertex.LEFT;\n\t\tif (sa < 0.0) return Vertex.RIGHT;\n\t\tif (a.getX() * b.getX() < 0.0 || a.getY() * b.getY() < 0.0) return Vertex.BEHIND;\n\t\tif (a.magn() < b.magn()) return Vertex.BEYOND;\n\t\tif (p0.equals(p2)) return Vertex.ORIGIN;\n\t\tif (p1.equals(p2)) return Vertex.DESTINATION;\n\t\treturn Vertex.BETWEEN;\n\t},\n\tsum: function (v) {\n\t\treturn new Vertex(this.p.x + v.getX(), this.p.y + v.getY());\n\t},\n\tdistance: function (v1, v2) {\n\t\treturn Math.sqrt(Math.pow(v2.getX() - v1.getX(), 2.0) + Math.pow(v2.getY() - v1.getY(), 2.0));\n\t},\n\tcircumRadiusRatio: function (b, c) {\n\t\tvar x = this.circleCenter(b, c);\n\t\tvar radius = this.distance(x, b);\n\t\tvar edgeLength = this.distance(this, b);\n\t\tvar el = this.distance(b, c);\n\t\tif (el < edgeLength) {\n\t\t\tedgeLength = el;\n\t\t}\n\t\tel = this.distance(c, this);\n\t\tif (el < edgeLength) {\n\t\t\tedgeLength = el;\n\t\t}\n\t\treturn radius / edgeLength;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Vertex;\n\t}\n});\nVertex.interpolateZ = function () {\n\tif (arguments.length === 3) {\n\t\tlet p = arguments[0], p0 = arguments[1], p1 = arguments[2];\n\t\tvar segLen = p0.distance(p1);\n\t\tvar ptLen = p.distance(p0);\n\t\tvar dz = p1.z - p0.z;\n\t\tvar pz = p0.z + dz * (ptLen / segLen);\n\t\treturn pz;\n\t} else if (arguments.length === 4) {\n\t\tlet p = arguments[0], v0 = arguments[1], v1 = arguments[2], v2 = arguments[3];\n\t\tvar x0 = v0.x;\n\t\tvar y0 = v0.y;\n\t\tvar a = v1.x - x0;\n\t\tvar b = v2.x - x0;\n\t\tvar c = v1.y - y0;\n\t\tvar d = v2.y - y0;\n\t\tvar det = a * d - b * c;\n\t\tvar dx = p.x - x0;\n\t\tvar dy = p.y - y0;\n\t\tvar t = (d * dx - b * dy) / det;\n\t\tvar u = (-c * dx + a * dy) / det;\n\t\tvar z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n\t\treturn z;\n\t}\n};\nVertex.LEFT = 0;\nVertex.RIGHT = 1;\nVertex.BEYOND = 2;\nVertex.BEHIND = 3;\nVertex.BETWEEN = 4;\nVertex.ORIGIN = 5;\nVertex.DESTINATION = 6;\n","import extend from '../../../../extend';\nimport Vertex from './quadedge/Vertex';\nimport inherits from '../../../../inherits';\nexport default function ConstraintVertex() {\n\tthis._isOnConstraint = null;\n\tthis.constraint = null;\n\tlet p = arguments[0];\n\tVertex.call(this, p);\n}\ninherits(ConstraintVertex, Vertex);\nextend(ConstraintVertex.prototype, {\n\tgetConstraint: function () {\n\t\treturn this.constraint;\n\t},\n\tsetOnConstraint: function (isOnConstraint) {\n\t\tthis._isOnConstraint = isOnConstraint;\n\t},\n\tmerge: function (other) {\n\t\tif (other._isOnConstraint) {\n\t\t\tthis._isOnConstraint = true;\n\t\t\tthis.constraint = other.constraint;\n\t\t}\n\t},\n\tisOnConstraint: function () {\n\t\treturn this._isOnConstraint;\n\t},\n\tsetConstraint: function (constraint) {\n\t\tthis._isOnConstraint = true;\n\t\tthis.constraint = constraint;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ConstraintVertex;\n\t}\n});\n","import WKTWriter from '../../io/WKTWriter';\nimport extend from '../../../../../extend';\nimport LineSegment from '../../geom/LineSegment';\nexport default function QuadEdge() {\n\tthis._rot = null;\n\tthis.vertex = null;\n\tthis.next = null;\n\tthis.data = null;\n}\nextend(QuadEdge.prototype, {\n\tequalsNonOriented: function (qe) {\n\t\tif (this.equalsOriented(qe)) return true;\n\t\tif (this.equalsOriented(qe.sym())) return true;\n\t\treturn false;\n\t},\n\ttoLineSegment: function () {\n\t\treturn new LineSegment(this.vertex.getCoordinate(), this.dest().getCoordinate());\n\t},\n\tdest: function () {\n\t\treturn this.sym().orig();\n\t},\n\toNext: function () {\n\t\treturn this.next;\n\t},\n\tequalsOriented: function (qe) {\n\t\tif (this.orig().getCoordinate().equals2D(qe.orig().getCoordinate()) && this.dest().getCoordinate().equals2D(qe.dest().getCoordinate())) return true;\n\t\treturn false;\n\t},\n\tdNext: function () {\n\t\treturn this.sym().oNext().sym();\n\t},\n\tlPrev: function () {\n\t\treturn this.next.sym();\n\t},\n\trPrev: function () {\n\t\treturn this.sym().oNext();\n\t},\n\trot: function () {\n\t\treturn this._rot;\n\t},\n\toPrev: function () {\n\t\treturn this._rot.next._rot;\n\t},\n\tsym: function () {\n\t\treturn this._rot._rot;\n\t},\n\tsetOrig: function (o) {\n\t\tthis.vertex = o;\n\t},\n\tlNext: function () {\n\t\treturn this.invRot().oNext().rot();\n\t},\n\tgetLength: function () {\n\t\treturn this.orig().getCoordinate().distance(this.dest().getCoordinate());\n\t},\n\tinvRot: function () {\n\t\treturn this._rot.sym();\n\t},\n\tsetDest: function (d) {\n\t\tthis.sym().setOrig(d);\n\t},\n\tsetData: function (data) {\n\t\tthis.data = data;\n\t},\n\tgetData: function () {\n\t\treturn this.data;\n\t},\n\tdelete: function () {\n\t\tthis._rot = null;\n\t},\n\torig: function () {\n\t\treturn this.vertex;\n\t},\n\trNext: function () {\n\t\treturn this._rot.next.invRot();\n\t},\n\ttoString: function () {\n\t\tvar p0 = this.vertex.getCoordinate();\n\t\tvar p1 = this.dest().getCoordinate();\n\t\treturn WKTWriter.toLineString(p0, p1);\n\t},\n\tisLive: function () {\n\t\treturn this._rot !== null;\n\t},\n\tgetPrimary: function () {\n\t\tif (this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0) return this; else return this.sym();\n\t},\n\tdPrev: function () {\n\t\treturn this.invRot().oNext().invRot();\n\t},\n\tsetNext: function (next) {\n\t\tthis.next = next;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn QuadEdge;\n\t}\n});\nQuadEdge.makeEdge = function (o, d) {\n\tvar q0 = new QuadEdge();\n\tvar q1 = new QuadEdge();\n\tvar q2 = new QuadEdge();\n\tvar q3 = new QuadEdge();\n\tq0._rot = q1;\n\tq1._rot = q2;\n\tq2._rot = q3;\n\tq3._rot = q0;\n\tq0.setNext(q0);\n\tq1.setNext(q3);\n\tq2.setNext(q2);\n\tq3.setNext(q1);\n\tvar base = q0;\n\tbase.setOrig(o);\n\tbase.setDest(d);\n\treturn base;\n};\nQuadEdge.swap = function (e) {\n\tvar a = e.oPrev();\n\tvar b = e.sym().oPrev();\n\tQuadEdge.splice(e, a);\n\tQuadEdge.splice(e.sym(), b);\n\tQuadEdge.splice(e, a.lNext());\n\tQuadEdge.splice(e.sym(), b.lNext());\n\te.setOrig(a.dest());\n\te.setDest(b.dest());\n};\nQuadEdge.splice = function (a, b) {\n\tvar alpha = a.oNext().rot();\n\tvar beta = b.oNext().rot();\n\tvar t1 = b.oNext();\n\tvar t2 = a.oNext();\n\tvar t3 = beta.oNext();\n\tvar t4 = alpha.oNext();\n\ta.setNext(t1);\n\tb.setNext(t2);\n\talpha.setNext(t3);\n\tbeta.setNext(t4);\n};\nQuadEdge.connect = function (a, b) {\n\tvar e = QuadEdge.makeEdge(a.dest(), b.orig());\n\tQuadEdge.splice(e, a.lNext());\n\tQuadEdge.splice(e.sym(), b);\n\treturn e;\n};\n","import QuadEdge from './quadedge/QuadEdge';\nimport extend from '../../../../extend';\nexport default function IncrementalDelaunayTriangulator() {\n\tthis.subdiv = null;\n\tthis.isUsingTolerance = false;\n\tlet subdiv = arguments[0];\n\tthis.subdiv = subdiv;\n\tthis.isUsingTolerance = subdiv.getTolerance() > 0.0;\n}\nextend(IncrementalDelaunayTriangulator.prototype, {\n\tinsertSite: function (v) {\n\t\tvar e = this.subdiv.locate(v);\n\t\tif (this.subdiv.isVertexOfEdge(e, v)) {\n\t\t\treturn e;\n\t\t} else if (this.subdiv.isOnEdge(e, v.getCoordinate())) {\n\t\t\te = e.oPrev();\n\t\t\tthis.subdiv.delete(e.oNext());\n\t\t}\n\t\tvar base = this.subdiv.makeEdge(e.orig(), v);\n\t\tQuadEdge.splice(base, e);\n\t\tvar startEdge = base;\n\t\tdo {\n\t\t\tbase = this.subdiv.connect(e, base.sym());\n\t\t\te = base.oPrev();\n\t\t} while (e.lNext() !== startEdge);\n\t\tdo {\n\t\t\tvar t = e.oPrev();\n\t\t\tif (t.dest().rightOf(e) && v.isInCircle(e.orig(), t.dest(), e.dest())) {\n\t\t\t\tQuadEdge.swap(e);\n\t\t\t\te = e.oPrev();\n\t\t\t} else if (e.oNext() === startEdge) {\n\t\t\t\treturn base;\n\t\t\t} else {\n\t\t\t\te = e.oNext().lPrev();\n\t\t\t}\n\t\t} while (true);\n\t},\n\tinsertSites: function (vertices) {\n\t\tfor (var i = vertices.iterator(); i.hasNext(); ) {\n\t\t\tvar v = i.next();\n\t\t\tthis.insertSite(v);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn IncrementalDelaunayTriangulator;\n\t}\n});\n","import extend from '../../../../../extend';\nexport default function QuadEdgeLocator() {}\nextend(QuadEdgeLocator.prototype, {\n\tlocate: function (v) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn QuadEdgeLocator;\n\t}\n});\n","import extend from '../../../../../extend';\nimport QuadEdgeLocator from './QuadEdgeLocator';\nexport default function LastFoundQuadEdgeLocator() {\n\tthis.subdiv = null;\n\tthis.lastEdge = null;\n\tlet subdiv = arguments[0];\n\tthis.subdiv = subdiv;\n\tthis.init();\n}\nextend(LastFoundQuadEdgeLocator.prototype, {\n\tinit: function () {\n\t\tthis.lastEdge = this.findEdge();\n\t},\n\tlocate: function (v) {\n\t\tif (!this.lastEdge.isLive()) {\n\t\t\tthis.init();\n\t\t}\n\t\tvar e = this.subdiv.locateFromEdge(v, this.lastEdge);\n\t\tthis.lastEdge = e;\n\t\treturn e;\n\t},\n\tfindEdge: function () {\n\t\tvar edges = this.subdiv.getEdges();\n\t\treturn edges.iterator().next();\n\t},\n\tinterfaces_: function () {\n\t\treturn [QuadEdgeLocator];\n\t},\n\tgetClass: function () {\n\t\treturn LastFoundQuadEdgeLocator;\n\t}\n});\n","import extend from '../../../../../extend';\nimport LineSegment from '../../geom/LineSegment';\nimport RuntimeException from '../../../../../java/lang/RuntimeException';\nimport inherits from '../../../../../inherits';\nexport default function LocateFailureException() {\n\tthis.seg = null;\n\tif (arguments.length === 1) {\n\t\tif (typeof arguments[0] === \"string\") {\n\t\t\tlet msg = arguments[0];\n\t\t\tRuntimeException.call(this, msg);\n\t\t} else if (arguments[0] instanceof LineSegment) {\n\t\t\tlet seg = arguments[0];\n\t\t\tRuntimeException.call(this, \"Locate failed to converge (at edge: \" + seg + \").  Possible causes include invalid Subdivision topology or very close sites\");\n\t\t\tthis.seg = new LineSegment(seg);\n\t\t}\n\t} else if (arguments.length === 2) {\n\t\tlet msg = arguments[0], seg = arguments[1];\n\t\tRuntimeException.call(this, LocateFailureException.msgWithSpatial(msg, seg));\n\t\tthis.seg = new LineSegment(seg);\n\t}\n}\ninherits(LocateFailureException, RuntimeException);\nextend(LocateFailureException.prototype, {\n\tgetSegment: function () {\n\t\treturn this.seg;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LocateFailureException;\n\t}\n});\nLocateFailureException.msgWithSpatial = function (msg, seg) {\n\tif (seg !== null) return msg + \" [ \" + seg + \" ]\";\n\treturn msg;\n};\n","import extend from '../../../../../extend';\nexport default function TriangleVisitor() {}\nextend(TriangleVisitor.prototype, {\n\tvisit: function (triEdges) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn TriangleVisitor;\n\t}\n});\n","import QuadEdge from './QuadEdge';\nimport CoordinateList from '../../geom/CoordinateList';\nimport HashSet from '../../../../../java/util/HashSet';\nimport WKTWriter from '../../io/WKTWriter';\nimport GeometryFactory from '../../geom/GeometryFactory';\nimport Coordinate from '../../geom/Coordinate';\nimport IllegalArgumentException from '../../../../../java/lang/IllegalArgumentException';\nimport Stack from '../../../../../java/util/Stack';\nimport extend from '../../../../../extend';\nimport LastFoundQuadEdgeLocator from './LastFoundQuadEdgeLocator';\nimport LocateFailureException from './LocateFailureException';\nimport Vertex from './Vertex';\nimport System from '../../../../../java/lang/System';\nimport LineSegment from '../../geom/LineSegment';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport Envelope from '../../geom/Envelope';\nimport Triangle from '../../geom/Triangle';\nimport TriangleVisitor from './TriangleVisitor';\nexport default function QuadEdgeSubdivision() {\n\tthis.visitedKey = 0;\n\tthis.quadEdges = new ArrayList();\n\tthis.startingEdge = null;\n\tthis.tolerance = null;\n\tthis.edgeCoincidenceTolerance = null;\n\tthis.frameVertex = new Array(3).fill(null);\n\tthis.frameEnv = null;\n\tthis.locator = null;\n\tthis.seg = new LineSegment();\n\tthis.triEdges = new Array(3).fill(null);\n\tlet env = arguments[0], tolerance = arguments[1];\n\tthis.tolerance = tolerance;\n\tthis.edgeCoincidenceTolerance = tolerance / QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR;\n\tthis.createFrame(env);\n\tthis.startingEdge = this.initSubdiv();\n\tthis.locator = new LastFoundQuadEdgeLocator(this);\n}\nextend(QuadEdgeSubdivision.prototype, {\n\tgetTriangleVertices: function (includeFrame) {\n\t\tvar visitor = new TriangleVertexListVisitor();\n\t\tthis.visitTriangles(visitor, includeFrame);\n\t\treturn visitor.getTriangleVertices();\n\t},\n\tisFrameVertex: function (v) {\n\t\tif (v.equals(this.frameVertex[0])) return true;\n\t\tif (v.equals(this.frameVertex[1])) return true;\n\t\tif (v.equals(this.frameVertex[2])) return true;\n\t\treturn false;\n\t},\n\tisVertexOfEdge: function (e, v) {\n\t\tif (v.equals(e.orig(), this.tolerance) || v.equals(e.dest(), this.tolerance)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\tconnect: function (a, b) {\n\t\tvar q = QuadEdge.connect(a, b);\n\t\tthis.quadEdges.add(q);\n\t\treturn q;\n\t},\n\tgetVoronoiCellPolygon: function (qe, geomFact) {\n\t\tvar cellPts = new ArrayList();\n\t\tvar startQE = qe;\n\t\tdo {\n\t\t\tvar cc = qe.rot().orig().getCoordinate();\n\t\t\tcellPts.add(cc);\n\t\t\tqe = qe.oPrev();\n\t\t} while (qe !== startQE);\n\t\tvar coordList = new CoordinateList();\n\t\tcoordList.addAll(cellPts, false);\n\t\tcoordList.closeRing();\n\t\tif (coordList.size() < 4) {\n\t\t\tSystem.out.println(coordList);\n\t\t\tcoordList.add(coordList.get(coordList.size() - 1), true);\n\t\t}\n\t\tvar pts = coordList.toCoordinateArray();\n\t\tvar cellPoly = geomFact.createPolygon(geomFact.createLinearRing(pts), null);\n\t\tvar v = startQE.orig();\n\t\tcellPoly.setUserData(v.getCoordinate());\n\t\treturn cellPoly;\n\t},\n\tsetLocator: function (locator) {\n\t\tthis.locator = locator;\n\t},\n\tinitSubdiv: function () {\n\t\tvar ea = this.makeEdge(this.frameVertex[0], this.frameVertex[1]);\n\t\tvar eb = this.makeEdge(this.frameVertex[1], this.frameVertex[2]);\n\t\tQuadEdge.splice(ea.sym(), eb);\n\t\tvar ec = this.makeEdge(this.frameVertex[2], this.frameVertex[0]);\n\t\tQuadEdge.splice(eb.sym(), ec);\n\t\tQuadEdge.splice(ec.sym(), ea);\n\t\treturn ea;\n\t},\n\tisFrameBorderEdge: function (e) {\n\t\tvar leftTri = new Array(3).fill(null);\n\t\tQuadEdgeSubdivision.getTriangleEdges(e, leftTri);\n\t\tvar rightTri = new Array(3).fill(null);\n\t\tQuadEdgeSubdivision.getTriangleEdges(e.sym(), rightTri);\n\t\tvar vLeftTriOther = e.lNext().dest();\n\t\tif (this.isFrameVertex(vLeftTriOther)) return true;\n\t\tvar vRightTriOther = e.sym().lNext().dest();\n\t\tif (this.isFrameVertex(vRightTriOther)) return true;\n\t\treturn false;\n\t},\n\tmakeEdge: function (o, d) {\n\t\tvar q = QuadEdge.makeEdge(o, d);\n\t\tthis.quadEdges.add(q);\n\t\treturn q;\n\t},\n\tvisitTriangles: function (triVisitor, includeFrame) {\n\t\tthis.visitedKey++;\n\t\tvar edgeStack = new Stack();\n\t\tedgeStack.push(this.startingEdge);\n\t\tvar visitedEdges = new HashSet();\n\t\twhile (!edgeStack.empty()) {\n\t\t\tvar edge = edgeStack.pop();\n\t\t\tif (!visitedEdges.contains(edge)) {\n\t\t\t\tvar triEdges = this.fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges);\n\t\t\t\tif (triEdges !== null) triVisitor.visit(triEdges);\n\t\t\t}\n\t\t}\n\t},\n\tisFrameEdge: function (e) {\n\t\tif (this.isFrameVertex(e.orig()) || this.isFrameVertex(e.dest())) return true;\n\t\treturn false;\n\t},\n\tisOnEdge: function (e, p) {\n\t\tthis.seg.setCoordinates(e.orig().getCoordinate(), e.dest().getCoordinate());\n\t\tvar dist = this.seg.distance(p);\n\t\treturn dist < this.edgeCoincidenceTolerance;\n\t},\n\tgetEnvelope: function () {\n\t\treturn new Envelope(this.frameEnv);\n\t},\n\tcreateFrame: function (env) {\n\t\tvar deltaX = env.getWidth();\n\t\tvar deltaY = env.getHeight();\n\t\tvar offset = 0.0;\n\t\tif (deltaX > deltaY) {\n\t\t\toffset = deltaX * 10.0;\n\t\t} else {\n\t\t\toffset = deltaY * 10.0;\n\t\t}\n\t\tthis.frameVertex[0] = new Vertex((env.getMaxX() + env.getMinX()) / 2.0, env.getMaxY() + offset);\n\t\tthis.frameVertex[1] = new Vertex(env.getMinX() - offset, env.getMinY() - offset);\n\t\tthis.frameVertex[2] = new Vertex(env.getMaxX() + offset, env.getMinY() - offset);\n\t\tthis.frameEnv = new Envelope(this.frameVertex[0].getCoordinate(), this.frameVertex[1].getCoordinate());\n\t\tthis.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate());\n\t},\n\tgetTriangleCoordinates: function (includeFrame) {\n\t\tvar visitor = new TriangleCoordinatesVisitor();\n\t\tthis.visitTriangles(visitor, includeFrame);\n\t\treturn visitor.getTriangles();\n\t},\n\tgetVertices: function (includeFrame) {\n\t\tvar vertices = new HashSet();\n\t\tfor (var i = this.quadEdges.iterator(); i.hasNext(); ) {\n\t\t\tvar qe = i.next();\n\t\t\tvar v = qe.orig();\n\t\t\tif (includeFrame || !this.isFrameVertex(v)) vertices.add(v);\n\t\t\tvar vd = qe.dest();\n\t\t\tif (includeFrame || !this.isFrameVertex(vd)) vertices.add(vd);\n\t\t}\n\t\treturn vertices;\n\t},\n\tfetchTriangleToVisit: function (edge, edgeStack, includeFrame, visitedEdges) {\n\t\tvar curr = edge;\n\t\tvar edgeCount = 0;\n\t\tvar isFrame = false;\n\t\tdo {\n\t\t\tthis.triEdges[edgeCount] = curr;\n\t\t\tif (this.isFrameEdge(curr)) isFrame = true;\n\t\t\tvar sym = curr.sym();\n\t\t\tif (!visitedEdges.contains(sym)) edgeStack.push(sym);\n\t\t\tvisitedEdges.add(curr);\n\t\t\tedgeCount++;\n\t\t\tcurr = curr.lNext();\n\t\t} while (curr !== edge);\n\t\tif (isFrame && !includeFrame) return null;\n\t\treturn this.triEdges;\n\t},\n\tgetEdges: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn this.quadEdges;\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet geomFact = arguments[0];\n\t\t\tvar quadEdges = this.getPrimaryEdges(false);\n\t\t\tvar edges = new Array(quadEdges.size()).fill(null);\n\t\t\tvar i = 0;\n\t\t\tfor (var it = quadEdges.iterator(); it.hasNext(); ) {\n\t\t\t\tvar qe = it.next();\n\t\t\t\tedges[i++] = geomFact.createLineString([qe.orig().getCoordinate(), qe.dest().getCoordinate()]);\n\t\t\t}\n\t\t\treturn geomFact.createMultiLineString(edges);\n\t\t}\n\t},\n\tgetVertexUniqueEdges: function (includeFrame) {\n\t\tvar edges = new ArrayList();\n\t\tvar visitedVertices = new HashSet();\n\t\tfor (var i = this.quadEdges.iterator(); i.hasNext(); ) {\n\t\t\tvar qe = i.next();\n\t\t\tvar v = qe.orig();\n\t\t\tif (!visitedVertices.contains(v)) {\n\t\t\t\tvisitedVertices.add(v);\n\t\t\t\tif (includeFrame || !this.isFrameVertex(v)) {\n\t\t\t\t\tedges.add(qe);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar qd = qe.sym();\n\t\t\tvar vd = qd.orig();\n\t\t\tif (!visitedVertices.contains(vd)) {\n\t\t\t\tvisitedVertices.add(vd);\n\t\t\t\tif (includeFrame || !this.isFrameVertex(vd)) {\n\t\t\t\t\tedges.add(qd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn edges;\n\t},\n\tgetTriangleEdges: function (includeFrame) {\n\t\tvar visitor = new TriangleEdgesListVisitor();\n\t\tthis.visitTriangles(visitor, includeFrame);\n\t\treturn visitor.getTriangleEdges();\n\t},\n\tgetPrimaryEdges: function (includeFrame) {\n\t\tthis.visitedKey++;\n\t\tvar edges = new ArrayList();\n\t\tvar edgeStack = new Stack();\n\t\tedgeStack.push(this.startingEdge);\n\t\tvar visitedEdges = new HashSet();\n\t\twhile (!edgeStack.empty()) {\n\t\t\tvar edge = edgeStack.pop();\n\t\t\tif (!visitedEdges.contains(edge)) {\n\t\t\t\tvar priQE = edge.getPrimary();\n\t\t\t\tif (includeFrame || !this.isFrameEdge(priQE)) edges.add(priQE);\n\t\t\t\tedgeStack.push(edge.oNext());\n\t\t\t\tedgeStack.push(edge.sym().oNext());\n\t\t\t\tvisitedEdges.add(edge);\n\t\t\t\tvisitedEdges.add(edge.sym());\n\t\t\t}\n\t\t}\n\t\treturn edges;\n\t},\n\tdelete: function (e) {\n\t\tQuadEdge.splice(e, e.oPrev());\n\t\tQuadEdge.splice(e.sym(), e.sym().oPrev());\n\t\tvar eSym = e.sym();\n\t\tvar eRot = e.rot();\n\t\tvar eRotSym = e.rot().sym();\n\t\tthis.quadEdges.remove(e);\n\t\tthis.quadEdges.remove(eSym);\n\t\tthis.quadEdges.remove(eRot);\n\t\tthis.quadEdges.remove(eRotSym);\n\t\te.delete();\n\t\teSym.delete();\n\t\teRot.delete();\n\t\teRotSym.delete();\n\t},\n\tlocateFromEdge: function (v, startEdge) {\n\t\tvar iter = 0;\n\t\tvar maxIter = this.quadEdges.size();\n\t\tvar e = startEdge;\n\t\twhile (true) {\n\t\t\titer++;\n\t\t\tif (iter > maxIter) {\n\t\t\t\tthrow new LocateFailureException(e.toLineSegment());\n\t\t\t}\n\t\t\tif (v.equals(e.orig()) || v.equals(e.dest())) {\n\t\t\t\tbreak;\n\t\t\t} else if (v.rightOf(e)) {\n\t\t\t\te = e.sym();\n\t\t\t} else if (!v.rightOf(e.oNext())) {\n\t\t\t\te = e.oNext();\n\t\t\t} else if (!v.rightOf(e.dPrev())) {\n\t\t\t\te = e.dPrev();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn e;\n\t},\n\tgetTolerance: function () {\n\t\treturn this.tolerance;\n\t},\n\tgetVoronoiCellPolygons: function (geomFact) {\n\t\tthis.visitTriangles(new TriangleCircumcentreVisitor(), true);\n\t\tvar cells = new ArrayList();\n\t\tvar edges = this.getVertexUniqueEdges(false);\n\t\tfor (var i = edges.iterator(); i.hasNext(); ) {\n\t\t\tvar qe = i.next();\n\t\t\tcells.add(this.getVoronoiCellPolygon(qe, geomFact));\n\t\t}\n\t\treturn cells;\n\t},\n\tgetVoronoiDiagram: function (geomFact) {\n\t\tvar vorCells = this.getVoronoiCellPolygons(geomFact);\n\t\treturn geomFact.createGeometryCollection(GeometryFactory.toGeometryArray(vorCells));\n\t},\n\tgetTriangles: function (geomFact) {\n\t\tvar triPtsList = this.getTriangleCoordinates(false);\n\t\tvar tris = new Array(triPtsList.size()).fill(null);\n\t\tvar i = 0;\n\t\tfor (var it = triPtsList.iterator(); it.hasNext(); ) {\n\t\t\tvar triPt = it.next();\n\t\t\ttris[i++] = geomFact.createPolygon(geomFact.createLinearRing(triPt), null);\n\t\t}\n\t\treturn geomFact.createGeometryCollection(tris);\n\t},\n\tinsertSite: function (v) {\n\t\tvar e = this.locate(v);\n\t\tif (v.equals(e.orig(), this.tolerance) || v.equals(e.dest(), this.tolerance)) {\n\t\t\treturn e;\n\t\t}\n\t\tvar base = this.makeEdge(e.orig(), v);\n\t\tQuadEdge.splice(base, e);\n\t\tvar startEdge = base;\n\t\tdo {\n\t\t\tbase = this.connect(e, base.sym());\n\t\t\te = base.oPrev();\n\t\t} while (e.lNext() !== startEdge);\n\t\treturn startEdge;\n\t},\n\tlocate: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tif (arguments[0] instanceof Vertex) {\n\t\t\t\tlet v = arguments[0];\n\t\t\t\treturn this.locator.locate(v);\n\t\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\t\tlet p = arguments[0];\n\t\t\t\treturn this.locator.locate(new Vertex(p));\n\t\t\t}\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\t\tvar e = this.locator.locate(new Vertex(p0));\n\t\t\tif (e === null) return null;\n\t\t\tvar base = e;\n\t\t\tif (e.dest().getCoordinate().equals2D(p0)) base = e.sym();\n\t\t\tvar locEdge = base;\n\t\t\tdo {\n\t\t\t\tif (locEdge.dest().getCoordinate().equals2D(p1)) return locEdge;\n\t\t\t\tlocEdge = locEdge.oNext();\n\t\t\t} while (locEdge !== base);\n\t\t\treturn null;\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn QuadEdgeSubdivision;\n\t}\n});\nQuadEdgeSubdivision.getTriangleEdges = function (startQE, triEdge) {\n\ttriEdge[0] = startQE;\n\ttriEdge[1] = triEdge[0].lNext();\n\ttriEdge[2] = triEdge[1].lNext();\n\tif (triEdge[2].lNext() !== triEdge[0]) throw new IllegalArgumentException(\"Edges do not form a triangle\");\n};\nfunction TriangleCircumcentreVisitor() {}\nextend(TriangleCircumcentreVisitor.prototype, {\n\tvisit: function (triEdges) {\n\t\tvar a = triEdges[0].orig().getCoordinate();\n\t\tvar b = triEdges[1].orig().getCoordinate();\n\t\tvar c = triEdges[2].orig().getCoordinate();\n\t\tvar cc = Triangle.circumcentre(a, b, c);\n\t\tvar ccVertex = new Vertex(cc);\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\ttriEdges[i].rot().setOrig(ccVertex);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [TriangleVisitor];\n\t},\n\tgetClass: function () {\n\t\treturn TriangleCircumcentreVisitor;\n\t}\n});\nfunction TriangleEdgesListVisitor() {\n\tthis.triList = new ArrayList();\n}\nextend(TriangleEdgesListVisitor.prototype, {\n\tgetTriangleEdges: function () {\n\t\treturn this.triList;\n\t},\n\tvisit: function (triEdges) {\n\t\tthis.triList.add(triEdges.clone());\n\t},\n\tinterfaces_: function () {\n\t\treturn [TriangleVisitor];\n\t},\n\tgetClass: function () {\n\t\treturn TriangleEdgesListVisitor;\n\t}\n});\nfunction TriangleVertexListVisitor() {\n\tthis.triList = new ArrayList();\n}\nextend(TriangleVertexListVisitor.prototype, {\n\tvisit: function (triEdges) {\n\t\tthis.triList.add([triEdges[0].orig(), triEdges[1].orig(), triEdges[2].orig()]);\n\t},\n\tgetTriangleVertices: function () {\n\t\treturn this.triList;\n\t},\n\tinterfaces_: function () {\n\t\treturn [TriangleVisitor];\n\t},\n\tgetClass: function () {\n\t\treturn TriangleVertexListVisitor;\n\t}\n});\nfunction TriangleCoordinatesVisitor() {\n\tthis.coordList = new CoordinateList();\n\tthis.triCoords = new ArrayList();\n}\nextend(TriangleCoordinatesVisitor.prototype, {\n\tcheckTriangleSize: function (pts) {\n\t\tvar loc = \"\";\n\t\tif (pts.length >= 2) loc = WKTWriter.toLineString(pts[0], pts[1]); else {\n\t\t\tif (pts.length >= 1) loc = WKTWriter.toPoint(pts[0]);\n\t\t}\n\t},\n\tvisit: function (triEdges) {\n\t\tthis.coordList.clear();\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\tvar v = triEdges[i].orig();\n\t\t\tthis.coordList.add(v.getCoordinate());\n\t\t}\n\t\tif (this.coordList.size() > 0) {\n\t\t\tthis.coordList.closeRing();\n\t\t\tvar pts = this.coordList.toCoordinateArray();\n\t\t\tif (pts.length !== 4) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthis.triCoords.add(pts);\n\t\t}\n\t},\n\tgetTriangles: function () {\n\t\treturn this.triCoords;\n\t},\n\tinterfaces_: function () {\n\t\treturn [TriangleVisitor];\n\t},\n\tgetClass: function () {\n\t\treturn TriangleCoordinatesVisitor;\n\t}\n});\nQuadEdgeSubdivision.TriangleCircumcentreVisitor = TriangleCircumcentreVisitor;\nQuadEdgeSubdivision.TriangleEdgesListVisitor = TriangleEdgesListVisitor;\nQuadEdgeSubdivision.TriangleVertexListVisitor = TriangleVertexListVisitor;\nQuadEdgeSubdivision.TriangleCoordinatesVisitor = TriangleCoordinatesVisitor;\nQuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR = 1000;\n","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport LineSegment from '../geom/LineSegment';\nexport default function Segment() {\n\tthis.ls = null;\n\tthis.data = null;\n\tif (arguments.length === 2) {\n\t\tlet p0 = arguments[0], p1 = arguments[1];\n\t\tthis.ls = new LineSegment(p0, p1);\n\t} else if (arguments.length === 3) {\n\t\tlet p0 = arguments[0], p1 = arguments[1], data = arguments[2];\n\t\tthis.ls = new LineSegment(p0, p1);\n\t\tthis.data = data;\n\t} else if (arguments.length === 6) {\n\t\tlet x1 = arguments[0], y1 = arguments[1], z1 = arguments[2], x2 = arguments[3], y2 = arguments[4], z2 = arguments[5];\n\t\tSegment.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2));\n\t} else if (arguments.length === 7) {\n\t\tlet x1 = arguments[0], y1 = arguments[1], z1 = arguments[2], x2 = arguments[3], y2 = arguments[4], z2 = arguments[5], data = arguments[6];\n\t\tSegment.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2), data);\n\t}\n}\nextend(Segment.prototype, {\n\tgetLineSegment: function () {\n\t\treturn this.ls;\n\t},\n\tgetEndZ: function () {\n\t\tvar p = this.ls.getCoordinate(1);\n\t\treturn p.z;\n\t},\n\tgetStartZ: function () {\n\t\tvar p = this.ls.getCoordinate(0);\n\t\treturn p.z;\n\t},\n\tintersection: function (s) {\n\t\treturn this.ls.intersection(s.getLineSegment());\n\t},\n\tgetStart: function () {\n\t\treturn this.ls.getCoordinate(0);\n\t},\n\tgetEnd: function () {\n\t\treturn this.ls.getCoordinate(1);\n\t},\n\tgetEndY: function () {\n\t\tvar p = this.ls.getCoordinate(1);\n\t\treturn p.y;\n\t},\n\tgetStartX: function () {\n\t\tvar p = this.ls.getCoordinate(0);\n\t\treturn p.x;\n\t},\n\tequalsTopo: function (s) {\n\t\treturn this.ls.equalsTopo(s.getLineSegment());\n\t},\n\tgetStartY: function () {\n\t\tvar p = this.ls.getCoordinate(0);\n\t\treturn p.y;\n\t},\n\tsetData: function (data) {\n\t\tthis.data = data;\n\t},\n\tgetData: function () {\n\t\treturn this.data;\n\t},\n\tgetEndX: function () {\n\t\tvar p = this.ls.getCoordinate(1);\n\t\treturn p.x;\n\t},\n\ttoString: function () {\n\t\treturn this.ls.toString();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn Segment;\n\t}\n});\n","import extend from '../../../../../extend';\nexport default function KdNodeVisitor() {}\nextend(KdNodeVisitor.prototype, {\n\tvisit: function (node) {},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn KdNodeVisitor;\n\t}\n});\n","import Coordinate from '../../geom/Coordinate';\nimport extend from '../../../../../extend';\nexport default function KdNode() {\n\tthis.p = null;\n\tthis.data = null;\n\tthis.left = null;\n\tthis.right = null;\n\tthis.count = null;\n\tif (arguments.length === 2) {\n\t\tlet p = arguments[0], data = arguments[1];\n\t\tthis.p = new Coordinate(p);\n\t\tthis.left = null;\n\t\tthis.right = null;\n\t\tthis.count = 1;\n\t\tthis.data = data;\n\t} else if (arguments.length === 3) {\n\t\tlet _x = arguments[0], _y = arguments[1], data = arguments[2];\n\t\tthis.p = new Coordinate(_x, _y);\n\t\tthis.left = null;\n\t\tthis.right = null;\n\t\tthis.count = 1;\n\t\tthis.data = data;\n\t}\n}\nextend(KdNode.prototype, {\n\tisRepeated: function () {\n\t\treturn this.count > 1;\n\t},\n\tgetRight: function () {\n\t\treturn this.right;\n\t},\n\tgetCoordinate: function () {\n\t\treturn this.p;\n\t},\n\tsetLeft: function (_left) {\n\t\tthis.left = _left;\n\t},\n\tgetX: function () {\n\t\treturn this.p.x;\n\t},\n\tgetData: function () {\n\t\treturn this.data;\n\t},\n\tgetCount: function () {\n\t\treturn this.count;\n\t},\n\tgetLeft: function () {\n\t\treturn this.left;\n\t},\n\tgetY: function () {\n\t\treturn this.p.y;\n\t},\n\tincrement: function () {\n\t\tthis.count = this.count + 1;\n\t},\n\tsetRight: function (_right) {\n\t\tthis.right = _right;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn KdNode;\n\t}\n});\n","import CoordinateList from '../../geom/CoordinateList';\nimport hasInterface from '../../../../../hasInterface';\nimport extend from '../../../../../extend';\nimport ArrayList from '../../../../../java/util/ArrayList';\nimport KdNodeVisitor from './KdNodeVisitor';\nimport Envelope from '../../geom/Envelope';\nimport List from '../../../../../java/util/List';\nimport KdNode from './KdNode';\nexport default function KdTree() {\n\tthis.root = null;\n\tthis.numberOfNodes = null;\n\tthis.tolerance = null;\n\tif (arguments.length === 0) {\n\t\tKdTree.call(this, 0.0);\n\t} else if (arguments.length === 1) {\n\t\tlet tolerance = arguments[0];\n\t\tthis.tolerance = tolerance;\n\t}\n}\nextend(KdTree.prototype, {\n\tinsert: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet p = arguments[0];\n\t\t\treturn this.insert(p, null);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p = arguments[0], data = arguments[1];\n\t\t\tif (this.root === null) {\n\t\t\t\tthis.root = new KdNode(p, data);\n\t\t\t\treturn this.root;\n\t\t\t}\n\t\t\tif (this.tolerance > 0) {\n\t\t\t\tvar matchNode = this.findBestMatchNode(p);\n\t\t\t\tif (matchNode !== null) {\n\t\t\t\t\tmatchNode.increment();\n\t\t\t\t\treturn matchNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.insertExact(p, data);\n\t\t}\n\t},\n\tquery: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet queryEnv = arguments[0];\n\t\t\tvar result = new ArrayList();\n\t\t\tthis.query(queryEnv, result);\n\t\t\treturn result;\n\t\t} else if (arguments.length === 2) {\n\t\t\tif (arguments[0] instanceof Envelope && hasInterface(arguments[1], List)) {\n\t\t\t\tlet queryEnv = arguments[0], result = arguments[1];\n\t\t\t\tthis.queryNode(this.root, queryEnv, true, {\n\t\t\t\t\tinterfaces_: function () {\n\t\t\t\t\t\treturn [KdNodeVisitor];\n\t\t\t\t\t},\n\t\t\t\t\tvisit: function (node) {\n\t\t\t\t\t\tresult.add(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (arguments[0] instanceof Envelope && hasInterface(arguments[1], KdNodeVisitor)) {\n\t\t\t\tlet queryEnv = arguments[0], visitor = arguments[1];\n\t\t\t\tthis.queryNode(this.root, queryEnv, true, visitor);\n\t\t\t}\n\t\t}\n\t},\n\tqueryNode: function (currentNode, queryEnv, odd, visitor) {\n\t\tif (currentNode === null) return null;\n\t\tvar min = null;\n\t\tvar max = null;\n\t\tvar discriminant = null;\n\t\tif (odd) {\n\t\t\tmin = queryEnv.getMinX();\n\t\t\tmax = queryEnv.getMaxX();\n\t\t\tdiscriminant = currentNode.getX();\n\t\t} else {\n\t\t\tmin = queryEnv.getMinY();\n\t\t\tmax = queryEnv.getMaxY();\n\t\t\tdiscriminant = currentNode.getY();\n\t\t}\n\t\tvar searchLeft = min < discriminant;\n\t\tvar searchRight = discriminant <= max;\n\t\tif (searchLeft) {\n\t\t\tthis.queryNode(currentNode.getLeft(), queryEnv, !odd, visitor);\n\t\t}\n\t\tif (queryEnv.contains(currentNode.getCoordinate())) {\n\t\t\tvisitor.visit(currentNode);\n\t\t}\n\t\tif (searchRight) {\n\t\t\tthis.queryNode(currentNode.getRight(), queryEnv, !odd, visitor);\n\t\t}\n\t},\n\tfindBestMatchNode: function (p) {\n\t\tvar visitor = new BestMatchVisitor(p, this.tolerance);\n\t\tthis.query(visitor.queryEnvelope(), visitor);\n\t\treturn visitor.getNode();\n\t},\n\tisEmpty: function () {\n\t\tif (this.root === null) return true;\n\t\treturn false;\n\t},\n\tinsertExact: function (p, data) {\n\t\tvar currentNode = this.root;\n\t\tvar leafNode = this.root;\n\t\tvar isOddLevel = true;\n\t\tvar isLessThan = true;\n\t\twhile (currentNode !== null) {\n\t\t\tif (currentNode !== null) {\n\t\t\t\tvar isInTolerance = p.distance(currentNode.getCoordinate()) <= this.tolerance;\n\t\t\t\tif (isInTolerance) {\n\t\t\t\t\tcurrentNode.increment();\n\t\t\t\t\treturn currentNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOddLevel) {\n\t\t\t\tisLessThan = p.x < currentNode.getX();\n\t\t\t} else {\n\t\t\t\tisLessThan = p.y < currentNode.getY();\n\t\t\t}\n\t\t\tleafNode = currentNode;\n\t\t\tif (isLessThan) {\n\t\t\t\tcurrentNode = currentNode.getLeft();\n\t\t\t} else {\n\t\t\t\tcurrentNode = currentNode.getRight();\n\t\t\t}\n\t\t\tisOddLevel = !isOddLevel;\n\t\t}\n\t\tthis.numberOfNodes = this.numberOfNodes + 1;\n\t\tvar node = new KdNode(p, data);\n\t\tif (isLessThan) {\n\t\t\tleafNode.setLeft(node);\n\t\t} else {\n\t\t\tleafNode.setRight(node);\n\t\t}\n\t\treturn node;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn KdTree;\n\t}\n});\nKdTree.toCoordinates = function () {\n\tif (arguments.length === 1) {\n\t\tlet kdnodes = arguments[0];\n\t\treturn KdTree.toCoordinates(kdnodes, false);\n\t} else if (arguments.length === 2) {\n\t\tlet kdnodes = arguments[0], includeRepeated = arguments[1];\n\t\tvar coord = new CoordinateList();\n\t\tfor (var it = kdnodes.iterator(); it.hasNext(); ) {\n\t\t\tvar node = it.next();\n\t\t\tvar count = includeRepeated ? node.getCount() : 1;\n\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\tcoord.add(node.getCoordinate(), true);\n\t\t\t}\n\t\t}\n\t\treturn coord.toCoordinateArray();\n\t}\n};\nfunction BestMatchVisitor() {\n\tthis.tolerance = null;\n\tthis.matchNode = null;\n\tthis.matchDist = 0.0;\n\tthis.p = null;\n\tlet p = arguments[0], tolerance = arguments[1];\n\tthis.p = p;\n\tthis.tolerance = tolerance;\n}\nextend(BestMatchVisitor.prototype, {\n\tvisit: function (node) {\n\t\tvar dist = this.p.distance(node.getCoordinate());\n\t\tvar isInTolerance = dist <= this.tolerance;\n\t\tif (!isInTolerance) return null;\n\t\tvar update = false;\n\t\tif (this.matchNode === null || dist < this.matchDist || this.matchNode !== null && dist === this.matchDist && node.getCoordinate().compareTo(this.matchNode.getCoordinate()) < 1) update = true;\n\t\tif (update) {\n\t\t\tthis.matchNode = node;\n\t\t\tthis.matchDist = dist;\n\t\t}\n\t},\n\tqueryEnvelope: function () {\n\t\tvar queryEnv = new Envelope(this.p);\n\t\tqueryEnv.expandBy(this.tolerance);\n\t\treturn queryEnv;\n\t},\n\tgetNode: function () {\n\t\treturn this.matchNode;\n\t},\n\tinterfaces_: function () {\n\t\treturn [KdNodeVisitor];\n\t},\n\tgetClass: function () {\n\t\treturn BestMatchVisitor;\n\t}\n});\nKdTree.BestMatchVisitor = BestMatchVisitor;\n","import GeometryFactory from '../geom/GeometryFactory';\nimport NonEncroachingSplitPointFinder from './NonEncroachingSplitPointFinder';\nimport ConstraintVertex from './ConstraintVertex';\nimport Coordinate from '../geom/Coordinate';\nimport IncrementalDelaunayTriangulator from './IncrementalDelaunayTriangulator';\nimport QuadEdgeSubdivision from './quadedge/QuadEdgeSubdivision';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport LastFoundQuadEdgeLocator from './quadedge/LastFoundQuadEdgeLocator';\nimport Segment from './Segment';\nimport ConvexHull from '../algorithm/ConvexHull';\nimport KdTree from '../index/kdtree/KdTree';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Envelope from '../geom/Envelope';\nexport default function ConformingDelaunayTriangulator() {\n\tthis.initialVertices = null;\n\tthis.segVertices = null;\n\tthis.segments = new ArrayList();\n\tthis.subdiv = null;\n\tthis.incDel = null;\n\tthis.convexHull = null;\n\tthis.splitFinder = new NonEncroachingSplitPointFinder();\n\tthis.kdt = null;\n\tthis.vertexFactory = null;\n\tthis.computeAreaEnv = null;\n\tthis.splitPt = null;\n\tthis.tolerance = null;\n\tlet initialVertices = arguments[0], tolerance = arguments[1];\n\tthis.initialVertices = new ArrayList(initialVertices);\n\tthis.tolerance = tolerance;\n\tthis.kdt = new KdTree(tolerance);\n}\nextend(ConformingDelaunayTriangulator.prototype, {\n\tgetInitialVertices: function () {\n\t\treturn this.initialVertices;\n\t},\n\tgetKDT: function () {\n\t\treturn this.kdt;\n\t},\n\tenforceConstraints: function () {\n\t\tthis.addConstraintVertices();\n\t\tvar count = 0;\n\t\tvar splits = 0;\n\t\tdo {\n\t\t\tsplits = this.enforceGabriel(this.segments);\n\t\t\tcount++;\n\t\t} while (splits > 0 && count < ConformingDelaunayTriangulator.MAX_SPLIT_ITER);\n\t},\n\tinsertSites: function (vertices) {\n\t\tfor (var i = vertices.iterator(); i.hasNext(); ) {\n\t\t\tvar v = i.next();\n\t\t\tthis.insertSite(v);\n\t\t}\n\t},\n\tgetVertexFactory: function () {\n\t\treturn this.vertexFactory;\n\t},\n\tgetPointArray: function () {\n\t\tvar pts = new Array(this.initialVertices.size() + this.segVertices.size()).fill(null);\n\t\tvar index = 0;\n\t\tfor (var i = this.initialVertices.iterator(); i.hasNext(); ) {\n\t\t\tvar v = i.next();\n\t\t\tpts[index++] = v.getCoordinate();\n\t\t}\n\t\tfor (var i2 = this.segVertices.iterator(); i2.hasNext(); ) {\n\t\t\tvar v = i2.next();\n\t\t\tpts[index++] = v.getCoordinate();\n\t\t}\n\t\treturn pts;\n\t},\n\tsetConstraints: function (segments, segVertices) {\n\t\tthis.segments = segments;\n\t\tthis.segVertices = segVertices;\n\t},\n\tcomputeConvexHull: function () {\n\t\tvar fact = new GeometryFactory();\n\t\tvar coords = this.getPointArray();\n\t\tvar hull = new ConvexHull(coords, fact);\n\t\tthis.convexHull = hull.getConvexHull();\n\t},\n\taddConstraintVertices: function () {\n\t\tthis.computeConvexHull();\n\t\tthis.insertSites(this.segVertices);\n\t},\n\tfindNonGabrielPoint: function (seg) {\n\t\tvar p = seg.getStart();\n\t\tvar q = seg.getEnd();\n\t\tvar midPt = new Coordinate((p.x + q.x) / 2.0, (p.y + q.y) / 2.0);\n\t\tvar segRadius = p.distance(midPt);\n\t\tvar env = new Envelope(midPt);\n\t\tenv.expandBy(segRadius);\n\t\tvar result = this.kdt.query(env);\n\t\tvar closestNonGabriel = null;\n\t\tvar minDist = Double.MAX_VALUE;\n\t\tfor (var i = result.iterator(); i.hasNext(); ) {\n\t\t\tvar nextNode = i.next();\n\t\t\tvar testPt = nextNode.getCoordinate();\n\t\t\tif (testPt.equals2D(p) || testPt.equals2D(q)) continue;\n\t\t\tvar testRadius = midPt.distance(testPt);\n\t\t\tif (testRadius < segRadius) {\n\t\t\t\tvar testDist = testRadius;\n\t\t\t\tif (closestNonGabriel === null || testDist < minDist) {\n\t\t\t\t\tclosestNonGabriel = testPt;\n\t\t\t\t\tminDist = testDist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn closestNonGabriel;\n\t},\n\tgetConstraintSegments: function () {\n\t\treturn this.segments;\n\t},\n\tsetSplitPointFinder: function (splitFinder) {\n\t\tthis.splitFinder = splitFinder;\n\t},\n\tgetConvexHull: function () {\n\t\treturn this.convexHull;\n\t},\n\tgetTolerance: function () {\n\t\treturn this.tolerance;\n\t},\n\tenforceGabriel: function (segsToInsert) {\n\t\tvar newSegments = new ArrayList();\n\t\tvar splits = 0;\n\t\tvar segsToRemove = new ArrayList();\n\t\tfor (var i = segsToInsert.iterator(); i.hasNext(); ) {\n\t\t\tvar seg = i.next();\n\t\t\tvar encroachPt = this.findNonGabrielPoint(seg);\n\t\t\tif (encroachPt === null) continue;\n\t\t\tthis.splitPt = this.splitFinder.findSplitPoint(seg, encroachPt);\n\t\t\tvar splitVertex = this.createVertex(this.splitPt, seg);\n\t\t\tvar insertedVertex = this.insertSite(splitVertex);\n\t\t\tvar s1 = new Segment(seg.getStartX(), seg.getStartY(), seg.getStartZ(), splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getData());\n\t\t\tvar s2 = new Segment(splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getEndX(), seg.getEndY(), seg.getEndZ(), seg.getData());\n\t\t\tnewSegments.add(s1);\n\t\t\tnewSegments.add(s2);\n\t\t\tsegsToRemove.add(seg);\n\t\t\tsplits = splits + 1;\n\t\t}\n\t\tsegsToInsert.removeAll(segsToRemove);\n\t\tsegsToInsert.addAll(newSegments);\n\t\treturn splits;\n\t},\n\tcreateVertex: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet p = arguments[0];\n\t\t\tvar v = null;\n\t\t\tif (this.vertexFactory !== null) v = this.vertexFactory.createVertex(p, null); else v = new ConstraintVertex(p);\n\t\t\treturn v;\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet p = arguments[0], seg = arguments[1];\n\t\t\tvar v = null;\n\t\t\tif (this.vertexFactory !== null) v = this.vertexFactory.createVertex(p, seg); else v = new ConstraintVertex(p);\n\t\t\tv.setOnConstraint(true);\n\t\t\treturn v;\n\t\t}\n\t},\n\tgetSubdivision: function () {\n\t\treturn this.subdiv;\n\t},\n\tcomputeBoundingBox: function () {\n\t\tvar vertexEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this.initialVertices);\n\t\tvar segEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this.segVertices);\n\t\tvar allPointsEnv = new Envelope(vertexEnv);\n\t\tallPointsEnv.expandToInclude(segEnv);\n\t\tvar deltaX = allPointsEnv.getWidth() * 0.2;\n\t\tvar deltaY = allPointsEnv.getHeight() * 0.2;\n\t\tvar delta = Math.max(deltaX, deltaY);\n\t\tthis.computeAreaEnv = new Envelope(allPointsEnv);\n\t\tthis.computeAreaEnv.expandBy(delta);\n\t},\n\tsetVertexFactory: function (vertexFactory) {\n\t\tthis.vertexFactory = vertexFactory;\n\t},\n\tformInitialDelaunay: function () {\n\t\tthis.computeBoundingBox();\n\t\tthis.subdiv = new QuadEdgeSubdivision(this.computeAreaEnv, this.tolerance);\n\t\tthis.subdiv.setLocator(new LastFoundQuadEdgeLocator(this.subdiv));\n\t\tthis.incDel = new IncrementalDelaunayTriangulator(this.subdiv);\n\t\tthis.insertSites(this.initialVertices);\n\t},\n\tinsertSite: function () {\n\t\tif (arguments[0] instanceof ConstraintVertex) {\n\t\t\tlet v = arguments[0];\n\t\t\tvar kdnode = this.kdt.insert(v.getCoordinate(), v);\n\t\t\tif (!kdnode.isRepeated()) {\n\t\t\t\tthis.incDel.insertSite(v);\n\t\t\t} else {\n\t\t\t\tvar snappedV = kdnode.getData();\n\t\t\t\tsnappedV.merge(v);\n\t\t\t\treturn snappedV;\n\t\t\t}\n\t\t\treturn v;\n\t\t} else if (arguments[0] instanceof Coordinate) {\n\t\t\tlet p = arguments[0];\n\t\t\tthis.insertSite(this.createVertex(p));\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ConformingDelaunayTriangulator;\n\t}\n});\nConformingDelaunayTriangulator.computeVertexEnvelope = function (vertices) {\n\tvar env = new Envelope();\n\tfor (var i = vertices.iterator(); i.hasNext(); ) {\n\t\tvar v = i.next();\n\t\tenv.expandToInclude(v.getCoordinate());\n\t}\n\treturn env;\n};\nConformingDelaunayTriangulator.MAX_SPLIT_ITER = 99;\n","import CoordinateList from '../geom/CoordinateList';\nimport Geometry from '../geom/Geometry';\nimport Arrays from '../../../../java/util/Arrays';\nimport hasInterface from '../../../../hasInterface';\nimport Collection from '../../../../java/util/Collection';\nimport IncrementalDelaunayTriangulator from './IncrementalDelaunayTriangulator';\nimport QuadEdgeSubdivision from './quadedge/QuadEdgeSubdivision';\nimport extend from '../../../../extend';\nimport Vertex from './quadedge/Vertex';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport Envelope from '../geom/Envelope';\nexport default function DelaunayTriangulationBuilder() {\n\tthis.siteCoords = null;\n\tthis.tolerance = 0.0;\n\tthis.subdiv = null;\n}\nextend(DelaunayTriangulationBuilder.prototype, {\n\tcreate: function () {\n\t\tif (this.subdiv !== null) return null;\n\t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this.siteCoords);\n\t\tvar vertices = DelaunayTriangulationBuilder.toVertices(this.siteCoords);\n\t\tthis.subdiv = new QuadEdgeSubdivision(siteEnv, this.tolerance);\n\t\tvar triangulator = new IncrementalDelaunayTriangulator(this.subdiv);\n\t\ttriangulator.insertSites(vertices);\n\t},\n\tsetTolerance: function (tolerance) {\n\t\tthis.tolerance = tolerance;\n\t},\n\tsetSites: function () {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet geom = arguments[0];\n\t\t\tthis.siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n\t\t} else if (hasInterface(arguments[0], Collection)) {\n\t\t\tlet coords = arguments[0];\n\t\t\tthis.siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n\t\t}\n\t},\n\tgetEdges: function (geomFact) {\n\t\tthis.create();\n\t\treturn this.subdiv.getEdges(geomFact);\n\t},\n\tgetSubdivision: function () {\n\t\tthis.create();\n\t\treturn this.subdiv;\n\t},\n\tgetTriangles: function (geomFact) {\n\t\tthis.create();\n\t\treturn this.subdiv.getTriangles(geomFact);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn DelaunayTriangulationBuilder;\n\t}\n});\nDelaunayTriangulationBuilder.extractUniqueCoordinates = function (geom) {\n\tif (geom === null) return new CoordinateList();\n\tvar coords = geom.getCoordinates();\n\treturn DelaunayTriangulationBuilder.unique(coords);\n};\nDelaunayTriangulationBuilder.envelope = function (coords) {\n\tvar env = new Envelope();\n\tfor (var i = coords.iterator(); i.hasNext(); ) {\n\t\tvar coord = i.next();\n\t\tenv.expandToInclude(coord);\n\t}\n\treturn env;\n};\nDelaunayTriangulationBuilder.unique = function (coords) {\n\tvar coordsCopy = CoordinateArrays.copyDeep(coords);\n\tArrays.sort(coordsCopy);\n\tvar coordList = new CoordinateList(coordsCopy, false);\n\treturn coordList;\n};\nDelaunayTriangulationBuilder.toVertices = function (coords) {\n\tvar verts = new ArrayList();\n\tfor (var i = coords.iterator(); i.hasNext(); ) {\n\t\tvar coord = i.next();\n\t\tverts.add(new Vertex(coord));\n\t}\n\treturn verts;\n};\n","import ConformingDelaunayTriangulator from './ConformingDelaunayTriangulator';\nimport ConstraintVertex from './ConstraintVertex';\nimport extend from '../../../../extend';\nimport DelaunayTriangulationBuilder from './DelaunayTriangulationBuilder';\nimport Segment from './Segment';\nimport ArrayList from '../../../../java/util/ArrayList';\nimport LinearComponentExtracter from '../geom/util/LinearComponentExtracter';\nimport TreeMap from '../../../../java/util/TreeMap';\nexport default function ConformingDelaunayTriangulationBuilder() {\n\tthis.siteCoords = null;\n\tthis.constraintLines = null;\n\tthis.tolerance = 0.0;\n\tthis.subdiv = null;\n\tthis.constraintVertexMap = new TreeMap();\n}\nextend(ConformingDelaunayTriangulationBuilder.prototype, {\n\tcreateSiteVertices: function (coords) {\n\t\tvar verts = new ArrayList();\n\t\tfor (var i = coords.iterator(); i.hasNext(); ) {\n\t\t\tvar coord = i.next();\n\t\t\tif (this.constraintVertexMap.containsKey(coord)) continue;\n\t\t\tverts.add(new ConstraintVertex(coord));\n\t\t}\n\t\treturn verts;\n\t},\n\tcreate: function () {\n\t\tif (this.subdiv !== null) return null;\n\t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this.siteCoords);\n\t\tvar segments = new ArrayList();\n\t\tif (this.constraintLines !== null) {\n\t\t\tsiteEnv.expandToInclude(this.constraintLines.getEnvelopeInternal());\n\t\t\tthis.createVertices(this.constraintLines);\n\t\t\tsegments = ConformingDelaunayTriangulationBuilder.createConstraintSegments(this.constraintLines);\n\t\t}\n\t\tvar sites = this.createSiteVertices(this.siteCoords);\n\t\tvar cdt = new ConformingDelaunayTriangulator(sites, this.tolerance);\n\t\tcdt.setConstraints(segments, new ArrayList(this.constraintVertexMap.values()));\n\t\tcdt.formInitialDelaunay();\n\t\tcdt.enforceConstraints();\n\t\tthis.subdiv = cdt.getSubdivision();\n\t},\n\tsetTolerance: function (tolerance) {\n\t\tthis.tolerance = tolerance;\n\t},\n\tsetConstraints: function (constraintLines) {\n\t\tthis.constraintLines = constraintLines;\n\t},\n\tsetSites: function (geom) {\n\t\tthis.siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n\t},\n\tgetEdges: function (geomFact) {\n\t\tthis.create();\n\t\treturn this.subdiv.getEdges(geomFact);\n\t},\n\tgetSubdivision: function () {\n\t\tthis.create();\n\t\treturn this.subdiv;\n\t},\n\tgetTriangles: function (geomFact) {\n\t\tthis.create();\n\t\treturn this.subdiv.getTriangles(geomFact);\n\t},\n\tcreateVertices: function (geom) {\n\t\tvar coords = geom.getCoordinates();\n\t\tfor (var i = 0; i < coords.length; i++) {\n\t\t\tvar v = new ConstraintVertex(coords[i]);\n\t\t\tthis.constraintVertexMap.put(coords[i], v);\n\t\t}\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ConformingDelaunayTriangulationBuilder;\n\t}\n});\nConformingDelaunayTriangulationBuilder.createConstraintSegments = function () {\n\tif (arguments.length === 1) {\n\t\tlet geom = arguments[0];\n\t\tvar lines = LinearComponentExtracter.getLines(geom);\n\t\tvar constraintSegs = new ArrayList();\n\t\tfor (var i = lines.iterator(); i.hasNext(); ) {\n\t\t\tvar line = i.next();\n\t\t\tConformingDelaunayTriangulationBuilder.createConstraintSegments(line, constraintSegs);\n\t\t}\n\t\treturn constraintSegs;\n\t} else if (arguments.length === 2) {\n\t\tlet line = arguments[0], constraintSegs = arguments[1];\n\t\tvar coords = line.getCoordinates();\n\t\tfor (var i = 1; i < coords.length; i++) {\n\t\t\tconstraintSegs.add(new Segment(coords[i - 1], coords[i]));\n\t\t}\n\t}\n};\n","import Geometry from '../geom/Geometry';\nimport hasInterface from '../../../../hasInterface';\nimport GeometryFactory from '../geom/GeometryFactory';\nimport Collection from '../../../../java/util/Collection';\nimport IncrementalDelaunayTriangulator from './IncrementalDelaunayTriangulator';\nimport QuadEdgeSubdivision from './quadedge/QuadEdgeSubdivision';\nimport extend from '../../../../extend';\nimport DelaunayTriangulationBuilder from './DelaunayTriangulationBuilder';\nimport CoordinateArrays from '../geom/CoordinateArrays';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function VoronoiDiagramBuilder() {\n\tthis.siteCoords = null;\n\tthis.tolerance = 0.0;\n\tthis.subdiv = null;\n\tthis.clipEnv = null;\n\tthis.diagramEnv = null;\n}\nextend(VoronoiDiagramBuilder.prototype, {\n\tcreate: function () {\n\t\tif (this.subdiv !== null) return null;\n\t\tvar siteEnv = DelaunayTriangulationBuilder.envelope(this.siteCoords);\n\t\tthis.diagramEnv = siteEnv;\n\t\tvar expandBy = Math.max(this.diagramEnv.getWidth(), this.diagramEnv.getHeight());\n\t\tthis.diagramEnv.expandBy(expandBy);\n\t\tif (this.clipEnv !== null) this.diagramEnv.expandToInclude(this.clipEnv);\n\t\tvar vertices = DelaunayTriangulationBuilder.toVertices(this.siteCoords);\n\t\tthis.subdiv = new QuadEdgeSubdivision(siteEnv, this.tolerance);\n\t\tvar triangulator = new IncrementalDelaunayTriangulator(this.subdiv);\n\t\ttriangulator.insertSites(vertices);\n\t},\n\tgetDiagram: function (geomFact) {\n\t\tthis.create();\n\t\tvar polys = this.subdiv.getVoronoiDiagram(geomFact);\n\t\treturn VoronoiDiagramBuilder.clipGeometryCollection(polys, this.diagramEnv);\n\t},\n\tsetTolerance: function (tolerance) {\n\t\tthis.tolerance = tolerance;\n\t},\n\tsetSites: function () {\n\t\tif (arguments[0] instanceof Geometry) {\n\t\t\tlet geom = arguments[0];\n\t\t\tthis.siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n\t\t} else if (hasInterface(arguments[0], Collection)) {\n\t\t\tlet coords = arguments[0];\n\t\t\tthis.siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n\t\t}\n\t},\n\tsetClipEnvelope: function (clipEnv) {\n\t\tthis.clipEnv = clipEnv;\n\t},\n\tgetSubdivision: function () {\n\t\tthis.create();\n\t\treturn this.subdiv;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn VoronoiDiagramBuilder;\n\t}\n});\nVoronoiDiagramBuilder.clipGeometryCollection = function (geom, clipEnv) {\n\tvar clipPoly = geom.getFactory().toGeometry(clipEnv);\n\tvar clipped = new ArrayList();\n\tfor (var i = 0; i < geom.getNumGeometries(); i++) {\n\t\tvar g = geom.getGeometryN(i);\n\t\tvar result = null;\n\t\tif (clipEnv.contains(g.getEnvelopeInternal())) result = g; else if (clipEnv.intersects(g.getEnvelopeInternal())) {\n\t\t\tresult = clipPoly.intersection(g);\n\t\t\tresult.setUserData(g.getUserData());\n\t\t}\n\t\tif (result !== null && !result.isEmpty()) {\n\t\t\tclipped.add(result);\n\t\t}\n\t}\n\treturn geom.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(clipped));\n};\n","import Coordinate from '../geom/Coordinate';\nimport extend from '../../../../extend';\nimport LineSegment from '../geom/LineSegment';\nimport Comparable from '../../../../java/lang/Comparable';\nexport default function LinearLocation() {\n\tthis.componentIndex = 0;\n\tthis.segmentIndex = 0;\n\tthis.segmentFraction = 0.0;\n\tif (arguments.length === 0) {} else if (arguments.length === 1) {\n\t\tlet loc = arguments[0];\n\t\tthis.componentIndex = loc.componentIndex;\n\t\tthis.segmentIndex = loc.segmentIndex;\n\t\tthis.segmentFraction = loc.segmentFraction;\n\t} else if (arguments.length === 2) {\n\t\tlet segmentIndex = arguments[0], segmentFraction = arguments[1];\n\t\tLinearLocation.call(this, 0, segmentIndex, segmentFraction);\n\t} else if (arguments.length === 3) {\n\t\tlet componentIndex = arguments[0], segmentIndex = arguments[1], segmentFraction = arguments[2];\n\t\tthis.componentIndex = componentIndex;\n\t\tthis.segmentIndex = segmentIndex;\n\t\tthis.segmentFraction = segmentFraction;\n\t\tthis.normalize();\n\t} else if (arguments.length === 4) {\n\t\tlet componentIndex = arguments[0], segmentIndex = arguments[1], segmentFraction = arguments[2], doNormalize = arguments[3];\n\t\tthis.componentIndex = componentIndex;\n\t\tthis.segmentIndex = segmentIndex;\n\t\tthis.segmentFraction = segmentFraction;\n\t\tif (doNormalize) this.normalize();\n\t}\n}\nextend(LinearLocation.prototype, {\n\tgetSegmentIndex: function () {\n\t\treturn this.segmentIndex;\n\t},\n\tgetComponentIndex: function () {\n\t\treturn this.componentIndex;\n\t},\n\tisEndpoint: function (linearGeom) {\n\t\tvar lineComp = linearGeom.getGeometryN(this.componentIndex);\n\t\tvar nseg = lineComp.getNumPoints() - 1;\n\t\treturn this.segmentIndex >= nseg || this.segmentIndex === nseg && this.segmentFraction >= 1.0;\n\t},\n\tisValid: function (linearGeom) {\n\t\tif (this.componentIndex < 0 || this.componentIndex >= linearGeom.getNumGeometries()) return false;\n\t\tvar lineComp = linearGeom.getGeometryN(this.componentIndex);\n\t\tif (this.segmentIndex < 0 || this.segmentIndex > lineComp.getNumPoints()) return false;\n\t\tif (this.segmentIndex === lineComp.getNumPoints() && this.segmentFraction !== 0.0) return false;\n\t\tif (this.segmentFraction < 0.0 || this.segmentFraction > 1.0) return false;\n\t\treturn true;\n\t},\n\tnormalize: function () {\n\t\tif (this.segmentFraction < 0.0) {\n\t\t\tthis.segmentFraction = 0.0;\n\t\t}\n\t\tif (this.segmentFraction > 1.0) {\n\t\t\tthis.segmentFraction = 1.0;\n\t\t}\n\t\tif (this.componentIndex < 0) {\n\t\t\tthis.componentIndex = 0;\n\t\t\tthis.segmentIndex = 0;\n\t\t\tthis.segmentFraction = 0.0;\n\t\t}\n\t\tif (this.segmentIndex < 0) {\n\t\t\tthis.segmentIndex = 0;\n\t\t\tthis.segmentFraction = 0.0;\n\t\t}\n\t\tif (this.segmentFraction === 1.0) {\n\t\t\tthis.segmentFraction = 0.0;\n\t\t\tthis.segmentIndex += 1;\n\t\t}\n\t},\n\ttoLowest: function (linearGeom) {\n\t\tvar lineComp = linearGeom.getGeometryN(this.componentIndex);\n\t\tvar nseg = lineComp.getNumPoints() - 1;\n\t\tif (this.segmentIndex < nseg) return this;\n\t\treturn new LinearLocation(this.componentIndex, nseg, 1.0, false);\n\t},\n\tgetCoordinate: function (linearGeom) {\n\t\tvar lineComp = linearGeom.getGeometryN(this.componentIndex);\n\t\tvar p0 = lineComp.getCoordinateN(this.segmentIndex);\n\t\tif (this.segmentIndex >= lineComp.getNumPoints() - 1) return p0;\n\t\tvar p1 = lineComp.getCoordinateN(this.segmentIndex + 1);\n\t\treturn LinearLocation.pointAlongSegmentByFraction(p0, p1, this.segmentFraction);\n\t},\n\tgetSegmentFraction: function () {\n\t\treturn this.segmentFraction;\n\t},\n\tgetSegment: function (linearGeom) {\n\t\tvar lineComp = linearGeom.getGeometryN(this.componentIndex);\n\t\tvar p0 = lineComp.getCoordinateN(this.segmentIndex);\n\t\tif (this.segmentIndex >= lineComp.getNumPoints() - 1) {\n\t\t\tvar prev = lineComp.getCoordinateN(lineComp.getNumPoints() - 2);\n\t\t\treturn new LineSegment(prev, p0);\n\t\t}\n\t\tvar p1 = lineComp.getCoordinateN(this.segmentIndex + 1);\n\t\treturn new LineSegment(p0, p1);\n\t},\n\tclamp: function (linear) {\n\t\tif (this.componentIndex >= linear.getNumGeometries()) {\n\t\t\tthis.setToEnd(linear);\n\t\t\treturn null;\n\t\t}\n\t\tif (this.segmentIndex >= linear.getNumPoints()) {\n\t\t\tvar line = linear.getGeometryN(this.componentIndex);\n\t\t\tthis.segmentIndex = line.getNumPoints() - 1;\n\t\t\tthis.segmentFraction = 1.0;\n\t\t}\n\t},\n\tsetToEnd: function (linear) {\n\t\tthis.componentIndex = linear.getNumGeometries() - 1;\n\t\tvar lastLine = linear.getGeometryN(this.componentIndex);\n\t\tthis.segmentIndex = lastLine.getNumPoints() - 1;\n\t\tthis.segmentFraction = 1.0;\n\t},\n\tcompareTo: function (o) {\n\t\tvar other = o;\n\t\tif (this.componentIndex < other.componentIndex) return -1;\n\t\tif (this.componentIndex > other.componentIndex) return 1;\n\t\tif (this.segmentIndex < other.segmentIndex) return -1;\n\t\tif (this.segmentIndex > other.segmentIndex) return 1;\n\t\tif (this.segmentFraction < other.segmentFraction) return -1;\n\t\tif (this.segmentFraction > other.segmentFraction) return 1;\n\t\treturn 0;\n\t},\n\tclone: function () {\n\t\treturn new LinearLocation(this.componentIndex, this.segmentIndex, this.segmentFraction);\n\t},\n\ttoString: function () {\n\t\treturn \"LinearLoc[\" + this.componentIndex + \", \" + this.segmentIndex + \", \" + this.segmentFraction + \"]\";\n\t},\n\tisOnSameSegment: function (loc) {\n\t\tif (this.componentIndex !== loc.componentIndex) return false;\n\t\tif (this.segmentIndex === loc.segmentIndex) return true;\n\t\tif (loc.segmentIndex - this.segmentIndex === 1 && loc.segmentFraction === 0.0) return true;\n\t\tif (this.segmentIndex - loc.segmentIndex === 1 && this.segmentFraction === 0.0) return true;\n\t\treturn false;\n\t},\n\tsnapToVertex: function (linearGeom, minDistance) {\n\t\tif (this.segmentFraction <= 0.0 || this.segmentFraction >= 1.0) return null;\n\t\tvar segLen = this.getSegmentLength(linearGeom);\n\t\tvar lenToStart = this.segmentFraction * segLen;\n\t\tvar lenToEnd = segLen - lenToStart;\n\t\tif (lenToStart <= lenToEnd && lenToStart < minDistance) {\n\t\t\tthis.segmentFraction = 0.0;\n\t\t} else if (lenToEnd <= lenToStart && lenToEnd < minDistance) {\n\t\t\tthis.segmentFraction = 1.0;\n\t\t}\n\t},\n\tcompareLocationValues: function (componentIndex1, segmentIndex1, segmentFraction1) {\n\t\tif (this.componentIndex < componentIndex1) return -1;\n\t\tif (this.componentIndex > componentIndex1) return 1;\n\t\tif (this.segmentIndex < segmentIndex1) return -1;\n\t\tif (this.segmentIndex > segmentIndex1) return 1;\n\t\tif (this.segmentFraction < segmentFraction1) return -1;\n\t\tif (this.segmentFraction > segmentFraction1) return 1;\n\t\treturn 0;\n\t},\n\tgetSegmentLength: function (linearGeom) {\n\t\tvar lineComp = linearGeom.getGeometryN(this.componentIndex);\n\t\tvar segIndex = this.segmentIndex;\n\t\tif (this.segmentIndex >= lineComp.getNumPoints() - 1) segIndex = lineComp.getNumPoints() - 2;\n\t\tvar p0 = lineComp.getCoordinateN(segIndex);\n\t\tvar p1 = lineComp.getCoordinateN(segIndex + 1);\n\t\treturn p0.distance(p1);\n\t},\n\tisVertex: function () {\n\t\treturn this.segmentFraction <= 0.0 || this.segmentFraction >= 1.0;\n\t},\n\tinterfaces_: function () {\n\t\treturn [Comparable];\n\t},\n\tgetClass: function () {\n\t\treturn LinearLocation;\n\t}\n});\nLinearLocation.getEndLocation = function (linear) {\n\tvar loc = new LinearLocation();\n\tloc.setToEnd(linear);\n\treturn loc;\n};\nLinearLocation.pointAlongSegmentByFraction = function (p0, p1, frac) {\n\tif (frac <= 0.0) return p0;\n\tif (frac >= 1.0) return p1;\n\tvar x = (p1.x - p0.x) * frac + p0.x;\n\tvar y = (p1.y - p0.y) * frac + p0.y;\n\tvar z = (p1.z - p0.z) * frac + p0.z;\n\treturn new Coordinate(x, y, z);\n};\nLinearLocation.compareLocationValues = function (componentIndex0, segmentIndex0, segmentFraction0, componentIndex1, segmentIndex1, segmentFraction1) {\n\tif (componentIndex0 < componentIndex1) return -1;\n\tif (componentIndex0 > componentIndex1) return 1;\n\tif (segmentIndex0 < segmentIndex1) return -1;\n\tif (segmentIndex0 > segmentIndex1) return 1;\n\tif (segmentFraction0 < segmentFraction1) return -1;\n\tif (segmentFraction0 > segmentFraction1) return 1;\n\treturn 0;\n};\n","import hasInterface from '../../../../hasInterface';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport Lineal from '../geom/Lineal';\nexport default function LinearIterator() {\n\tthis.linearGeom = null;\n\tthis.numLines = null;\n\tthis.currentLine = null;\n\tthis.componentIndex = 0;\n\tthis.vertexIndex = 0;\n\tif (arguments.length === 1) {\n\t\tlet linear = arguments[0];\n\t\tLinearIterator.call(this, linear, 0, 0);\n\t} else if (arguments.length === 2) {\n\t\tlet linear = arguments[0], start = arguments[1];\n\t\tLinearIterator.call(this, linear, start.getComponentIndex(), LinearIterator.segmentEndVertexIndex(start));\n\t} else if (arguments.length === 3) {\n\t\tlet linearGeom = arguments[0], componentIndex = arguments[1], vertexIndex = arguments[2];\n\t\tif (!hasInterface(linearGeom, Lineal)) throw new IllegalArgumentException(\"Lineal geometry is required\");\n\t\tthis.linearGeom = linearGeom;\n\t\tthis.numLines = linearGeom.getNumGeometries();\n\t\tthis.componentIndex = componentIndex;\n\t\tthis.vertexIndex = vertexIndex;\n\t\tthis.loadCurrentLine();\n\t}\n}\nextend(LinearIterator.prototype, {\n\tgetComponentIndex: function () {\n\t\treturn this.componentIndex;\n\t},\n\tgetLine: function () {\n\t\treturn this.currentLine;\n\t},\n\tgetVertexIndex: function () {\n\t\treturn this.vertexIndex;\n\t},\n\tgetSegmentEnd: function () {\n\t\tif (this.vertexIndex < this.getLine().getNumPoints() - 1) return this.currentLine.getCoordinateN(this.vertexIndex + 1);\n\t\treturn null;\n\t},\n\tnext: function () {\n\t\tif (!this.hasNext()) return null;\n\t\tthis.vertexIndex++;\n\t\tif (this.vertexIndex >= this.currentLine.getNumPoints()) {\n\t\t\tthis.componentIndex++;\n\t\t\tthis.loadCurrentLine();\n\t\t\tthis.vertexIndex = 0;\n\t\t}\n\t},\n\tloadCurrentLine: function () {\n\t\tif (this.componentIndex >= this.numLines) {\n\t\t\tthis.currentLine = null;\n\t\t\treturn null;\n\t\t}\n\t\tthis.currentLine = this.linearGeom.getGeometryN(this.componentIndex);\n\t},\n\tgetSegmentStart: function () {\n\t\treturn this.currentLine.getCoordinateN(this.vertexIndex);\n\t},\n\tisEndOfLine: function () {\n\t\tif (this.componentIndex >= this.numLines) return false;\n\t\tif (this.vertexIndex < this.currentLine.getNumPoints() - 1) return false;\n\t\treturn true;\n\t},\n\thasNext: function () {\n\t\tif (this.componentIndex >= this.numLines) return false;\n\t\tif (this.componentIndex === this.numLines - 1 && this.vertexIndex >= this.currentLine.getNumPoints()) return false;\n\t\treturn true;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LinearIterator;\n\t}\n});\nLinearIterator.segmentEndVertexIndex = function (loc) {\n\tif (loc.getSegmentFraction() > 0.0) return loc.getSegmentIndex() + 1;\n\treturn loc.getSegmentIndex();\n};\n","import LinearIterator from './LinearIterator';\nimport LinearLocation from './LinearLocation';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport LineSegment from '../geom/LineSegment';\nimport Assert from '../util/Assert';\nexport default function LocationIndexOfPoint() {\n\tthis.linearGeom = null;\n\tlet linearGeom = arguments[0];\n\tthis.linearGeom = linearGeom;\n}\nextend(LocationIndexOfPoint.prototype, {\n\tindexOf: function (inputPt) {\n\t\treturn this.indexOfFromStart(inputPt, null);\n\t},\n\tindexOfFromStart: function (inputPt, minIndex) {\n\t\tvar minDistance = Double.MAX_VALUE;\n\t\tvar minComponentIndex = 0;\n\t\tvar minSegmentIndex = 0;\n\t\tvar minFrac = -1.0;\n\t\tvar seg = new LineSegment();\n\t\tfor (var it = new LinearIterator(this.linearGeom); it.hasNext(); it.next()) {\n\t\t\tif (!it.isEndOfLine()) {\n\t\t\t\tseg.p0 = it.getSegmentStart();\n\t\t\t\tseg.p1 = it.getSegmentEnd();\n\t\t\t\tvar segDistance = seg.distance(inputPt);\n\t\t\t\tvar segFrac = seg.segmentFraction(inputPt);\n\t\t\t\tvar candidateComponentIndex = it.getComponentIndex();\n\t\t\t\tvar candidateSegmentIndex = it.getVertexIndex();\n\t\t\t\tif (segDistance < minDistance) {\n\t\t\t\t\tif (minIndex === null || minIndex.compareLocationValues(candidateComponentIndex, candidateSegmentIndex, segFrac) < 0) {\n\t\t\t\t\t\tminComponentIndex = candidateComponentIndex;\n\t\t\t\t\t\tminSegmentIndex = candidateSegmentIndex;\n\t\t\t\t\t\tminFrac = segFrac;\n\t\t\t\t\t\tminDistance = segDistance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (minDistance === Double.MAX_VALUE) {\n\t\t\treturn new LinearLocation(minIndex);\n\t\t}\n\t\tvar loc = new LinearLocation(minComponentIndex, minSegmentIndex, minFrac);\n\t\treturn loc;\n\t},\n\tindexOfAfter: function (inputPt, minIndex) {\n\t\tif (minIndex === null) return this.indexOf(inputPt);\n\t\tvar endLoc = LinearLocation.getEndLocation(this.linearGeom);\n\t\tif (endLoc.compareTo(minIndex) <= 0) return endLoc;\n\t\tvar closestAfter = this.indexOfFromStart(inputPt, minIndex);\n\t\tAssert.isTrue(closestAfter.compareTo(minIndex) >= 0, \"computed location is before specified minimum location\");\n\t\treturn closestAfter;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LocationIndexOfPoint;\n\t}\n});\nLocationIndexOfPoint.indexOf = function (linearGeom, inputPt) {\n\tvar locater = new LocationIndexOfPoint(linearGeom);\n\treturn locater.indexOf(inputPt);\n};\nLocationIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {\n\tvar locater = new LocationIndexOfPoint(linearGeom);\n\treturn locater.indexOfAfter(inputPt, minIndex);\n};\n","import extend from '../../../../extend';\nimport LocationIndexOfPoint from './LocationIndexOfPoint';\nexport default function LocationIndexOfLine() {\n\tthis.linearGeom = null;\n\tlet linearGeom = arguments[0];\n\tthis.linearGeom = linearGeom;\n}\nextend(LocationIndexOfLine.prototype, {\n\tindicesOf: function (subLine) {\n\t\tvar startPt = subLine.getGeometryN(0).getCoordinateN(0);\n\t\tvar lastLine = subLine.getGeometryN(subLine.getNumGeometries() - 1);\n\t\tvar endPt = lastLine.getCoordinateN(lastLine.getNumPoints() - 1);\n\t\tvar locPt = new LocationIndexOfPoint(this.linearGeom);\n\t\tvar subLineLoc = new Array(2).fill(null);\n\t\tsubLineLoc[0] = locPt.indexOf(startPt);\n\t\tif (subLine.getLength() === 0.0) {\n\t\t\tsubLineLoc[1] = subLineLoc[0].clone();\n\t\t} else {\n\t\t\tsubLineLoc[1] = locPt.indexOfAfter(endPt, subLineLoc[0]);\n\t\t}\n\t\treturn subLineLoc;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LocationIndexOfLine;\n\t}\n});\nLocationIndexOfLine.indicesOf = function (linearGeom, subLine) {\n\tvar locater = new LocationIndexOfLine(linearGeom);\n\treturn locater.indicesOf(subLine);\n};\n","import CoordinateList from '../geom/CoordinateList';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport extend from '../../../../extend';\nimport ArrayList from '../../../../java/util/ArrayList';\nexport default function LinearGeometryBuilder() {\n\tthis.geomFact = null;\n\tthis.lines = new ArrayList();\n\tthis.coordList = null;\n\tthis.ignoreInvalidLines = false;\n\tthis.fixInvalidLines = false;\n\tthis.lastPt = null;\n\tlet geomFact = arguments[0];\n\tthis.geomFact = geomFact;\n}\nextend(LinearGeometryBuilder.prototype, {\n\tgetGeometry: function () {\n\t\tthis.endLine();\n\t\treturn this.geomFact.buildGeometry(this.lines);\n\t},\n\tgetLastCoordinate: function () {\n\t\treturn this.lastPt;\n\t},\n\tendLine: function () {\n\t\tif (this.coordList === null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.ignoreInvalidLines && this.coordList.size() < 2) {\n\t\t\tthis.coordList = null;\n\t\t\treturn null;\n\t\t}\n\t\tvar rawPts = this.coordList.toCoordinateArray();\n\t\tvar pts = rawPts;\n\t\tif (this.fixInvalidLines) pts = this.validCoordinateSequence(rawPts);\n\t\tthis.coordList = null;\n\t\tvar line = null;\n\t\ttry {\n\t\t\tline = this.geomFact.createLineString(pts);\n\t\t} catch (ex) {\n\t\t\tif (ex instanceof IllegalArgumentException) {\n\t\t\t\tif (!this.ignoreInvalidLines) throw ex;\n\t\t\t} else throw ex;\n\t\t} finally {}\n\t\tif (line !== null) this.lines.add(line);\n\t},\n\tsetFixInvalidLines: function (fixInvalidLines) {\n\t\tthis.fixInvalidLines = fixInvalidLines;\n\t},\n\tadd: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet pt = arguments[0];\n\t\t\tthis.add(pt, true);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet pt = arguments[0], allowRepeatedPoints = arguments[1];\n\t\t\tif (this.coordList === null) this.coordList = new CoordinateList();\n\t\t\tthis.coordList.add(pt, allowRepeatedPoints);\n\t\t\tthis.lastPt = pt;\n\t\t}\n\t},\n\tsetIgnoreInvalidLines: function (ignoreInvalidLines) {\n\t\tthis.ignoreInvalidLines = ignoreInvalidLines;\n\t},\n\tvalidCoordinateSequence: function (pts) {\n\t\tif (pts.length >= 2) return pts;\n\t\tvar validPts = [pts[0], pts[0]];\n\t\treturn validPts;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LinearGeometryBuilder;\n\t}\n});\n","import LineString from '../geom/LineString';\nimport CoordinateList from '../geom/CoordinateList';\nimport LinearIterator from './LinearIterator';\nimport extend from '../../../../extend';\nimport Assert from '../util/Assert';\nimport LinearGeometryBuilder from './LinearGeometryBuilder';\nimport MultiLineString from '../geom/MultiLineString';\nexport default function ExtractLineByLocation() {\n\tthis.line = null;\n\tlet line = arguments[0];\n\tthis.line = line;\n}\nextend(ExtractLineByLocation.prototype, {\n\tcomputeLinear: function (start, end) {\n\t\tvar builder = new LinearGeometryBuilder(this.line.getFactory());\n\t\tbuilder.setFixInvalidLines(true);\n\t\tif (!start.isVertex()) builder.add(start.getCoordinate(this.line));\n\t\tfor (var it = new LinearIterator(this.line, start); it.hasNext(); it.next()) {\n\t\t\tif (end.compareLocationValues(it.getComponentIndex(), it.getVertexIndex(), 0.0) < 0) break;\n\t\t\tvar pt = it.getSegmentStart();\n\t\t\tbuilder.add(pt);\n\t\t\tif (it.isEndOfLine()) builder.endLine();\n\t\t}\n\t\tif (!end.isVertex()) builder.add(end.getCoordinate(this.line));\n\t\treturn builder.getGeometry();\n\t},\n\tcomputeLine: function (start, end) {\n\t\tvar coordinates = this.line.getCoordinates();\n\t\tvar newCoordinates = new CoordinateList();\n\t\tvar startSegmentIndex = start.getSegmentIndex();\n\t\tif (start.getSegmentFraction() > 0.0) startSegmentIndex += 1;\n\t\tvar lastSegmentIndex = end.getSegmentIndex();\n\t\tif (end.getSegmentFraction() === 1.0) lastSegmentIndex += 1;\n\t\tif (lastSegmentIndex >= coordinates.length) lastSegmentIndex = coordinates.length - 1;\n\t\tif (!start.isVertex()) newCoordinates.add(start.getCoordinate(this.line));\n\t\tfor (var i = startSegmentIndex; i <= lastSegmentIndex; i++) {\n\t\t\tnewCoordinates.add(coordinates[i]);\n\t\t}\n\t\tif (!end.isVertex()) newCoordinates.add(end.getCoordinate(this.line));\n\t\tif (newCoordinates.size() <= 0) newCoordinates.add(start.getCoordinate(this.line));\n\t\tvar newCoordinateArray = newCoordinates.toCoordinateArray();\n\t\tif (newCoordinateArray.length <= 1) {\n\t\t\tnewCoordinateArray = [newCoordinateArray[0], newCoordinateArray[0]];\n\t\t}\n\t\treturn this.line.getFactory().createLineString(newCoordinateArray);\n\t},\n\textract: function (start, end) {\n\t\tif (end.compareTo(start) < 0) {\n\t\t\treturn this.reverse(this.computeLinear(end, start));\n\t\t}\n\t\treturn this.computeLinear(start, end);\n\t},\n\treverse: function (linear) {\n\t\tif (linear instanceof LineString) return linear.reverse();\n\t\tif (linear instanceof MultiLineString) return linear.reverse();\n\t\tAssert.shouldNeverReachHere(\"non-linear geometry encountered\");\n\t\treturn null;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn ExtractLineByLocation;\n\t}\n});\nExtractLineByLocation.extract = function (line, start, end) {\n\tvar ls = new ExtractLineByLocation(line);\n\treturn ls.extract(start, end);\n};\n","import LineString from '../geom/LineString';\nimport IllegalArgumentException from '../../../../java/lang/IllegalArgumentException';\nimport LinearLocation from './LinearLocation';\nimport extend from '../../../../extend';\nimport LocationIndexOfPoint from './LocationIndexOfPoint';\nimport LocationIndexOfLine from './LocationIndexOfLine';\nimport ExtractLineByLocation from './ExtractLineByLocation';\nimport MultiLineString from '../geom/MultiLineString';\nexport default function LocationIndexedLine() {\n\tthis.linearGeom = null;\n\tlet linearGeom = arguments[0];\n\tthis.linearGeom = linearGeom;\n\tthis.checkGeometryType();\n}\nextend(LocationIndexedLine.prototype, {\n\tclampIndex: function (index) {\n\t\tvar loc = index.clone();\n\t\tloc.clamp(this.linearGeom);\n\t\treturn loc;\n\t},\n\tproject: function (pt) {\n\t\treturn LocationIndexOfPoint.indexOf(this.linearGeom, pt);\n\t},\n\tcheckGeometryType: function () {\n\t\tif (!(this.linearGeom instanceof LineString || this.linearGeom instanceof MultiLineString)) throw new IllegalArgumentException(\"Input geometry must be linear\");\n\t},\n\textractPoint: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet index = arguments[0];\n\t\t\treturn index.getCoordinate(this.linearGeom);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], offsetDistance = arguments[1];\n\t\t\tvar indexLow = index.toLowest(this.linearGeom);\n\t\t\treturn indexLow.getSegment(this.linearGeom).pointAlongOffset(indexLow.getSegmentFraction(), offsetDistance);\n\t\t}\n\t},\n\tisValidIndex: function (index) {\n\t\treturn index.isValid(this.linearGeom);\n\t},\n\tgetEndIndex: function () {\n\t\treturn LinearLocation.getEndLocation(this.linearGeom);\n\t},\n\tgetStartIndex: function () {\n\t\treturn new LinearLocation();\n\t},\n\tindexOfAfter: function (pt, minIndex) {\n\t\treturn LocationIndexOfPoint.indexOfAfter(this.linearGeom, pt, minIndex);\n\t},\n\textractLine: function (startIndex, endIndex) {\n\t\treturn ExtractLineByLocation.extract(this.linearGeom, startIndex, endIndex);\n\t},\n\tindexOf: function (pt) {\n\t\treturn LocationIndexOfPoint.indexOf(this.linearGeom, pt);\n\t},\n\tindicesOf: function (subLine) {\n\t\treturn LocationIndexOfLine.indicesOf(this.linearGeom, subLine);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LocationIndexedLine;\n\t}\n});\n","import LinearIterator from './LinearIterator';\nimport Double from '../../../../java/lang/Double';\nimport extend from '../../../../extend';\nimport LineSegment from '../geom/LineSegment';\nimport Assert from '../util/Assert';\nexport default function LengthIndexOfPoint() {\n\tthis.linearGeom = null;\n\tlet linearGeom = arguments[0];\n\tthis.linearGeom = linearGeom;\n}\nextend(LengthIndexOfPoint.prototype, {\n\tindexOf: function (inputPt) {\n\t\treturn this.indexOfFromStart(inputPt, -1.0);\n\t},\n\tindexOfFromStart: function (inputPt, minIndex) {\n\t\tvar minDistance = Double.MAX_VALUE;\n\t\tvar ptMeasure = minIndex;\n\t\tvar segmentStartMeasure = 0.0;\n\t\tvar seg = new LineSegment();\n\t\tvar it = new LinearIterator(this.linearGeom);\n\t\twhile (it.hasNext()) {\n\t\t\tif (!it.isEndOfLine()) {\n\t\t\t\tseg.p0 = it.getSegmentStart();\n\t\t\t\tseg.p1 = it.getSegmentEnd();\n\t\t\t\tvar segDistance = seg.distance(inputPt);\n\t\t\t\tvar segMeasureToPt = this.segmentNearestMeasure(seg, inputPt, segmentStartMeasure);\n\t\t\t\tif (segDistance < minDistance && segMeasureToPt > minIndex) {\n\t\t\t\t\tptMeasure = segMeasureToPt;\n\t\t\t\t\tminDistance = segDistance;\n\t\t\t\t}\n\t\t\t\tsegmentStartMeasure += seg.getLength();\n\t\t\t}\n\t\t\tit.next();\n\t\t}\n\t\treturn ptMeasure;\n\t},\n\tindexOfAfter: function (inputPt, minIndex) {\n\t\tif (minIndex < 0.0) return this.indexOf(inputPt);\n\t\tvar endIndex = this.linearGeom.getLength();\n\t\tif (endIndex < minIndex) return endIndex;\n\t\tvar closestAfter = this.indexOfFromStart(inputPt, minIndex);\n\t\tAssert.isTrue(closestAfter >= minIndex, \"computed index is before specified minimum index\");\n\t\treturn closestAfter;\n\t},\n\tsegmentNearestMeasure: function (seg, inputPt, segmentStartMeasure) {\n\t\tvar projFactor = seg.projectionFactor(inputPt);\n\t\tif (projFactor <= 0.0) return segmentStartMeasure;\n\t\tif (projFactor <= 1.0) return segmentStartMeasure + projFactor * seg.getLength();\n\t\treturn segmentStartMeasure + seg.getLength();\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LengthIndexOfPoint;\n\t}\n});\nLengthIndexOfPoint.indexOf = function (linearGeom, inputPt) {\n\tvar locater = new LengthIndexOfPoint(linearGeom);\n\treturn locater.indexOf(inputPt);\n};\nLengthIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {\n\tvar locater = new LengthIndexOfPoint(linearGeom);\n\treturn locater.indexOfAfter(inputPt, minIndex);\n};\n","import LinearIterator from './LinearIterator';\nimport LinearLocation from './LinearLocation';\nimport extend from '../../../../extend';\nexport default function LengthLocationMap() {\n\tthis.linearGeom = null;\n\tlet linearGeom = arguments[0];\n\tthis.linearGeom = linearGeom;\n}\nextend(LengthLocationMap.prototype, {\n\tgetLength: function (loc) {\n\t\tvar totalLength = 0.0;\n\t\tvar it = new LinearIterator(this.linearGeom);\n\t\twhile (it.hasNext()) {\n\t\t\tif (!it.isEndOfLine()) {\n\t\t\t\tvar p0 = it.getSegmentStart();\n\t\t\t\tvar p1 = it.getSegmentEnd();\n\t\t\t\tvar segLen = p1.distance(p0);\n\t\t\t\tif (loc.getComponentIndex() === it.getComponentIndex() && loc.getSegmentIndex() === it.getVertexIndex()) {\n\t\t\t\t\treturn totalLength + segLen * loc.getSegmentFraction();\n\t\t\t\t}\n\t\t\t\ttotalLength += segLen;\n\t\t\t}\n\t\t\tit.next();\n\t\t}\n\t\treturn totalLength;\n\t},\n\tresolveHigher: function (loc) {\n\t\tif (!loc.isEndpoint(this.linearGeom)) return loc;\n\t\tvar compIndex = loc.getComponentIndex();\n\t\tif (compIndex >= this.linearGeom.getNumGeometries() - 1) return loc;\n\t\tdo {\n\t\t\tcompIndex++;\n\t\t} while (compIndex < this.linearGeom.getNumGeometries() - 1 && this.linearGeom.getGeometryN(compIndex).getLength() === 0);\n\t\treturn new LinearLocation(compIndex, 0, 0.0);\n\t},\n\tgetLocation: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet length = arguments[0];\n\t\t\treturn this.getLocation(length, true);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet length = arguments[0], resolveLower = arguments[1];\n\t\t\tvar forwardLength = length;\n\t\t\tif (length < 0.0) {\n\t\t\t\tvar lineLen = this.linearGeom.getLength();\n\t\t\t\tforwardLength = lineLen + length;\n\t\t\t}\n\t\t\tvar loc = this.getLocationForward(forwardLength);\n\t\t\tif (resolveLower) {\n\t\t\t\treturn loc;\n\t\t\t}\n\t\t\treturn this.resolveHigher(loc);\n\t\t}\n\t},\n\tgetLocationForward: function (length) {\n\t\tif (length <= 0.0) return new LinearLocation();\n\t\tvar totalLength = 0.0;\n\t\tvar it = new LinearIterator(this.linearGeom);\n\t\twhile (it.hasNext()) {\n\t\t\tif (it.isEndOfLine()) {\n\t\t\t\tif (totalLength === length) {\n\t\t\t\t\tvar compIndex = it.getComponentIndex();\n\t\t\t\t\tvar segIndex = it.getVertexIndex();\n\t\t\t\t\treturn new LinearLocation(compIndex, segIndex, 0.0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar p0 = it.getSegmentStart();\n\t\t\t\tvar p1 = it.getSegmentEnd();\n\t\t\t\tvar segLen = p1.distance(p0);\n\t\t\t\tif (totalLength + segLen > length) {\n\t\t\t\t\tvar frac = (length - totalLength) / segLen;\n\t\t\t\t\tvar compIndex = it.getComponentIndex();\n\t\t\t\t\tvar segIndex = it.getVertexIndex();\n\t\t\t\t\treturn new LinearLocation(compIndex, segIndex, frac);\n\t\t\t\t}\n\t\t\t\ttotalLength += segLen;\n\t\t\t}\n\t\t\tit.next();\n\t\t}\n\t\treturn LinearLocation.getEndLocation(this.linearGeom);\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LengthLocationMap;\n\t}\n});\nLengthLocationMap.getLength = function (linearGeom, loc) {\n\tvar locater = new LengthLocationMap(linearGeom);\n\treturn locater.getLength(loc);\n};\nLengthLocationMap.getLocation = function () {\n\tif (arguments.length === 2) {\n\t\tlet linearGeom = arguments[0], length = arguments[1];\n\t\tvar locater = new LengthLocationMap(linearGeom);\n\t\treturn locater.getLocation(length);\n\t} else if (arguments.length === 3) {\n\t\tlet linearGeom = arguments[0], length = arguments[1], resolveLower = arguments[2];\n\t\tvar locater = new LengthLocationMap(linearGeom);\n\t\treturn locater.getLocation(length, resolveLower);\n\t}\n};\n","import LocationIndexedLine from './LocationIndexedLine';\nimport extend from '../../../../extend';\nimport LengthIndexOfPoint from './LengthIndexOfPoint';\nimport LocationIndexOfLine from './LocationIndexOfLine';\nimport LengthLocationMap from './LengthLocationMap';\nimport ExtractLineByLocation from './ExtractLineByLocation';\nexport default function LengthIndexedLine() {\n\tthis.linearGeom = null;\n\tlet linearGeom = arguments[0];\n\tthis.linearGeom = linearGeom;\n}\nextend(LengthIndexedLine.prototype, {\n\tclampIndex: function (index) {\n\t\tvar posIndex = this.positiveIndex(index);\n\t\tvar startIndex = this.getStartIndex();\n\t\tif (posIndex < startIndex) return startIndex;\n\t\tvar endIndex = this.getEndIndex();\n\t\tif (posIndex > endIndex) return endIndex;\n\t\treturn posIndex;\n\t},\n\tlocationOf: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet index = arguments[0];\n\t\t\treturn LengthLocationMap.getLocation(this.linearGeom, index);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], resolveLower = arguments[1];\n\t\t\treturn LengthLocationMap.getLocation(this.linearGeom, index, resolveLower);\n\t\t}\n\t},\n\tproject: function (pt) {\n\t\treturn LengthIndexOfPoint.indexOf(this.linearGeom, pt);\n\t},\n\tpositiveIndex: function (index) {\n\t\tif (index >= 0.0) return index;\n\t\treturn this.linearGeom.getLength() + index;\n\t},\n\textractPoint: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet index = arguments[0];\n\t\t\tvar loc = LengthLocationMap.getLocation(this.linearGeom, index);\n\t\t\treturn loc.getCoordinate(this.linearGeom);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet index = arguments[0], offsetDistance = arguments[1];\n\t\t\tvar loc = LengthLocationMap.getLocation(this.linearGeom, index);\n\t\t\tvar locLow = loc.toLowest(this.linearGeom);\n\t\t\treturn locLow.getSegment(this.linearGeom).pointAlongOffset(locLow.getSegmentFraction(), offsetDistance);\n\t\t}\n\t},\n\tisValidIndex: function (index) {\n\t\treturn index >= this.getStartIndex() && index <= this.getEndIndex();\n\t},\n\tgetEndIndex: function () {\n\t\treturn this.linearGeom.getLength();\n\t},\n\tgetStartIndex: function () {\n\t\treturn 0.0;\n\t},\n\tindexOfAfter: function (pt, minIndex) {\n\t\treturn LengthIndexOfPoint.indexOfAfter(this.linearGeom, pt, minIndex);\n\t},\n\textractLine: function (startIndex, endIndex) {\n\t\tvar lil = new LocationIndexedLine(this.linearGeom);\n\t\tvar startIndex2 = this.clampIndex(startIndex);\n\t\tvar endIndex2 = this.clampIndex(endIndex);\n\t\tvar resolveStartLower = startIndex2 === endIndex2;\n\t\tvar startLoc = this.locationOf(startIndex2, resolveStartLower);\n\t\tvar endLoc = this.locationOf(endIndex2);\n\t\treturn ExtractLineByLocation.extract(this.linearGeom, startLoc, endLoc);\n\t},\n\tindexOf: function (pt) {\n\t\treturn LengthIndexOfPoint.indexOf(this.linearGeom, pt);\n\t},\n\tindicesOf: function (subLine) {\n\t\tvar locIndex = LocationIndexOfLine.indicesOf(this.linearGeom, subLine);\n\t\tvar index = [LengthLocationMap.getLength(this.linearGeom, locIndex[0]), LengthLocationMap.getLength(this.linearGeom, locIndex[1])];\n\t\treturn index;\n\t},\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn LengthIndexedLine;\n\t}\n});\n","import SnapIfNeededOverlayOp from '../overlay/snap/SnapIfNeededOverlayOp';\nimport extend from '../../../../../extend';\nimport OverlayOp from '../overlay/OverlayOp';\nexport default function UnionOp() {}\nextend(UnionOp.prototype, {\n\tinterfaces_: function () {\n\t\treturn [];\n\t},\n\tgetClass: function () {\n\t\treturn UnionOp;\n\t}\n});\nUnionOp.union = function (g, other) {\n\tif (g.isEmpty() || other.isEmpty()) {\n\t\tif (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());\n\t\tif (g.isEmpty()) return other.copy();\n\t\tif (other.isEmpty()) return g.copy();\n\t}\n\tg.checkNotGeometryCollection(g);\n\tg.checkNotGeometryCollection(other);\n\treturn SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);\n};\n","/* Polyfill service v3.13.0\n * For detailed credits and licence information see http://github.com/financial-times/polyfill-service\n *\n * - Array.prototype.fill, License: CC0 */\n\nif (!('fill' in Array.prototype)) {\n  Object.defineProperty(Array.prototype, 'fill', {\n    configurable: true,\n    value: function fill(value) {\n      if (this === undefined || this === null) {\n        throw new TypeError(this + ' is not an object');\n      }\n\n      var arrayLike = Object(this);\n\n      var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;\n\n      var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;\n\n      relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);\n\n      var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;\n\n      relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);\n\n      while (relativeStart < relativeEnd) {\n        arrayLike[relativeStart] = value;\n\n        ++relativeStart;\n      }\n\n      return arrayLike;\n    },\n    writable: true\n  });\n}\n","Number.isFinite = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value)\n}\n\nNumber.isInteger = Number.isInteger || function (val) {\n  return typeof val === 'number' &&\n  isFinite(val) &&\n  Math.floor(val) === val\n}\n\nNumber.parseFloat = Number.parseFloat || parseFloat\n\nNumber.isNaN = Number.isNaN || function (value) {\n  return value !== value // eslint-disable-line\n}\n","Math.trunc = Math.trunc || function(x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n}\n","export default function (target, source) {\n  for (let key in source) {\n    if (source.hasOwnProperty(key)) target[key] = source[key]\n  }\n}\n","export default function (c, p) {\n  c.prototype = Object.create(p.prototype)\n  c.prototype.constructor = c\n}\n","export default function (o, i) {\n  return o.interfaces_ && o.interfaces_().indexOf(i) > -1\n}\n","import Arrays from './Arrays'\nimport ArrayList from './ArrayList'\n\nconst Collections = {\n  reverseOrder: function () {\n    return {\n      compare (a, b) {\n        return b.compareTo(a)\n      }\n    }\n  },\n  min: function (l) {\n    Collections.sort(l)\n    return l.get(0)\n  },\n  sort: function (l, c) {\n    const a = l.toArray()\n    if (c) {\n      Arrays.sort(a, c)\n    } else {\n      Arrays.sort(a)\n    }\n    const i = l.iterator()\n    for (let pos = 0, alen = a.length; pos < alen; pos++) {\n      i.next()\n      i.set(a[pos])\n    }\n  },\n  singletonList: function (o) {\n    const arrayList = new ArrayList()\n    arrayList.add(o)\n    return arrayList\n  }\n}\n\nexport default Collections\n","import WKTWriter from './io/WKTWriter';\nimport GeometryCollectionMapper from './geom/util/GeometryCollectionMapper';\nimport IsValidOp from './operation/valid/IsValidOp';\nimport InteriorPointArea from './algorithm/InteriorPointArea';\nimport UnaryUnionOp from './operation/union/UnaryUnionOp';\nimport UnionOp from './operation/union/UnionOp';\nimport SnapIfNeededOverlayOp from './operation/overlay/snap/SnapIfNeededOverlayOp';\nimport InteriorPointLine from './algorithm/InteriorPointLine';\nimport IsSimpleOp from './operation/IsSimpleOp';\nimport BufferOp from './operation/buffer/BufferOp';\nimport ConvexHull from './algorithm/ConvexHull';\nimport Centroid from './algorithm/Centroid';\nimport Comparable from '../../../java/lang/Comparable';\nimport RelateOp from './operation/relate/RelateOp';\nimport InteriorPointPoint from './algorithm/InteriorPointPoint';\nimport Cloneable from '../../../java/lang/Cloneable';\nimport Serializable from '../../../java/io/Serializable';\nimport DistanceOp from './operation/distance/DistanceOp';\nimport Envelope from './geom/Envelope';\nimport RectangleContains from './operation/predicate/RectangleContains';\nimport Assert from './util/Assert';\nimport RectangleIntersects from './operation/predicate/RectangleIntersects';\nimport OverlayOp from './operation/overlay/OverlayOp';\n\nimport Geometry from './geom/Geometry';\nimport GeometryCollection from './geom/GeometryCollection';\n\nimport extend from '../../../extend';\n\nextend(Geometry.prototype, {\n\tequalsTopo: function (g) {\n\t\tif (!this.getEnvelopeInternal().equals(g.getEnvelopeInternal())) return false;\n\t\treturn RelateOp.relate(this, g).isEquals(this.getDimension(), g.getDimension());\n\t},\n\tunion: function () {\n\t\tif (arguments.length === 0) {\n\t\t\treturn UnaryUnionOp.union(this);\n\t\t} else if (arguments.length === 1) {\n\t\t\tlet other = arguments[0];\n\t\t\treturn UnionOp.union(this, other);\n\t\t}\n\t},\n\tisValid: function () {\n\t\treturn IsValidOp.isValid(this);\n\t},\n\tintersection: function (other) {\n\t\tif (this.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, this, other, this.factory);\n\t\tif (this.isGeometryCollection()) {\n\t\t\tvar g2 = other;\n\t\t\treturn GeometryCollectionMapper.map(this, {\n\t\t\t\tinterfaces_: function () {\n\t\t\t\t\treturn [MapOp];\n\t\t\t\t},\n\t\t\t\tmap: function (g) {\n\t\t\t\t\treturn g.intersection(g2);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.checkNotGeometryCollection(this);\n\t\tthis.checkNotGeometryCollection(other);\n\t\treturn SnapIfNeededOverlayOp.overlayOp(this, other, OverlayOp.INTERSECTION);\n\t},\n\tcovers: function (g) {\n\t\treturn RelateOp.covers(this, g);\n\t},\n\tcoveredBy: function (g) {\n\t\treturn RelateOp.coveredBy(this, g);\n\t},\n\ttouches: function (g) {\n\t\treturn RelateOp.touches(this, g);\n\t},\n\tintersects: function (g) {\n\t\treturn RelateOp.intersects(this, g);\n\t},\n\twithin: function (g) {\n\t\treturn RelateOp.within(this, g);\n\t},\n\toverlaps: function (g) {\n\t\treturn RelateOp.overlaps(this, g);\n\t},\n\tdisjoint: function (g) {\n\t\treturn RelateOp.disjoint(this, g);\n\t},\n\tcrosses: function (g) {\n\t\treturn RelateOp.crosses(this, g);\n\t},\n\tbuffer: function () {\n\t\tif (arguments.length === 1) {\n\t\t\tlet distance = arguments[0];\n\t\t\treturn BufferOp.bufferOp(this, distance);\n\t\t} else if (arguments.length === 2) {\n\t\t\tlet distance = arguments[0], quadrantSegments = arguments[1];\n\t\t\treturn BufferOp.bufferOp(this, distance, quadrantSegments);\n\t\t} else if (arguments.length === 3) {\n\t\t\tlet distance = arguments[0], quadrantSegments = arguments[1], endCapStyle = arguments[2];\n\t\t\treturn BufferOp.bufferOp(this, distance, quadrantSegments, endCapStyle);\n\t\t}\n\t},\n\tconvexHull: function () {\n\t\treturn new ConvexHull(this).getConvexHull();\n\t},\n\trelate: function (...args) {\n\t\treturn RelateOp.relate(this, ...args);\n\t},\n\tgetCentroid: function () {\n\t\tif (this.isEmpty()) return this.factory.createPoint();\n\t\tvar centPt = Centroid.getCentroid(this);\n\t\treturn this.createPointFromInternalCoord(centPt, this);\n\t},\n\tgetInteriorPoint: function () {\n\t\tif (this.isEmpty()) return this.factory.createPoint();\n\t\tvar interiorPt = null;\n\t\tvar dim = this.getDimension();\n\t\tif (dim === 0) {\n\t\t\tvar intPt = new InteriorPointPoint(this);\n\t\t\tinteriorPt = intPt.getInteriorPoint();\n\t\t} else if (dim === 1) {\n\t\t\tvar intPt = new InteriorPointLine(this);\n\t\t\tinteriorPt = intPt.getInteriorPoint();\n\t\t} else {\n\t\t\tvar intPt = new InteriorPointArea(this);\n\t\t\tinteriorPt = intPt.getInteriorPoint();\n\t\t}\n\t\treturn this.createPointFromInternalCoord(interiorPt, this);\n\t},\n\tsymDifference: function (other) {\n\t\tif (this.isEmpty() || other.isEmpty()) {\n\t\t\tif (this.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, this, other, this.factory);\n\t\t\tif (this.isEmpty()) return other.copy();\n\t\t\tif (other.isEmpty()) return this.copy();\n\t\t}\n\t\tthis.checkNotGeometryCollection(this);\n\t\tthis.checkNotGeometryCollection(other);\n\t\treturn SnapIfNeededOverlayOp.overlayOp(this, other, OverlayOp.SYMDIFFERENCE);\n\t},\n\tcreatePointFromInternalCoord: function (coord, exemplar) {\n\t\texemplar.getPrecisionModel().makePrecise(coord);\n\t\treturn exemplar.getFactory().createPoint(coord);\n\t},\n\ttoText: function () {\n\t\tvar writer = new WKTWriter();\n\t\treturn writer.write(this);\n\t},\n\ttoString: function() {\n\t\tthis.toText();\n\t},\n\tcontains: function (g) {\n\t\treturn RelateOp.contains(this, g);\n\t},\n\tdifference: function (other) {\n\t\tif (this.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, this, other, this.factory);\n\t\tif (other.isEmpty()) return this.copy();\n\t\tthis.checkNotGeometryCollection(this);\n\t\tthis.checkNotGeometryCollection(other);\n\t\treturn SnapIfNeededOverlayOp.overlayOp(this, other, OverlayOp.DIFFERENCE);\n\t},\n\tisSimple: function () {\n\t\tvar op = new IsSimpleOp(this);\n\t\treturn op.isSimple();\n\t},\n\tisWithinDistance: function (geom, distance) {\n\t\tvar envDist = this.getEnvelopeInternal().distance(geom.getEnvelopeInternal());\n\t\tif (envDist > distance) return false;\n\t\treturn DistanceOp.isWithinDistance(this, geom, distance);\n\t},\n\tdistance: function (g) {\n\t\treturn DistanceOp.distance(this, g);\n\t},\n\tisEquivalentClass: function (other) {\n\t\treturn this.getClass() === other.getClass();\n\t}\n})\n","import './Array'\nimport './Number'\nimport './Math'\n\nimport * as geom from './org/locationtech/jts/geom'\nimport * as algorithm from './org/locationtech/jts/algorithm'\nimport * as densify from './org/locationtech/jts/densify'\nimport * as dissolve from './org/locationtech/jts/dissolve'\nimport * as geomgraph from './org/locationtech/jts/geomgraph'\nimport * as index from './org/locationtech/jts/index'\nimport * as io from './org/locationtech/jts/io'\nimport * as noding from './org/locationtech/jts/noding'\nimport * as operation from './org/locationtech/jts/operation'\nimport * as precision from './org/locationtech/jts/precision'\nimport * as simplify from './org/locationtech/jts/simplify'\nimport * as triangulate from './org/locationtech/jts/triangulate'\nimport * as linearref from './org/locationtech/jts/linearref'\n\nimport './org/locationtech/jts/monkey'\n\nconst version = 'npm_package_version (git_hash)'\nexport {\n  version,\n  algorithm,\n  densify,\n  dissolve,\n  geom,\n  geomgraph,\n  index,\n  io,\n  noding,\n  operation,\n  precision,\n  simplify,\n  triangulate,\n  linearref\n}\n"]}